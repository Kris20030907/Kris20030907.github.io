<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kafka 副本机制详解</title>
      <link href="/2024/10/07/kafka-fu-ben-ji-zhi-xiang-jie/"/>
      <url>/2024/10/07/kafka-fu-ben-ji-zhi-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>主要介绍 kafka 的副本机制是什么，如何处理读写，副本存储在哪，以及 kafka 如何根据副本实现高可用，ISR 机制。为什么不用 mysql 那种主从架构（比如 follower 节点来提高读性能，leader 节点只负责写）有什么好处，mysql 那边为什么不这样设计之类的问题。</p><h2 id="一般的分布式副本机制是什么"><a href="#一般的分布式副本机制是什么" class="headerlink" title="一般的分布式副本机制是什么"></a>一般的分布式副本机制是什么</h2><p>一般的分布式副本机制实际上就是官方给出的说法，主要是说明副本机制需要保证什么特性。</p><p>副本机制（replication），也可以说是备份机制。体现在<strong>一个分布式系统中多个互联的机器上保存相同的数据副本</strong>。</p><p>有什么好处？</p><ol><li><mark style="background: #FFFF00;">提高数据冗余</mark>：<u>当系统的一部分组件失效宕机了，系统仍然能够正常运行，保证可用性和数据持久性</u>。（数据不丢失以及系统不会停止服务）</li><li><mark style="background: #FFFF00;">提高伸缩能力</mark>：通过增加机器，来横向的提升读写性能，进一步提高吞吐量。</li><li><mark style="background: #FFFF00;">数据局部性访问</mark>：其实<u>类似 CDN</u>，也就是<u>客户端在读取数据的时候可以优先读取最近的数据副本来降低延时</u>。</li></ol><p>这个是通用的说法，但是 kafka 实际上只实现了第一点，也就是数据冗余。至于增加机器来提高读性能，实际上 kafka 不能实现，后续会重点介绍为什么这样设计。至于<em>局部性访问</em>，那就更难实现了，你<strong>怎么权衡数据存储到位置和多个客户端之间的距离，会不会涉及到大量的数据转移？数据不一致的情况</strong>？</p><p>我们还是先来看 kafka 是怎么使用这个副本机制的。</p><h2 id="Kafka-的副本机制"><a href="#Kafka-的副本机制" class="headerlink" title="Kafka 的副本机制"></a>Kafka 的副本机制</h2><p>副本，这里指的是 partition 下的副本，也就是我们常说的 replica，<mark style="background: #FFFF00;">实际上就是一个只能追加写消息的提交日志</mark>。同一个分区下的所有副本都是保存的相同的消息序列，这些副本可以分布在一个集群中的多个 broker 上，因此可以保证一些 broker 宕机，消息不会丢失，实现持久性和高可用。</p><p>因此，实际上 kafka 的每个 broker 上可能都存放了成百上千个副本。这些副本来自<strong>不同主题 Topic 下的不同分区 partition 的不同副本</strong>。</p><blockquote><ul><li><strong>副本数量 ≤ 节点数量</strong>：副本数量不能超过集群中的节点数量。如果集群中有 3 个节点，那么副本数量最多也只能是 3。否则，Kafka 无法在不同的节点上分布这些副本。</li></ul></blockquote><p>比如一个三个 broker 节点的集群，可以看到分区以及副本是分布在各个 broker 上的：<br><img src="/images/san.png"></p><h2 id="副本的角色如何划分"><a href="#副本的角色如何划分" class="headerlink" title="副本的角色如何划分"></a>副本的角色如何划分</h2><p>副本并不都是一样的角色，kafka 的副本分为 leader 副本和 follower 副本。其中他们的职责如下：</p><ul><li>Leader 副本<mark style="background: #FFFF00;">只负责处理读写请求</mark>。</li><li>follower 副本只负责从 leader 副本<mark style="background: #FFFF00;">异步地拉取消息同步到它自己的消息日志</mark>来保证和 leader 副本的数据一致。</li></ul><p>客户端（生产者，消费者）与副本的交互关系可参考：</p><p><img src="/images/producer.png"></p><p>当 leader 副本挂掉了，kafka 集群如果使用 zookpeeper 作为分布式协调组件，那就会用它从 follower 副本中选举出新的 leader 副本，继续进行读写请求的处理。当旧的 leader 副本恢复了，会再次被加入到副本集合。</p><blockquote><p>如果在 KRaft 模式下，<u>Kafka 使用 Raft 共识算法来管理集群的元数据和选举新 Leader 副本</u>。需要补充：<a href="kafka%20kraft%20%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%8D%8F%E8%B0%83%E7%AE%97%E6%B3%95.md">kafka kraft 模式下的协调算法</a> </p></blockquote><h2 id="为什么-follower-副本不负责读写处理"><a href="#为什么-follower-副本不负责读写处理" class="headerlink" title="为什么 follower 副本不负责读写处理"></a>为什么 follower 副本不负责读写处理</h2><p>为什么不像其他的主从架构系统那样，比如 mysql，redis 的主从架构，都是主节点负责写，从节点负责读，来提高读的吞吐量。</p><p>这种设计有两种好处：</p><ol><li><mark style="background: #FFFF00;">可以实现“read your writes”</mark></li></ol><p>直译过来就是说你可以读取到你自己写的数据。类比到 kafka 中就是生产者写入消息后，可以立即用消费者读取到这条新写入的消息。</p><p>由于 follower 副本需要<strong>异步拉取 leader 副本的消息进行同步</strong>，因此消费者可能从 follower 中拉取不到最新写入的消息，导致消息的滞后处理。</p><ol start="2"><li><mark style="background: #FFFF00;">可以实现单调读</mark></li></ol><p>当消费者多次重复消费同一条消息时，可能会出现这种情况：发现读取这条消息，有时候能拉到，有什么拉不到。主要就是因为多个 follower 副本作为读系统时<u>没有全部同步到这条消息</u>。</p><h2 id="ISR-机制保证消息同步"><a href="#ISR-机制保证消息同步" class="headerlink" title="ISR 机制保证消息同步"></a>ISR 机制保证消息同步</h2><p>In-sync Replicas 同步副本集合。</p><p>概念：<mark style="background: #FFFF00;">ISR 集合实际上就是一个存放与 leader 副本保持同步的副本集合</mark>。当然也包括 leader 副本本身。</p><p>作用：作用是什么？其实主要是用来<mark style="background: #FFFF00;">在 leader 副本挂掉的情况下，从 ISR 副本集合中选举出一个新的 leader 副本</mark>。</p><blockquote><p>因为你总不能用一个没有同步的副本集合作为 leader 副本吧，这不是<strong>导致消息丢失了</strong>嘛？</p></blockquote><p>关于“同步”，如何确定一个副本是否与 leader 副本同步，follower 副本异步拉取 leader 副本消息进行同步。由于是异步，那肯定不能保证实时的同步（即消息的偏移量都到达了同一个位置）。</p><p>比如下面这个图，是不是两个 follower 都是不同步的副本？<br><img src="/images/kafka-1.png"></p><p>不一定，因为 kafka 定义的同步实际上是<mark style="background: #FFFF00;">由一段时间内 follower 副本是否能够与 leader 副本同步来决定的</mark>。就是说，会给你一定的缓冲时间，毕竟你是异步。ß</p><p>至于这个时间怎么确定，其实是由 Broker 端参数：<code>replica.lag.time.max.ms</code> 决定的，比如设置为 10 秒，那就说明 10 秒内，只要你的 follower 副本能够与 leader 副本同步成功，那就算是同步了。</p><blockquote><p>比如 leader 副本写入消息的速度太快了，follower 副本跟不上速度，就会出现这种规定时间内无法同步，进而被踢出 ISR 集合，所以 <strong>ISR 集合是动态的</strong>。我们怎么减少这种被踢出 ISR 集合的情况？</p><ul><li>增加等待时间的值，给 broker 更多的同步时间，或者增加可以接受的滞后的消息数量参数值：<code>replica.lag.max.messages</code>。</li><li>降低生产者的发送速率，防止 follower 跟不上。</li><li>压缩消息大小，提高同步速度。</li></ul></blockquote><h2 id="如果-ISR-集合空了怎么办"><a href="#如果-ISR-集合空了怎么办" class="headerlink" title="如果 ISR 集合空了怎么办"></a>如果 ISR 集合空了怎么办</h2><p>一个小思考：</p><p>ISR 集合中的副本是可以参与 leader 副本选举的，而 ISR 集合之外的存活副本一般被认为是不能与 leader 副本保持同步的，所以正常情况下不参与 leader 副本的选举。而在特殊情况下，ISR 集合中可能一个副本都不存在（即唯一的同步副本 leader 副本也挂掉了），那只能退而求其次使用 unclear 的副本作为选举的 base 副本。</p><p>空了，说明 leader 副本挂掉了，且没有其他 follower 副本与 leader 副本同步。也就是没法进行 leader 选举了，也就无法正常处理客户端的读写请求。</p><p>这种情况下需要看你怎么考虑：</p><ol><li>开启 Broker 端参数 <code>unclean.leader.election.enable</code> 控制是否允许 Unclean 领导者选举。</li></ol><p>Unclear 也就是没有与 leader 副本保持同步的副本，如果开启这个参数，也就可以从 unclear 副本中选举出一个 leader 副本，继续提供客户端的读写请求，<mark style="background: #FFFF00;">保证了可用性，但是会丢失一定的消息，丧失持久性</mark>。</p><ol start="2"><li>不使用 unclear</li></ol><p>由于没有可用于选举 leader 的副本，因此 broker 无法进行 leader 选举，因此无法继续提供服务。<mark style="background: #FFFF00;">丧失可用性，但是消息不会丢失</mark>。</p><p>扩展：这里实际上也是分布式系统 CAP 理论中的 CP 和 AP 系统的决策，也就是要<strong>保证强一致性系统还是高可用性系统</strong>。CAP 理论参考：<a href="../../%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F--%E6%B0%B8%E4%B9%85%E7%AC%94%E8%AE%B0-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BB%A5%E5%8F%8ACAP%20%E5%92%8C%20BASE%20%E7%90%86%E8%AE%BA.md">分布式–永久笔记-分布式事务以及CAP 和 BASE 理论</a> </p><hr><h2 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h2><p>类似关于 MySQ 架构，以及副本机制设计的疑问点都可以在这里解答。</p><p>TODO.</p><h3 id="补充-：kafka-是怎么通过-ISR-和多副本保证持久性和消息不丢失的？"><a href="#补充-：kafka-是怎么通过-ISR-和多副本保证持久性和消息不丢失的？" class="headerlink" title="补充 ：kafka 是怎么通过 ISR 和多副本保证持久性和消息不丢失的？"></a>补充 ：kafka 是怎么通过 ISR 和多副本保证持久性和消息不丢失的？</h3><p>客户端怎么保证消息不丢失，相关引用：<a href="kafka%20%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1.md">kafka 怎么保证消息不丢失</a> </p><ol><li><mark style="background: #FFFF00;">ACK 机制</mark>，也就是生产者消息确认的级别。<ul><li>如果设置为 0,  那生产者不会等待响应，只要发送了就任务消息发送成功。</li><li>如果设置为 1，只要 leader 副本写入消息成功就算发送成功。</li><li>如果设置为 all，必须使 ISR 集合中的所有副本都写入消息成功之后才算发送成功。持久性保证更强。</li></ul></li><li><mark style="background: #FFFF00;">多副本机制</mark>：即多副本分布在不同的 broker 上实现数据冗余，保证消息不丢失持久化和高可用。</li><li><mark style="background: #FFFF00;">禁用 unclear leader 选举</mark>，因为这种情况下会选择没有完全与 leader 副本同步的副本进行选举，可能会丢失一部分消息。</li></ol><p>而且你也可以自定义设置当 ack 机制为 all 时，需要满足的最小 ISR 集合元素数量，比如设置为 2，那在只有一个 leader 副本的情况下，也不能算作发送成功。必须等 ISR 集合中出现 follower 副本才算发送成功。这样的话，leader 副本突然挂掉也不会导致消息丢失。但是可能会丧失一定可用性，还是之前写的，leader 副本写入太快之类的问题导致 follower 副本无法同步。</p>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秋招总结与系统性学习 kafka 的碎碎念</title>
      <link href="/2024/09/29/qiu-zhao-zong-jie-yu-xi-tong-xing-xue-xi-kafka-de-sui-sui-nian/"/>
      <url>/2024/09/29/qiu-zhao-zong-jie-yu-xi-tong-xing-xue-xi-kafka-de-sui-sui-nian/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/kafka.png"></p><p>今天有点想记录，也好久没更新了，也当做<strong>秋招前中期</strong>的一个总结吧。</p><p>面试情况：</p><p>好的面试都集中在这周了，也就是下面这四个流程，共七场面试。</p><ul><li>0926 滴滴一天三面：base 北京，从 10:30 到 15 点，中间 hr 推迟了三面一小时，没吃上饭。<strong>一句八股都没</strong>，真汗流浃背。</li><li>盒马：base 武汉，二面通过了，二面完发了个笔试做了（三题手撕，另一个面试官看着）。等约第三面技术面。</li><li>途虎：base 上海，二面感觉还行，希望能约 hr 面，看评价还挺不错，薪资也达到预期。</li><li>腾讯云智：一面半小时迅速结束，就问了实习项目+几个八股，然后就问有哪些其他的流程了。不知道是不想要还是过了，目前还没挂。</li></ul><p>其他的流程就是小厂了，拿来练手的，都挺一般（小厂甚至也都不问八股了）。还有很多的是笔试完但是一直不约面的中大厂。很烦，比如小米 0908 开始评估，现在 29 了还不约面（笔试 1.5&#x2F;2），看牛客也基本无约面和 OC。不懂。</p><p>大概就是这样的，挺惨淡，没个保底，希望上面剩余的三个流程能继续，国庆后再来一些中大厂面试吧，这段时间先恶补场景题，设计题，kafka 底层。八股已经没多少用了，<strong>哪怕不是单纯背八股，有自己的理解也没机会说出来</strong>。</p><p>最近几场面试，反应出对系统的设计能力，理解能力都有很多不足，前几天的滴滴三面，三场面试一句八股都没有问，全是项目+实习+场景题，可能是运气好才到三面吧，虽然已经挂掉了。途虎二面面试官就问了 kafka 的一些东西，涉及到的挺全面的，回答的还行，但是我希望能更系统的讲出来，从整体到细节，这种能力我很喜欢，但是暂时还不能完全掌握。因此嘞，休息了一天，今天打算系统学习一下 kafka 先，然后去触类旁通的学习其他 MQ。</p><hr><p>然后现在是另一个主题，怎么学 kafka ？</p><p>现在看不下去 kafka 底层，原因可能在方向不对，直接开始容易处处碰壁，因为有些概念和组件就是这么设计的，直接把一个完整的架构给你了，可能不知道为什么这么设计，虽然也能理解是为了解决某些方法，但是看起来很费劲。</p><p>我觉得应该改变一下，从需求来说。比如我想知道是怎么完成收发消息的，毕竟平常的场景就是这个。然后是其他特性的保证：消息消费失败，丢失，重复怎么避免。通过持久化，重试机制，逻辑上的幂等判断？Kafka 为什么能保证吞吐量很大，这样设计会不会造成什么问题（对可靠性，持久性的不利影响）？关系到生产环境那就设计到很多问题了，kafka 会不会有什么短板，RocketMQ 又是怎么去做改动的，为什么更加业务性？那类似的，实习公司做的 AutoMQ 又有什么优势？又舍去了什么，难道只有优势嘛？</p><p>当然前提是知道有哪些东西，清楚概念，大概的作用，背的话没啥用，还是理解为主，之后碰到功能实现，忘掉了再回顾。还是水平有限，知识面不足导致，思考不全面，还得锻炼啊。</p><p>看样子还是得硬啃，学习的过程就是这样吧，希望后面能拨开迷雾，随缘更新。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务之 CAP 和 BASE 理论基础</title>
      <link href="/2024/09/16/fen-bu-shi-shi-wu-zhi-cap-he-base-li-lun-ji-chu/"/>
      <url>/2024/09/16/fen-bu-shi-shi-wu-zhi-cap-he-base-li-lun-ji-chu/</url>
      
        <content type="html"><![CDATA[<p>#CAP理论</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>如果存在跨数据库的数据一致性保证时，就需要用到分布式事务，比如分库。</p><p>比较常见的场景是，商城业务，如果项目体量比较大，那肯定需要进行分库分表，因为<u>单库和单表的性能有瓶颈，而且数据安全无法保证</u>。</p><p>由于数据库事务只能限制在当前数据库内，所以无法实现跨数据库事务保证。</p><p><mark style="background: #FFFF00;">分布式事务的目标是：多个相关的数据库之间能保证数据一致性</mark>。</p><blockquote><p>举个例子：银行业务，有俩人进行转账，A 扣钱，B 收到钱，这个存钱的账户信息放到一个数据库 <code>D1</code>，然后相应的交易记录放到数据库 <code>D2</code>。如果这个过程中，一部分完成了（扣钱和收钱完成），但是订单存储失败，那在年终对账的时候就要吃牢饭了。</p></blockquote><p>那么，我们继续来探讨一下如何实现分布式事务。</p><h2 id="分布式事务理论基础"><a href="#分布式事务理论基础" class="headerlink" title="分布式事务理论基础"></a>分布式事务理论基础</h2><p>先谈理论，是为了让我们知道我们最终实现的系统能变成什么样的。是不是类似 MySQL 的 ACID 特性的事务？先给出结论，接下来将根据这个主题探讨：</p><p><mark style="background: #FFFF00;">ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</mark></p><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>CAP 代表的是：</p><ul><li><code>一致性（Consistence）</code> : 所有节点访问同一份最新的数据副本  </li><li><code>可用性（Availability）</code>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。  </li><li><code>分区容错性（Partition tolerance）</code> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li></ul><p>其中网络分区，指的是<u>因为某些故障，导致一部分节点脱离了整个系统所在的网络，节点之间网络无法通信，形成了分区</u>。</p><hr><ol><li><mark style="background: #FFFF00;">我们实现的系统是否能完美的实现这三个特点呢</mark>？ans：No！</li></ol><p>首要的一点是，<strong>这个分区容错 P，必须要有</strong>。因为在实际情况中，<u>网络延迟，节点故障，或者节点通信故障</u>等问题是经常发生的，如果不保证在这种情况下的容错，那系统的数据大概率是乱掉的。</p><ol start="2"><li><mark style="background: #FFFF00;">既然 P 一定要有，CA 能共存吗</mark>？ans：也不能</li></ol><p><strong>为啥无同时保证 CA 呢？</strong><br>举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C，必须要禁止其他节点的读写操作，这就和 A 发生冲突了（可用性）。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了（多节点同时操作数据导致不一致）。</p><ol start="3"><li><mark style="background: #FFFF00;">保证 P 的特点，那就衍生出了两种系统，CP 和 AP</mark></li></ol><p>CP 就是强一致性的系统，比较适合银行这种，哪怕你请求失败也不能把数据的一致性抛弃了，必须强一致，避免数据异常。</p><p>AP 就是高可用优先，也就是说，两个节点的数据可能是不一致的，适合对数据的要求不这么敏感的场景，可以接受”暂时的误差”。</p><blockquote><ul><li>比如社区服务：你这次没获取到最新的帖子有问题吗，没问题，我可以给你返还旧数据，等一段时间你刷新了最新帖子就有了，完全没问题。</li><li>比如社交媒体平台：用户发布一条状态，系统立即返回成功响应，其他用户可能暂时看不到这条状态，但经过一段时间的后台同步，所有用户最终都能看到该状态。</li></ul></blockquote><p>假设我们有一个分布式系统，使用了 AP 优先的策略，但通过后台数据同步机制实现最终一致性，那么它的数据流向可以是这样的：<br><img src="/images/AP.png"></p><ol><li><strong>写操作</strong>：<ul><li>客户端 A 向节点 1 写入数据。</li><li>节点 1 立即返回成功响应，<strong>保证可用性</strong>。</li><li>节点 1 将数据变更记录到日志，并异步地将变更同步到其他节点。</li></ul></li><li><strong>读操作</strong>：<ul><li>客户端 B 向节点 2 读取数据。</li><li>如果节点 2 尚未收到同步的最新数据，可能会返回旧数据。</li><li>在后台数据同步完成后，节点 2 的数据将与节点 1 一致，最终达到一致性。</li></ul></li></ol><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>BASE 理论代表的是：</p><ul><li><code>基本可用（Basically Available）</code>：系统在分布式环境中，允许在部分节点故障的情况下，仍然能提供基本的可用性。</li><li><code>软状态（Soft State）</code>：系统允许存在中间状态，即数据在不同节点之间的副本不必时刻保持强一致性。</li><li><code>最终一致性（Eventual Consistency）</code>：系统保证在没有新的更新操作后，所有的数据副本最终会达到一致性。</li></ul><p>其中，基本可用指的是<u>系统在部分功能失效或性能下降的情况下，仍然能对外提供服务</u>。</p><hr><ol><li><mark style="background: #FFFF00;">我们实现的系统是否能完美的实现 BASE 理论的三个特点呢</mark>？ans：No！</li></ol><p>首要的一点是，<strong>基本可用性 BA 和最终一致性 EC 需要在软状态 SS 的支持下才能实现</strong>。因为在实际情况中，<u>网络延迟、节点故障、数据同步延迟</u>等问题是经常发生的，如果不允许存在软状态，那系统的数据一致性和可用性就无法同时实现。</p><ol start="2"><li><mark style="background: #FFFF00;">既然 SS 是必要的，BA 和 EC 能共存吗</mark>？ans：可以</li></ol><p><strong>为啥能同时保证 BA 和 EC 呢？</strong><br>举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证基本可用性（BA），节点可以立即返回成功响应而不等待其他节点的确认，这样用户体验不受影响。而为了保证最终一致性（EC），系统可以在后台异步进行数据同步，确保所有节点最终达到一致状态。</p><ol start="3"><li><mark style="background: #FFFF00;">保证 SS 的特点，那就衍生出了 BASE 系统的应用场景</mark></li></ol><p>BASE 更适合那些对数据一致性要求不高，但对系统可用性和响应速度要求较高的场景。通过牺牲强一致性，系统可以在高并发、分布式环境中提供更好的可用性和性能。</p><p>可以看到和 AP 极其相似，也符合我们的主题思想，<u>BASE 是 AP 的理论延伸</u>。</p><p>关于分布式事务的实现方式还有很多，敬请期待下部分内容！</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫码登录流程</title>
      <link href="/2024/08/19/sao-ma-deng-lu-liu-cheng/"/>
      <url>/2024/08/19/sao-ma-deng-lu-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p>二维码信息里主要包括唯一的二维码 ID，过期的时间，还有扫描状态：未扫描、已扫描、已失效。</p><h2 id="扫码登录流程"><a href="#扫码登录流程" class="headerlink" title="扫码登录流程"></a>扫码登录流程</h2><p>我们从客户端（用户浏览器）到二维码服务端，以及手机到手机端服务器，手机端服务器响应数据到二维码服务器等。（这里的服务器可以当做一个服务）</p><h3 id="客户端到二维码服务"><a href="#客户端到二维码服务" class="headerlink" title="客户端到二维码服务"></a>客户端到二维码服务</h3><p>用户打开网站的登录页面的时候，浏览器会向二维码服务器发送一个获取登录二维码的请求。二维码服务器收到请求之后，会随机的生成一个 uuid，通常是唯一的。将这个 uuid 作为 key 存储到 redis 服务器中，同时会设置一个过期时间，过期之后用户就要重新网页刷新来获取。</p><p>之后会将这个 uuid 和本公司的验证字符串和在一起通过二维码生成接口生成图片，将二维码图片信息和 uuid 返回给浏览器，浏览器拿到 uuid 和图片之后，每隔一定时间就向服务器发送一个判断登陆是否成功的请求，请求中会携带 uuid 作为当前页面的标识符。</p><h3 id="手机到手机端服务器"><a href="#手机到手机端服务器" class="headerlink" title="手机到手机端服务器"></a>手机到手机端服务器</h3><p>用户拿起手机扫描二维码之后，就会得到二维码中包含的验证信息和 uuid，由于手机端已经进行过登陆验证，在访问手机端服务器的时候参数中都会携带一个用户信息 token，这个 token 是在第一次手机登陆过程中产生并且长期有效的。手机端服务器通过这个 token 就可以解析出用户的类似于 userId 等信息。 </p><p>然后手机端服务器会将解析出来的数据作为参数向二维码服务器发送登陆请求，二维码服务器收到请求之后会对参数进行校验，确定是否为用户登录请求接口。如果是就返回给手机一个确认信息。手机端收到信息之后，登陆确认框会显示给用户，用户进行登陆确认之后手机再次发送请求，redis 服务器拿到信息之后，会将刚才 uuid 的 key 的 value 设置为 userId。 </p><p>这样浏览器再次发送请求的时候就可以在 redis 服务器中拿到用户的 id，并调用登陆方法生成一个浏览器端 token。浏览器再发送请求，就会将用户信息的 token 返回给浏览器。</p><blockquote><ul><li>这里存储用户 id 而不是直接存储用户信息是因为手机端的用户信息，不一定是和浏览器端的用户信息完全一致。</li><li>传 token 是为了安全，token 是被加密的，直接传 userId 可能有被窃取的风险。</li></ul></blockquote><h3 id="浏览器通过该-Token-的后续登录流程"><a href="#浏览器通过该-Token-的后续登录流程" class="headerlink" title="浏览器通过该 Token 的后续登录流程"></a>浏览器通过该 Token 的后续登录流程</h3><ol><li>认证成功后，会对当前用户数据进行加密，生成一个加密字符串 token，返还给客户端（服务器端并不进行保存）。</li><li>浏览器会将接收到的 token 值存储在 Local Storage 中（通过 js 代码写入 Local Storage，通过 js 获取，并不会像 cookie 一样自动携带）。</li><li>再次访问时服务器端对 token 值的处理：<ul><li>服务器对浏览器传来的 token 值进行解密，解密完成后进行用户数据的查询。</li><li>如果查询成功，则通过认证，实现状态保持。</li><li>即使有了多台服务器，服务器也只是做了 token 的解密和用户数据的查询，不需要在服务端去保留用户的认证信息或者会话信息。</li><li>这就意味着基于 token 认证机制的应用不需要去考虑用户在哪一台服务器登录了，为应用的扩展提供了便利，解决了 session 扩展性的弊端（session 需要保存 sessionid 到服务端，在分布式场景下，多个服务器之间的 session 共享很麻烦，如果需要同步还需要进行通信以及延迟问题）。</li></ul></li></ol><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>画个时序图，应该更好理解一些。</p><p><img src="/images/%E6%B5%81%E7%A8%8B.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升 IO 密集型服务性能的异步处理模型</title>
      <link href="/2024/08/18/ti-sheng-io-mi-ji-xing-fu-wu-xing-neng-de-yi-bu-chu-li-mo-xing/"/>
      <url>/2024/08/18/ti-sheng-io-mi-ji-xing-fu-wu-xing-neng-de-yi-bu-chu-li-mo-xing/</url>
      
        <content type="html"><![CDATA[<p>电子商务平台的订单处理服务是典型的 I&#x2F;O 密集型（I&#x2F;O Bound）服务。</p><p><strong>IO 密集型任务</strong>：一般就是说需要大量请求数据库和网络请求这些，如果请求比较多，系统大部分时间都花在等待 IO 操作完成。也就导致系统的性能瓶颈是在 IO 的延迟上。因此需要采用<u>并发加载</u>的方式，减少系统串行等待 IO 操作导致的系统性能下降。</p><h2 id="并发加载的方式"><a href="#并发加载的方式" class="headerlink" title="并发加载的方式"></a>并发加载的方式</h2><p>主要讲三种方式，同步模型，线程池异步，NIO 异步模型，CompletableFuture 的异步模型。</p><h3 id="同步模型"><a href="#同步模型" class="headerlink" title="同步模型"></a>同步模型</h3><p>很经典，也就是一个服务调用完返回结果，再去调另一个服务，之后逐个返回结果拼成 VO（响应的数据结果）。</p><p><img src="/images/%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%9E%8B.png"></p><p>这种其实不用多说，肯定是最不可取的，我们至少需要引入异步操作。</p><h3 id="线程池异步"><a href="#线程池异步" class="headerlink" title="线程池异步"></a>线程池异步</h3><p><mark style="background: #FFFF00;">线程池的异步实际上是线程的并发操作，不会阻塞主线程</mark>。</p><p>我们可以通过引入线程池，也就是利用线程池能够管理线程的特点：</p><ul><li>线程可复用，避免线程重复创建</li><li>异步操作，直接分配线程去处理请求，不会阻塞主线程</li><li>任务执行完成后线程被释放，并且能够被分配给其他任务</li></ul><p>这样，我们可以在一个请求来到时，把向各个服务的请求交给线程池处理，我们再拿到响应的数据进行封装。这样能避免串行场景下的等待时间。但是，这样还有问题：</p><h4 id="CPU-仍然资源利用率低"><a href="#CPU-仍然资源利用率低" class="headerlink" title="CPU 仍然资源利用率低"></a>CPU 仍然资源利用率低</h4><p>虽然等待时间减少了，但是这些子线程仍然需要等待 IO 操作，CPU 仍然处于等待 IO 操作的空闲状态。这样也会导致 CPU 资源利用率低。</p><p>所以，一般<u>通过回调去防止阻塞</u>，也就是在执行 IO 操作时做异步处理，当 IO 操作完成之后，通知线程 IO 操作完成，需要继续执行数据的处理和响应。进而减少 CPU 阻塞时间。然而这种场景只适合少量请求的回调，如果回调函数过多，会造成”回调地狱”问题，使得代码可读性和可维护性降低。</p><h4 id="为增加并发度，需要增大线程池容量或数量"><a href="#为增加并发度，需要增大线程池容量或数量" class="headerlink" title="为增加并发度，需要增大线程池容量或数量"></a>为增加并发度，需要增大线程池容量或数量</h4><p>CPU 可以调度的线程数量更多了，但是竞争更激烈了，可能会发生频繁的上下文切换，导致资源白白消耗。并且线程池的参数也不好设置，大量空闲线程也会占用系统资源。</p><p>所以线程池异步实际上也不是完全合适的。</p><blockquote><p>补充：线程池是可以通过 Future 类去接受子线程执行的结果的，可以通过它的 get 方法等待任务执行完成之后获取结果，如果任务还没有结束，则会阻塞在获取操作那里，等待任务完成。</p></blockquote><h3 id="NIO-异步"><a href="#NIO-异步" class="headerlink" title="NIO 异步"></a>NIO 异步</h3><p>和线程池的异步不同，NIO 异步基于事件驱动模型和 selector 机制完成异步加载。</p><ul><li><strong>Selector</strong>：负责监控所有注册的 Channel（Channel 通道实际上就是 I&#x2F;O 连接，比如文件传输通道，Socket 套接字）。</li><li><strong>Channel 的非阻塞模式</strong>：当需要进行 I&#x2F;O 操作时，Channel 不会进行等待，而是立即返回继续处理其他请求。Selector 会监控这些 Channel，当 I&#x2F;O 操作可以进行时（例如数据准备好读取或可以写入），Selector 会通知应用程序处理这些 I&#x2F;O 操作。</li><li><strong>事件驱动模型</strong>：当有 I&#x2F;O 事件（如 read、write、accept 等操作）发生时，Selector 会检测到并返回一个包含所有准备好进行 I&#x2F;O 操作的 Channel 的 SelectionKey 集合。应用程序迭代这个集合，并处理每个 Channel 上的 I&#x2F;O 事件。通过这种方式，I&#x2F;O 操作是由事件驱动的，而不是由线程阻塞等待。</li></ul><p><img src="/images/NIO.png"></p><p><mark style="background: #FFFF00;">那它是怎么和处理请求的线程联系起来的呢</mark>？</p><p>这点，我的理解是：<u>NIO 的选择器能够监听所有的 IO 操作，然后通过 Channel 的方式将这些请求提交给线程池处理，也就不会阻塞主线程了</u>。</p><p>所以和线程池的根本区别是：线程池实际上没有把 IO 操作完全的抛离出去，而是用子线程去处理请求，如果需要使用回调函数则可能会引发回调地狱。而 NIO 呢，是把所有会阻塞线程的 IO 操作异步的通过 selector 去将 IO 操作传递给线程池的线程去做。</p><h4 id="NIO-的不足"><a href="#NIO-的不足" class="headerlink" title="NIO 的不足"></a>NIO 的不足</h4><p><mark style="background: #FFFF00;">NIO 主要适用于高并发的网络通信和 I&#x2F;O 操作，不适用于所有异步任务</mark>。也就是那种需要大量用到 CPU 的请求，NIO 的性能还是有限的。而且 NIO 模型的代码复杂度很高，涉及到缓存，字节，缓冲区等概念模型，编码难度大，不好维护。</p><p>而 CompletableFuture ，更适合 CPU 密集型以及需要大量处理业务逻辑的异步处理任务，同时也能够兼容这种 IO 密集型的任务（因为回调地狱）。能够结合线程池实现任务的异步执行，并且它是基于 Future 的进化版，能够获取异步任务执行结果，总之很全面，下面我们开始继续介绍。</p><blockquote><p>当然，NIO 和 CompletableFuture 也是可以联用的。</p></blockquote><h3 id="CompletableFuture-异步模型"><a href="#CompletableFuture-异步模型" class="headerlink" title="CompletableFuture 异步模型"></a>CompletableFuture 异步模型</h3><p>CompletableFuture 是基于 Future 的进化版，能够解决传统情况下 ListenableFuture 引发的回调地狱问题。因为传统场景下，Future 实现异步和回调是这样的：</p><ul><li>每个异步操作都需要嵌套多个回调函数（比如成功的结果回调，失败的结果回调，或者特殊情况下的回调结果），这种嵌套很容易导致所谓的“回调地狱”，使得代码难以阅读和维护。</li></ul><h4 id="ListenableFuture-的实现方式"><a href="#ListenableFuture-的实现方式" class="headerlink" title="ListenableFuture 的实现方式"></a>ListenableFuture 的实现方式</h4><p>比如下面这段代码是 ListenableFuture 的异步实现：</p><ul><li>定义了一个线程池，两个异步任务</li><li>两个异步任务 AB 执行结束后，通过 AllAsList 方法组合两个异步任务执行的结果，之后再给这个聚合的结果加上一个回调函数。</li><li>这两个异步任务结束后，会调用回调函数，其中首先打印之前的两个异步任务的结果，然后再新增一个异步任务 C 提交给线程池，再给 C 加上回调函数，依次类推，最后打印出所有异步任务的结果</li><li>如果异步任务没有执行完成，则获取异步结果的方法会被阻塞（而 CompletableFuture 虽然通过 get 方法也会阻塞，但是可以选择通过 thenAccept 异步的获取执行结果，所以不会被阻塞）。<pre class="line-numbers language-java" data-language="java"><code class="language-java">ExecutorService executor &#x3D; Executors.newFixedThreadPool(5);ListeningExecutorService guavaExecutor &#x3D; MoreExecutors.listeningDecorator(executor);ListenableFuture&lt;String&gt; future1 &#x3D; guavaExecutor.submit(() -&gt; &#123;    &#x2F;&#x2F; step 1    System.out.println(&quot;执行step 1&quot;);    return &quot;step1 result&quot;;&#125;);ListenableFuture&lt;String&gt; future2 &#x3D; guavaExecutor.submit(() -&gt; &#123;    &#x2F;&#x2F; step 2    System.out.println(&quot;执行step 2&quot;);    return &quot;step2 result&quot;;&#125;);ListenableFuture&lt;List&lt;String&gt;&gt; future1And2 &#x3D; Futures.allAsList(future1, future2);Futures.addCallback(future1And2, new FutureCallback&lt;List&lt;String&gt;&gt;() &#123;    @Override    public void onSuccess(List&lt;String&gt; result) &#123;        System.out.println(result);        ListenableFuture&lt;String&gt; future3 &#x3D; guavaExecutor.submit(() -&gt; &#123;            System.out.println(&quot;执行step 3&quot;);            return &quot;step3 result&quot;;        &#125;);        Futures.addCallback(future3, new FutureCallback&lt;String&gt;() &#123;            @Override            public void onSuccess(String result) &#123;                System.out.println(result);            &#125;                    @Override            public void onFailure(Throwable t) &#123;            &#125;        &#125;, guavaExecutor);    &#125;    @Override    public void onFailure(Throwable t) &#123;    &#125;&#125;, guavaExecutor);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>流程图如下：<br><img src="/images/listenableFuture.png"></p><h4 id="CompletableFuture-的实现方式"><a href="#CompletableFuture-的实现方式" class="headerlink" title="CompletableFuture 的实现方式"></a>CompletableFuture 的实现方式</h4><p>CompletableFuture 提供了很多组合操作，比如 <code>thenCombine</code>、<code>thenAccept</code>、<code>thenApply</code>，下面这个就是用到了 thenCombine ，能够将异步任务直接传递到参数，等待两个异步任务执行完成后，可以直接进行调用，其内部就是回调函数的内容。还可以继续拼接其他方法，比如 thenAccept ，可以处理上一个异步操作（thenCombine ）得到的结果。</p><p>可以看到，这里是可以采用<strong>链式调用</strong>的方式完成组合，以及进一步处理。而不是像 ListenableFuture 去嵌套的完成。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ExecutorService executor &#x3D; Executors.newFixedThreadPool(5);CompletableFuture&lt;String&gt; cf1 &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;    System.out.println(&quot;执行step 1&quot;);    return &quot;step1 result&quot;;&#125;, executor);CompletableFuture&lt;String&gt; cf2 &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;    System.out.println(&quot;执行step 2&quot;);    return &quot;step2 result&quot;;&#125;, executor);cf1.thenCombine(cf2, (result1, result2) -&gt; &#123;    System.out.println(result1 + &quot; , &quot; + result2);    System.out.println(&quot;执行step 3&quot;);    return &quot;step3 result&quot;;&#125;).thenAccept(result3 -&gt; System.out.println(result3));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>流程图如下：<br><img src="/images/ss.png"></p><blockquote><p>ThenApply，是对上一个操作返回的结果进行封装，再次生成一个异步任务。</p></blockquote><p>因此呢，我们选择用 CompletableFuture 来处理这种异步任务，能够简化异步调用流程以及回调函数的处理。不会遇到回调地狱的问题，代码看起来也更简洁。</p><h3 id="补充-：线程池与-CompletableFuture-结合使用的注意事项"><a href="#补充-：线程池与-CompletableFuture-结合使用的注意事项" class="headerlink" title="补充 ：线程池与 CompletableFuture 结合使用的注意事项"></a>补充 ：线程池与 CompletableFuture 结合使用的注意事项</h3><ol><li>如果在调用方法时，不指定线程池对象，会默认使用公共线程池 ForkJoinPool，导致频繁竞争，并且有性能瓶颈。因此建议都要指定线程池对象。</li><li>线程池对象最好进行业务之间的隔离，否则容易导致业务间干扰。</li><li>循环依赖导致死锁：</li></ol><p>比如下面这个场景：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Object doGet() &#123;  ExecutorService threadPool1 &#x3D; new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;&gt;(100));  CompletableFuture cf1 &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;  &#x2F;&#x2F;do sth    return CompletableFuture.supplyAsync(() -&gt; &#123;        System.out.println(&quot;child&quot;);        return &quot;child&quot;;      &#125;, threadPool1).join();&#x2F;&#x2F;子任务    &#125;, threadPool1);  return cf1.join();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>父任务和子任务共用一个线程池，如果请求量过大，父任务将线程池线程用完了，会导致子任务获取不到线程执行，而父任务需要依赖子任务的执行结果，进而导致死锁。</p><p>所以：<strong>需要将父任务与子任务做线程池隔离，两个任务请求不同的线程池，避免循环依赖导致的阻塞</strong>。</p><h2 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h2><p>本文讨论了外卖商家端 API 服务的并发加载方式，主要包括同步模型、线程池异步、NIO 异步模型和 CompletableFuture 异步模型。</p><ol><li><strong>同步模型</strong>：逐个调用服务，性能低下，不推荐。</li><li><strong>线程池异步</strong>：通过线程池处理并发请求，减少主线程阻塞，但可能导致 CPU 利用率低和回调地狱问题。</li><li><strong>NIO 异步</strong>：基于事件驱动模型和 selector 机制，适用于高并发的网络通信，但代码复杂度高。</li><li><strong>CompletableFuture 异步模型</strong>：解决回调地狱问题，适合 CPU 密集型任务，代码简洁易读。</li></ol><p>总结：对于电子商务平台的订单处理服务，推荐使用 CompletableFuture 结合线程池实现异步处理，以提高系统性能和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CompletableFuture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoMQ 开源可观测性方案：夜莺 Flashcat</title>
      <link href="/2024/07/19/automq-kai-yuan-ke-guan-ce-xing-fang-an-ye-ying-flashcat/"/>
      <url>/2024/07/19/automq-kai-yuan-ke-guan-ce-xing-fang-an-ye-ying-flashcat/</url>
      
        <content type="html"><![CDATA[<h2 id="碎言"><a href="#碎言" class="headerlink" title="碎言"></a>碎言</h2><p>今天集成了夜莺观测平台，对于 Prometheus 更加熟悉了，同时发现了其实这些可观测的平台实际上都差不多的，都是采集 Metrics 数据，然后在平台上做聚合操作。比如观测云的采集工具 datakit，实际上也是采集观测数据，然后通过 token 获取数据并进行聚合查询，以及告警等。</p><blockquote><p>所以,,, 这些平台大同小异，在之前没了解过可能会觉得好厉害，这么多乱七八糟的数据怎么进行监控呢。现在看来就那样，但是不同的产品可能又侧重点不同，大家也都在积极的解决用户的需求，这点还是非常值得鼓励的。</p></blockquote><p>然后呢，夜莺平台有问题反馈的渠道，有一个是免费的知识星球，这个就很好，里面有几千位球友，如果你用这个产品出了什么问题，靠自己搜索解决不了，实际上可能早就出现在知识星球里了。所以这种方案对于快速解决用户问题以及节省人员精力的消耗是非常不错的。同时夜莺和 Open-Falcon 的创始人<strong>秦晓辉</strong>，我看他们的仓库里这位大佬已经提交了上百万行代码，何况是开源项目里的，可见其经验深厚，同时也是极客时间中一个课程《运维监控系统实战笔记》的作者。</p><p>然后呢，知识星球里的文章也文笔很好并且逻辑严谨，值得学习！</p><p>还是开始介绍怎么集成 AutoMQ 与夜莺监控吧，感觉现在写文档比刚开始熟练多了，也能发现逻辑问题，尽量写清楚无争议一些。可能对之后写技术文章也有帮助。之后再考虑多写技术文章，也可以发到这里来。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在现代企业中，随着数据处理需求的不断增长，<a href="https://www.automq.com/zh">AutoMQ</a> [1] 作为一种高效、低成本的流处理系统，逐渐成为企业实时数据处理的关键组件。然而，随着集群规模的扩大和业务复杂性的增加，确保 AutoMQ 集群的稳定性、高可用性和性能优化变得尤为重要。因此，集成一个强大而全面的监控系统对于维护 AutoMQ 集群的健康运行至关重要。<a href="https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v7/introduction/">夜莺监控系统</a>（Nightingale）[2] 以其高效的数据采集、灵活的告警管理和丰富的可视化能力，成为企业监控AutoMQ 集群的理想选择。通过使用夜莺监控系统，企业可以实时掌握 AutoMQ 集群的运行状态，及时发现和解决潜在问题，优化系统性能，确保业务的连续性和稳定性。</p><h3 id="AutoMQ-概述"><a href="#AutoMQ-概述" class="headerlink" title="AutoMQ 概述"></a><strong>AutoMQ 概述</strong></h3><p>AutoMQ 是一种基于云重新设计的流处理系统，它在保持与 Apache Kafka 100% 兼容的前提下，通过将存储分离至对象存储，显著提升了系统的成本效益和弹性能力。具体来说，AutoMQ 通过构建在 S3 上的流存储库 S3Stream，将存储卸载至云厂商提供的共享云存储 EBS 和 S3，提供低成本、低延时、高可用、高可靠和无限容量的流存储能力。与传统的 Shared Nothing 架构相比，AutoMQ 采用了 Shared Storage 架构，显著降低了存储和运维的复杂性，同时提升了系统的弹性和可靠性。</p><p>AutoMQ 的设计理念和技术优势使其成为替换企业现有 Kafka 集群的理想选择。通过采用 AutoMQ，企业可以显著降低存储成本，简化运维，并实现集群的自动扩缩容和流量自平衡，从而更高效地应对业务需求的变化。此外，AutoMQ 的架构支持高效的冷读操作和服务零中断，确保系统在高负载和突发流量情况下的稳定运行。它的存储结构如下：</p><p><img src="/images/flash.png"></p><h3 id="夜莺概述"><a href="#夜莺概述" class="headerlink" title="夜莺概述"></a>夜莺概述</h3><p>夜莺监控系统（Nightingale）是一款开源的云原生观测分析工具，采用 All-in-One 设计理念，集数据采集、可视化、监控告警和数据分析于一体。其主要优势包括高效的数据采集能力、灵活的告警策略和丰富的可视化功能。夜莺与多种云原生生态紧密集成，支持多种数据源和存储后端，提供低延迟、高可靠性的监控服务。通过使用夜莺，企业可以实现对复杂分布式系统的全面监控和管理，快速定位和解决问题，从而优化系统性能和提高业务连续性。</p><p><img src="/images/yey.png"></p><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>为了实现集群状态的监控，你需要如下环境：</p><ul><li><p>部署一个可用的 AutoMQ 节点&#x2F;集群，并开放 Metrics 采集端口</p></li><li><p>部署夜莺监控及其依赖环境</p></li><li><p>部署 <a href="https://prometheus.io/docs/prometheus/latest/getting_started/">Prometheus</a> [4] 以获取 Metrics 数据</p></li></ul><h2 id="部署-AutoMQ、Prometheus-以及夜莺监控"><a href="#部署-AutoMQ、Prometheus-以及夜莺监控" class="headerlink" title="部署 AutoMQ、Prometheus 以及夜莺监控"></a>部署 AutoMQ、Prometheus 以及夜莺监控</h2><h3 id="部署-AutoMQ"><a href="#部署-AutoMQ" class="headerlink" title="部署 AutoMQ"></a>部署 AutoMQ</h3><p>参考 AutoMQ 文档：<a href="https://docs.automq.com/zh/docs/automq-opensource/IyXrw3lHriVPdQkQLDvcPGQdnNh">集群方式部署 | AutoMQ</a> [5] 。在部署启动前，添加如下配置参数以开启 Prometheu 的拉取接口。通过以下参数启动 AutoMQ 集群以后，每个节点将会额外开放一个 HTTP 接口供我们拉取 AutoMQ 的监控指标。这些指标的格式均遵循 Prometheus Metrics 的格式。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bin&#x2F;kafka-server-start.sh ...\--override  s3.telemetry.metrics.exporter.type&#x3D;prometheus \--override  s3.metrics.exporter.prom.host&#x3D;0.0.0.0 \--override  s3.metrics.exporter.prom.port&#x3D;8890 \....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当启用 AutoMQ 监控指标后，可以在任意一台节点上通过 HTTP 协议拉取到 Prometheus 格式的监控指标，地址为：<code>http://&#123;node_ip&#125;:8890</code>，响应结果示例如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">....kafka_request_time_mean_milliseconds&#123;otel_scope_name&#x3D;&quot;io.opentelemetry.jmx&quot;,type&#x3D;&quot;DescribeDelegationToken&quot;&#125; 0.0 1720520709290kafka_request_time_mean_milliseconds&#123;otel_scope_name&#x3D;&quot;io.opentelemetry.jmx&quot;,type&#x3D;&quot;CreatePartitions&quot;&#125; 0.0 1720520709290...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>关于指标介绍，可以参考 AutoMQ 官网文档：<a href="https://docs.automq.com/zh/docs/automq-opensource/ArHpwR9zsiLbqwkecNzcqOzXn4b">Metrics | AutoMQ</a> [6] 。</p><h3 id="部署-Prometheus"><a href="#部署-Prometheus" class="headerlink" title="部署 Prometheus"></a>部署 Prometheus</h3><p>Prometheus 可以通过下载二进制包部署，也可以通过 Docker 方式部署。以下是这两种部署方式的介绍。</p><h4 id="二进制部署"><a href="#二进制部署" class="headerlink" title="二进制部署"></a>二进制部署</h4><p>为了方便使用，你可以新建一个脚本，并根据需要修改 Prometheus 的下载版本，最后执行脚本即可完成部署。首先，新建脚本：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;homevim install_prometheus.sh# !!! 粘贴下面的脚本内容 并保存退出# 授予权限chmod +x install_prometheus.sh# 执行脚本.&#x2F;install_prometheus.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>脚本内容如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version&#x3D;2.45.3filename&#x3D;prometheus-$&#123;version&#125;.linux-amd64mkdir -p &#x2F;opt&#x2F;prometheuswget https:&#x2F;&#x2F;github.com&#x2F;prometheus&#x2F;prometheus&#x2F;releases&#x2F;download&#x2F;v$&#123;version&#125;&#x2F;$&#123;filename&#125;.tar.gztar xf $&#123;filename&#125;.tar.gzcp -far $&#123;filename&#125;&#x2F;*  &#x2F;opt&#x2F;prometheus&#x2F;# config as a service cat &lt;&lt;EOF &gt;&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;prometheus.service[Unit]Description&#x3D;&quot;prometheus&quot;Documentation&#x3D;https:&#x2F;&#x2F;prometheus.io&#x2F;After&#x3D;network.target[Service]Type&#x3D;simpleExecStart&#x3D;&#x2F;opt&#x2F;prometheus&#x2F;prometheus --config.file&#x3D;&#x2F;opt&#x2F;prometheus&#x2F;prometheus.yml --storage.tsdb.path&#x3D;&#x2F;opt&#x2F;prometheus&#x2F;data --web.enable-lifecycle --web.enable-remote-write-receiverRestart&#x3D;on-failureSuccessExitStatus&#x3D;0LimitNOFILE&#x3D;65536StandardOutput&#x3D;syslogStandardError&#x3D;syslogSyslogIdentifier&#x3D;prometheus[Install]WantedBy&#x3D;multi-user.targetEOFsystemctl enable prometheussystemctl restart prometheussystemctl status prometheus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>随后修改 Prometheus 的配置文件，<strong>增加采集 AutoMQ 可观测数据的任务</strong>，并<strong>重启</strong> Prometheus，执行命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># config 配置文件内容填下面的vim &#x2F;opt&#x2F;prometheus&#x2F;prometheus.yml# 重启 Prometheussystemctl restart prometheus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>配置文件内容参考如下</strong>，请将下列中的<code>client_ip</code>修改为 AutoMQ 开放的可观测数据暴露地址：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># my global configglobal:  scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.scrape_configs:  # The job name is added as a label &#96;job&#x3D;&lt;job_name&gt;&#96; to any timeseries scraped from this config.  - job_name: &quot;prometheus&quot;    static_configs:      - targets: [&quot;localhost:9090&quot;]        - job_name: &quot;automq&quot;    static_configs:      - targets: [&quot;&#123;client_ip&#125;:8890&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>部署完成后，我们可以通过浏览器访问 Prometheus，查看是否真正采集到了 AutoMQ 的 Metrics数据，访问<code>http://&#123;client_ip&#125;:9090/targets</code>：</p><p><img src="/images/Prometheus.png"></p><h4 id="Docker-部署"><a href="#Docker-部署" class="headerlink" title="Docker 部署"></a>Docker 部署</h4><p>如果你已经有一个在运行的 Prometheus Docker 容器，请先执行命令删除该容器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker stop prometheusdocker rm prometheus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>新建配置文件，并在 Docker 启动时进行挂载：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir -p &#x2F;opt&#x2F;prometheusvim &#x2F;opt&#x2F;prometheus&#x2F;prometheus.yml# 配置内容参考上述 “二进制部署” 中的配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>启动 Docker 容器：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d \  --name&#x3D;prometheus \  -p 9090:9090 \  -v &#x2F;opt&#x2F;prometheus&#x2F;prometheus.yml:&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml \  -m 500m \  prom&#x2F;prometheus \  --config.file&#x3D;&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml \  --enable-feature&#x3D;otlp-write-receiver \  --web.enable-remote-write-receiver<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样你便得到了一个采集 AutoMQ Metrics 的 Prometheus 服务，关于更多 AutoMQ Metrics 与 Prometheus 集成的介绍，可以参考：<a href="https://docs.automq.com/zh/automq/observability/integrating-metrics-with-prometheus">将 Metrics 集成到 Prometheus | AutoMQ</a> [7]。</p><h3 id="部署夜莺监控"><a href="#部署夜莺监控" class="headerlink" title="部署夜莺监控"></a>部署夜莺监控</h3><p>夜莺监控可以通过下面三种方式进行部署，关于更详细的部署说明可以参考<a href="https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v7/install/intro/">官方文档</a> [8]：</p><ul><li><p>Docker compose 方式部署</p></li><li><p>二进制方式部署</p></li><li><p>Helm 方式部署</p></li></ul><p>接下来我将采用二进制的方式进行部署。</p><h4 id="下载夜莺"><a href="#下载夜莺" class="headerlink" title="下载夜莺"></a>下载夜莺</h4><p>请在夜莺 <a href="https://github.com/ccfos/nightingale">Github releases</a> [9] 页中选择合适的版本进行下载，这里我们采用的版本是<code>v7.0.0-beta.14</code>。如果你是 amd 架构的机器，可直接执行如下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;home# 下载wget https:&#x2F;&#x2F;github.com&#x2F;ccfos&#x2F;nightingale&#x2F;releases&#x2F;download&#x2F;v7.0.0-beta.14&#x2F;n9e-v7.0.0-beta.14-linux-amd64.tar.gzmkdir -p &#x2F;home&#x2F;flashcat# 解压文件到 &#x2F;home&#x2F;flashcat 文件夹tar -xzf &#x2F;home&#x2F;n9e-v7.0.0-beta.14-linux-amd64.tar.gz -C &#x2F;home&#x2F;flashcat# 进入主目录cd &#x2F;home&#x2F;flashcat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置依赖环境"><a href="#配置依赖环境" class="headerlink" title="配置依赖环境"></a>配置依赖环境</h4><p>夜莺依赖 MySQL 和 Redis，因此需要提前安装这两个环境。你可以通过 Docker 方式部署，也可以通过执行命令进行安装，参考命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># install mysqlyum -y install mariadb*systemctl enable mariadbsystemctl restart mariadbmysql -e &quot;SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; &#x3D; PASSWORD(&#39;1234&#39;);&quot;# install redisyum install -y redissystemctl enable redissystemctl restart redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里 Redis 设置的是无密码的。并且这里指定 MySQL 数据库的密码为<code>1234</code>，<strong>如果你需要更改为其他的密码</strong>，要在夜莺的配置文件中进行配置，以保证夜莺能连接到你的数据库。修改夜莺配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;home&#x2F;flashcat&#x2F;etc&#x2F;config.toml修改 [DB] 下的用户名和密码：[DB]# postgres: host&#x3D;%s port&#x3D;%s user&#x3D;%s dbname&#x3D;%s password&#x3D;%s sslmode&#x3D;%s# postgres: DSN&#x3D;&quot;host&#x3D;127.0.0.1 port&#x3D;5432 user&#x3D;root dbname&#x3D;n9e_v6 password&#x3D;1234 sslmode&#x3D;disable&quot;# sqlite: DSN&#x3D;&quot;&#x2F;path&#x2F;to&#x2F;filename.db&quot;DSN &#x3D; &quot;&#123;username&#125;:&#123;password&#125;@tcp(127.0.0.1:3306)&#x2F;n9e_v6?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&amp;allowNativePasswords&#x3D;true&quot;# enable debug mode or not<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="导入数据库表"><a href="#导入数据库表" class="headerlink" title="导入数据库表"></a>导入数据库表</h4><p>执行如下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -uroot -p1234 &lt; n9e.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请通过数据库工具检测是否成功导入数据库表：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; show databases;+--------------------+| Database           |+--------------------+| n9e_v6             |+--------------------+&gt; show tables;+-----------------------+| Tables_in_n9e_v6      |+-----------------------+| alert_aggr_view       || alert_cur_event       || alert_his_event       || alert_mute            || alert_rule            || alert_subscribe       || alerting_engines      || board                 || board_busigroup       || board_payload         || builtin_cate          || builtin_components    || builtin_metrics       |······<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改夜莺配置文件"><a href="#修改夜莺配置文件" class="headerlink" title="修改夜莺配置文件"></a>修改夜莺配置文件</h4><p>你需要修改夜莺的配置文件，进行 Prometheus 数据源的设置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim &#x2F;home&#x2F;flashcat&#x2F;etc&#x2F;config.toml# 修改 [[Pushgw.Writers]] 部分的内容为[[Pushgw.Writers]]# Url &#x3D; &quot;http:&#x2F;&#x2F;127.0.0.1:8480&#x2F;insert&#x2F;0&#x2F;prometheus&#x2F;api&#x2F;v1&#x2F;write&quot;Url &#x3D; &quot;http:&#x2F;&#x2F;&#123;client_ip&#125;:9090&#x2F;api&#x2F;v1&#x2F;write&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="启动夜莺"><a href="#启动夜莺" class="headerlink" title="启动夜莺"></a>启动夜莺</h4><p>在夜莺的根目录 <code>/home/flashcat</code>下执行：<code>./n9e</code>。成功启动后，可在浏览器中访问 <code>http://&#123;client_ip&#125;:17000</code>，默认的登录账号和密码为：</p><ul><li><p>账号：<code>root</code></p></li><li><p>密码：<code>root.2020</code></p></li></ul><p><img src="/images/start'.png"></p><h4 id="接入-Prometheus-数据源"><a href="#接入-Prometheus-数据源" class="headerlink" title="接入 Prometheus 数据源"></a>接入 Prometheus 数据源</h4><p>左侧边栏集成 -&gt; 数据源 -&gt; Prometheus。</p><p><img src="/images/datasource-1.png"></p><p>至此，我们的夜莺监控就部署结束了。</p><h2 id="夜莺监控-AutoMQ-集群状态"><a href="#夜莺监控-AutoMQ-集群状态" class="headerlink" title="夜莺监控 AutoMQ 集群状态"></a>夜莺监控 AutoMQ 集群状态</h2><p>接下来，我将介绍夜莺监控提供的一部分功能，帮助你更好地了解夜莺与 AutoMQ 集成的可用功能。</p><h3 id="即时查询"><a href="#即时查询" class="headerlink" title="即时查询"></a>即时查询</h3><p>选择内置的 AutoMQ 指标：</p><p><img src="/images/query1.png"></p><p>可以尝试查询一些数据，比如Fetch请求处理时间的平均值 <code>kafka_request_time_50p_milliseconds</code>:</p><p><img src="/images/avg.png"></p><p><img src="/images/avg2.png"></p><p>同时你也可以自定义一些指标，并利用表达式对指标进行聚合：</p><p><img src="/images/%E8%81%9A%E5%90%88.png"></p><h3 id="警报功能"><a href="#警报功能" class="headerlink" title="警报功能"></a>警报功能</h3><p>选择左侧边栏警报 -&gt; 警报规则 -&gt; 新建规则。比如我们可以给 <code>kafka_network_io_bytes_total</code>设置报警，这个指标的意义是 Kafka Broker 节点通过网络发送或接收的字节总数，通过对这个指标设置表达式，就能够计算 Kafka Broker 节点的入站网络 I&#x2F;O 速率。表达式为：</p><pre class="line-numbers language-none"><code class="language-none">sum by(job, instance) (rate(kafka_network_io_bytes_total&#123;direction&#x3D;&quot;in&quot;&#125;[1m]))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置警报规则：</p><p><img src="/images/alertrule.png"></p><p>Data preview：</p><p><img src="/images/preview.png"></p><p>同时你也可以设置发生警报时会通知到的群组：</p><p><img src="/images/group.png"></p><p>创建完告警后，让我们来模拟高并发的消息处理场景：短时间内总共<code>2500000</code>条消息被发送到 AutoMQ 节点，我采用的方式是通过 Kafka SDK 的方式进行消息发送，一次共 50 个 Topic ，给每个 Topic 发送 500 条消息，共 100 次。示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.apache.kafka.clients.admin.AdminClient;import org.apache.kafka.clients.admin.AdminClientConfig;import org.apache.kafka.clients.admin.NewTopic;import org.apache.kafka.clients.producer.KafkaProducer;import org.apache.kafka.clients.producer.ProducerConfig;import org.apache.kafka.clients.producer.ProducerRecord;import org.apache.kafka.clients.producer.RecordMetadata;import org.apache.kafka.common.serialization.StringSerializer;import java.util.ArrayList;import java.util.List;import java.util.Properties;import java.util.concurrent.ExecutionException;public class KafkaTest &#123;    private static final String BOOTSTRAP_SERVERS &#x3D; &quot;http:&#x2F;&#x2F;&#123;&#125;:9092&quot;; &#x2F;&#x2F; your automq broker ip    private static final int NUM_TOPICS &#x3D; 50;    private static final int NUM_MESSAGES &#x3D; 500;    public static void main(String[] args) throws Exception &#123;        KafkaTest test &#x3D; new KafkaTest();        &#x2F;&#x2F; test.createTopics();    &#x2F;&#x2F; create 50 topics        for(int i &#x3D; 0; i &lt; 100; i++)&#123;            test.sendMessages();   &#x2F;&#x2F; 25,000 messages will be sent each time, and 500 messages will be sent to each of 50 topics.        &#125;    &#125;        public void createTopics() &#123;        Properties props &#x3D; new Properties();        props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, BOOTSTRAP_SERVERS);        try (AdminClient adminClient &#x3D; AdminClient.create(props)) &#123;            List&lt;NewTopic&gt; topics &#x3D; new ArrayList&lt;&gt;();            for (int i &#x3D; 1; i &lt;&#x3D; NUM_TOPICS; i++) &#123;                topics.add(new NewTopic(&quot;Topic-&quot; + i, 1, (short) 1));            &#125;            adminClient.createTopics(topics).all().get();            System.out.println(&quot;Topics created successfully&quot;);        &#125; catch (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;    public void sendMessages() &#123;        Properties props &#x3D; new Properties();        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, BOOTSTRAP_SERVERS);        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());        try (KafkaProducer&lt;String, String&gt; producer &#x3D; new KafkaProducer&lt;&gt;(props)) &#123;            for (int i &#x3D; 1; i &lt;&#x3D; NUM_TOPICS; i++) &#123;                String topic &#x3D; &quot;Topic-&quot; + i;                for (int j &#x3D; 1; j &lt;&#x3D; NUM_MESSAGES; j++) &#123;                    String key &#x3D; &quot;key-&quot; + j;                    String value &#x3D; &quot;&#123;\&quot;userId\&quot;: &quot; + j + &quot;, \&quot;action\&quot;: \&quot;visit\&quot;, \&quot;timestamp\&quot;: &quot; + System.currentTimeMillis() + &quot;&#125;&quot;;                    ProducerRecord&lt;String, String&gt; record &#x3D; new ProducerRecord&lt;&gt;(topic, key, value);                    producer.send(record, (RecordMetadata metadata, Exception exception) -&gt; &#123;                        if (exception &#x3D;&#x3D; null) &#123;                            System.out.printf(&quot;Sent message to topic %s partition %d with offset %d%n&quot;, metadata.topic(), metadata.partition(), metadata.offset());                        &#125; else &#123;                            exception.printStackTrace();                        &#125;                    &#125;);                &#125;            &#125;            System.out.println(&quot;Messages sent successfully&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>随后我们可以在夜莺控制台看到报警信息：</p><p><img src="/images/alert2.png"></p><p>告警详细信息：</p><p><img src="/images/alertinfo.png"></p><h3 id="仪表盘"><a href="#仪表盘" class="headerlink" title="仪表盘"></a>仪表盘</h3><p>首先我们可以利用已知的指标建立自己的仪表盘，如下所示是对 AutoMQ 消息请求处理时间，消息总数，网络 IO 比特数进行的统计仪表盘：</p><p><img src="/images/board.png"></p><p>同时，我们也可以利用官方内置的仪表盘进行监测。左侧边栏 -&gt; 聚合 -&gt; 模板中心：</p><p><img src="/images/template.png"></p><p>选择 AutoMQ，可以看到有几个 DashBoard 可以选用:</p><p><img src="/images/dashboard.png"></p><p>我们选择 Topic Metrics 仪表盘，展示内容如下：</p><p><img src="/images/metrics.png"></p><p>这里展示了 AutoMQ 集群在最近一段时间内的消息输入和输出的占用情况、消息输入和请求的速率、消息大小等。这些指标用于监控和优化 AutoMQ 集群的性能和稳定性：通过消息输入和输出的占用情况，可以评估生产者和消费者的负载，确保集群能正常处理消息流量；消息输入速率用于实时监控生产者发送消息的速率，从而识别潜在的瓶颈或突发流量；请求速率帮助了解客户端请求的频率，以便优化资源分配和处理能力；消息大小指标则用于分析消息的平均大小，从而调整配置以优化存储和网络传输效率。通过监控这些指标，能够及时发现并解决性能问题，确保 AutoMQ 集群的高效和稳定运行。</p><p>至此，我们的集成过程已完成。关于更多的使用方式，你可以参考夜莺的<a href="https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v7/overview/">官方文档</a> [10] 进行体验。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，我们详细阐述了如何使用夜莺监控系统（Nightingale）对 AutoMQ 集群进行全面监控。我们从AutoMQ 和夜莺的基本概念入手，逐步讲解了如何部署 AutoMQ、Prometheus 和夜莺，并配置监控和告警规则。通过这种集成，企业可以实时掌握 AutoMQ 集群的运行状态，及时发现和解决潜在问题，优化系统性能，确保业务的连续性和稳定性。夜莺监控系统以其强大的数据采集能力、灵活的告警机制和丰富的可视化功能，成为企业监控复杂分布式系统的理想选择。希望本文能为您在实际应用中提供有价值的参考，助力您的系统运维更加高效和稳定。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] AutoMQ：<a href="https://www.automq.com/zh">https://www.automq.com/zh</a></p><p>[2] 夜莺监控：<a href="https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v7/introduction/">https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v7/introduction/</a></p><p>[3] 夜莺架构：<a href="https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v7/introduction/">https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v7/introduction/</a></p><p>[4] Prometheus：<a href="https://prometheus.io/docs/prometheus/latest/getting_started/">https://prometheus.io/docs/prometheus/latest/getting_started/</a></p><p>[5] 集群方式部署 | AutoMQ：<a href="https://docs.automq.com/zh/docs/automq-opensource/IyXrw3lHriVPdQkQLDvcPGQdnNh">https://docs.automq.com/zh/docs/automq-opensource/IyXrw3lHriVPdQkQLDvcPGQdnNh</a></p><p>[6] Metrics | AutoMQ：<a href="https://docs.automq.com/zh/docs/automq-opensource/ArHpwR9zsiLbqwkecNzcqOzXn4b">https://docs.automq.com/zh/docs/automq-opensource/ArHpwR9zsiLbqwkecNzcqOzXn4b</a></p><p>[7] 将 Metrics 集成到 Prometheus：<a href="https://docs.automq.com/zh/automq/observability/integrating-metrics-with-prometheus">https://docs.automq.com/zh/automq/observability/integrating-metrics-with-prometheus</a></p><p>[8] 部署说明：<a href="https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v7/install/intro/">https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v7/install/intro/</a></p><p>[9] 夜莺 Github releases：<a href="https://github.com/ccfos/nightingale">https://github.com/ccfos/nightingale</a></p><p>[10] 夜莺官方文档：<a href="https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v7/overview/">https://flashcat.cloud/docs/content/flashcat-monitor/nightingale-v7/overview/</a></p>]]></content>
      
      
      <categories>
          
          <category> AutoMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常 PR</title>
      <link href="/2024/07/18/ri-chang-pr/"/>
      <url>/2024/07/18/ri-chang-pr/</url>
      
        <content type="html"><![CDATA[<p>这周做了一个 FP，主要是实现了腾讯云 COS 和华为云对象存储 OBS 的 CredentialsProvider。</p><p>（仓库是私有的，好像看不到具体的我的提交）<br><img src="/images/pr1.png"></p><p><img src="/images/pr2.png"></p><p>我简单解释一下就是：</p><ul><li>一种获取 AK 和 SK 的方式是静态的，也就是我们直接指定凭证去操作对象存储。</li><li>第二种是以 IAM 角色绑定服务器实例，通过服务器内请求远端 Imdsendpoint 得到临时凭证，之后就可以利用这个临时凭证去操作对象存储。</li></ul><p>至于<strong>为什么要获取临时凭证</strong>，这个主要是考虑到之后 AutoMQ 商业版会作为 Saas 服务提供给客户，客户只需要说：我需要换掉 Kafka 接入 AutoMQ，你们告诉我该怎么做。</p><p>我们直接提供商业版安装包，里面的逻辑都是封装好的，且在开源版的基础上增加了更多的实用功能，满足不同的需求。因此嘞，你只需要修改一下我们给的 terraform 配置文件，以及 ansible 等工具的配置，来完成自动化的部署，由于底层兼容了各大云厂商的 Api 以及 IMDS，所以你只需要照着说明来理解。</p><p>至于其他的一些逻辑，我之后做到了或者理解了会发一部分内容，尽情期待。</p>]]></content>
      
      
      
        <tags>
            
            <tag> push </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus + Grafana监控搞定了</title>
      <link href="/2024/07/14/prometheus-grafana-xiang-mu-jian-kong-gao-ding-liao/"/>
      <url>/2024/07/14/prometheus-grafana-xiang-mu-jian-kong-gao-ding-liao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章只是碎碎念，格式不太好请见谅，今天好好的做了些自己的事情，之后可能就很少有时间自己做了。</p></blockquote><p>今天上午把本地的 Prometheus + Grafana 监控搞定了，然后下午就尝试在服务器上部署，然后把前端页面改了一下，搞了个弹窗用来提示 Grafana 监控功能上线，然后导航栏也加了个按钮。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>目前的效果是能看到下面这种数据监控情况：<br><img src="/images/Prometheus%20+%20Grafana%E7%9B%91%E6%8E%A7%E6%90%9E%E5%AE%9A%E4%BA%86.png"></p><p>其实感觉还挺有用的，我暂时还没设置报警，这个功能可以在后续监控到响应时间不正常的接口进行报警和通知，通知的形式有很多种，包括邮箱，飞书 bot 等。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>然后嘞，我提供了两个版本：</p><ul><li>快照版本：也就是某个时间段的数据，这个主要是为了避免访客在使用时看不到数据，还得自己去调接口从而拿到数据的情况。</li><li>实时更新版本：这个就是正常的选择最近的时间范围了，比如几个小时之内，几十分钟之内啊，或者具体的某一天的统计情况，这个就看你自己的选择了，你也可以适当的压测一些接口（虽然我做了限流就是说😏，你可以试一下短链接跳转多来那么个几百上千次访问没问题的）。</li></ul><p>这两个版本都需要进行登录，我专门创建了一个访客用户，你可以访问这些数据：</p><ul><li>用户名：<code>visitor</code> </li><li>密码：<code>wzc123</code></li></ul><h2 id="关于部署教程"><a href="#关于部署教程" class="headerlink" title="关于部署教程"></a>关于部署教程</h2><p>很抱歉，目前只有一篇我自己在做重构的时候输出的步骤文章，但是暂时没办法细细优化，总不能拿一篇水文来给各位。所以呢这个计划就暂时搁置了，之后会找时间整理一下，争取输出一篇高质量的文章，帮你避免很多坑的那种（主要是我也踩坑很多）。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>还是决定把项目地址公布出来了，也希望大家能帮我找出更多的问题，也能让我有所准备并解决。</p><ul><li>项目部署地址： <a href="http://www.ktpro.ink/login">http://www.ktpro.ink/login</a></li></ul><p>其中也包括了 Grafana 监控的提示，你可以自行查看！</p><p>还有一件事也蛮开心的，换成 consul 之后，整个项目 + 中间件的内存占用才不到 3g，之前用 nacos 不加监控就已经达到 3.6g。因此还要强调一次：注重项目结构的搭建和中间件选用，最大程度的在满足功能的前提下节省成本。</p><p>实际上，这个和 AutoMQ 的理念不谋而合，都是以实用为主，最大程度的提高资源利用率和效率。</p><p>祝大家生活愉快！</p><p>好想去旅行….<br><img src="/images/Snipaste_2024-05-07_19-52-55.png"></p><hr><p>害，好多计划搁置了：<br><img src="/images/1-2.png"></p><p><img src="/images/2-3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>很开心，换掉 Nacos 后服务器内存省下很多！</title>
      <link href="/2024/07/13/hen-kai-xin-huan-diao-nacos-hou-fu-wu-qi-nei-cun-sheng-xia-hen-duo/"/>
      <url>/2024/07/13/hen-kai-xin-huan-diao-nacos-hou-fu-wu-qi-nei-cun-sheng-xia-hen-duo/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如题，最近打算在项目中引入 Grafana + Prometheus 作为数据监控，用来监控服务接口调用次数以及重点接口耗时等情况，这个后续做完会出一篇教程。</p><p>我们还是先看看替换之后的结果（旧的截图忘记截了），可以看到目前所有中间件加两个项目模块启动后内存占用是 <strong>2.5g</strong>，这个是什么概念呢，在之前用 Nacos 时总的内存占用达到了 <strong>3.6 g</strong>，也就是说只换掉了一个 Nacos 就节省了 1g 的内存，这 1g 内存你去部署个博客都绰绰有余了：<br><img src="/images/linux.png"></p><p>而且还有一个可怕的一点是，之前我的中间件如 Redis，Mysql，Nacos 都是 Docker 方式部署，比较方便，并且呢对容器的内存大小作了限制，容器如果运行内存超过限制就被扼杀掉，保证系统不会崩掉。说重点，之前通过 <code>docker stats</code> 查看容器占用情况，Nacos 是一直稳定在 1g 左右的（限制最大为 1.5g），所以现在来看，Consul 几乎是不占内存的 ??，神奇，相见恨晚呐。</p><p>我现在只有一台服务器，配置是 2c 4g 的，和公司分的 8c 16g 根本没法比，但是我只需要部署的模块只有两个，一个聚合服务，一个网关服务。所以需求其实不高。但是我发现了一个问题，就是 Nacos 的占用实在是太高了，然后我们继续来看下面 Nacos 的特点和功能。</p><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><strong>多功能集成</strong>：Nacos 集成了服务发现、配置管理和动态 DNS 服务，功能非常全面。</li><li><strong>简单易用</strong>：Nacos 提供简单的 API 和用户界面，易于使用和管理。</li><li><strong>健康检查</strong>：支持多种健康检查方式，包括 HTTP、TCP 和自定义脚本。</li><li><strong>动态配置管理</strong>：支持分布式配置管理，支持配置的实时推送和灰度发布。</li><li><strong>多种数据存储支持</strong>：支持 MySQL、嵌入式数据库等多种存储方式，便于灵活选择。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>成熟度</strong>：相对于 Consul，Nacos 的成熟度和社区支持可能稍逊一筹。</li><li><strong>性能和扩展性</strong>：在高并发、大规模场景下，Nacos 的性能和扩展性可能需要进一步优化。</li><li><strong>依赖性</strong>：Nacos 依赖于 MySQL 等外部存储，增加了系统复杂性。</li></ol><p>我们可以看到 Nacos 的一个很大的缺点就是<strong>性能比较低</strong>，或者说比较重，当然我不是说 Nacos 不好，对于新手来说，一套 Spring Cloud Alibaba 系列下的中间件都是非常兼容的，对于初学微服务来说非常的好使。</p><p>然而，Consul 由于是更加面向国际的开源项目，它的功能也非常全面，且弊端很小，所以我就考虑了使用 Consul 来替换 Nacos，毕竟它也兼容 Spring Cloud。下面还是先介绍一下 Consul。</p><h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><p>Consul 是 HashiCorp 提供的一款开源工具，主要用于服务发现和配置管理，具有强大的分布式特性和高可用性。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li><strong>成熟稳定</strong>：Consul 经过多年的发展，已经非常成熟和稳定，广泛应用于生产环境。</li><li><strong>高可用和分布式</strong>：Consul 采用 Raft 协议，保证了分布式系统的一致性和高可用性。</li><li><strong>多数据中心支持</strong>：支持多数据中心的服务发现和配置管理，适用于复杂的分布式系统。</li><li><strong>丰富的健康检查</strong>：支持多种健康检查方式，包括 HTTP、TCP 和自定义脚本。</li><li><strong>强大的生态系统</strong>：Consul 具有丰富的插件和工具生态，易于与其他系统集成。</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li><strong>学习曲线</strong>：Consul 的配置和管理相对复杂，学习曲线较陡。</li><li><strong>功能单一</strong>：Consul 主要专注于服务发现和配置管理，功能相对单一。</li><li><strong>存储依赖</strong>：Consul 依赖于其内置的存储系统（基于 Raft 协议），在某些情况下可能不如外部存储灵活。</li></ol><p>一看到缺点，我们会想到学习曲线抖？你是说一个换掉 Nacos 的 pom 依赖，再改一下配置文件的 Consul 开放端口算难度高？好吧，其实要复杂点，你再配置个 ACL，再配置用户认证，那确实会难度陡增，然而，Nacos 不也一样，如果你要用复杂的功能。而且对于我们这种小项目，最重要的就是功能和业务展示，也不会说遇到各种乱七八糟的错误，所以换掉 Nacos 对于我们来说非常的划算。如果之后做项目，我同样选择 Consul。</p><h2 id="关于如何部署-Consul"><a href="#关于如何部署-Consul" class="headerlink" title="关于如何部署 Consul"></a>关于如何部署 Consul</h2><ol><li>参考官方文档，选择一种方式部署即可。参考：<a href="https://developer.hashicorp.com/consul/docs/install">Install Consul | Consul | HashiCorp Developer</a> </li><li>Pom 依赖<pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;&lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>项目中的配置文件，你可以参考下面这种：<pre class="line-numbers language-none"><code class="language-none">spring  cloud:    consul:      host: localhost      port: 8500      discovery: # 指定注册对外暴露的服务名称        service-name: $&#123;spring.application.name&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>这篇文档并不是专门的配置教程，而且也不难，主要是希望你在选择中间件时多考虑自己的需要，合适最好！</p><p>接下来，我将着手引入 Prometheus 和 Grafana，尽情期待！</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过 CloudCanal 实现从 Kafka 到 AutoMQ 的数据迁移</title>
      <link href="/2024/07/12/ru-he-tong-guo-cloudcanal-shi-xian-cong-kafka-dao-automq-de-shu-ju-qian-yi/"/>
      <url>/2024/07/12/ru-he-tong-guo-cloudcanal-shi-xian-cong-kafka-dao-automq-de-shu-ju-qian-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实习过程中，接触到了 Kafka 数据迁移，了解到了好多的数据迁移工具，比如 CloudCanal，DataX等。<br>其实我觉得这些对于开发人员来说也是要会的一件事，因为我们自己开发过程中可能会用到将数据从 Mysql 直接同步到消息队列的Topic中，也就是直接模拟日志入队来验证某些功能是否能正常工作，提前发现问题，并且呢这类迁移数据的工具非常的多，且支持很多的源数据源和目标数据源，能解决我们大多数的数据迁移问题。</p><p>所以顺便写了篇文档，希望也能对你有所帮助！</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>随着大数据技术的飞速发展，Apache Kafka 作为一种高吞吐量、低延迟的分布式消息系统，已经成为企业实时数据处理的核心组件。然而，随着业务的扩展和技术的发展，企业面临着不断增加的存储成本和运维复杂性问题。为了更好地优化系统性能和降低运营成本，企业开始寻找更具优势的消息系统解决方案。其中，<a href="https://docs.automq.com/zh/docs/automq-opensource/HSiEwHVfdiO7rWk34vKcVvcvn2Z">AutoMQ</a> [1] 作为一种基于云重新设计的消息系统，凭借其显著的成本优势和弹性能力，成为了企业的理想选择。</p><h3 id="AutoMQ-概述"><a href="#AutoMQ-概述" class="headerlink" title="AutoMQ 概述"></a><strong>AutoMQ 概述</strong></h3><p>AutoMQ 基于云重新设计了 Kafka，将存储分离至对象存储，在保持与 Apache Kafka 100% 兼容的前提下，为用户提供高达10倍的成本优势和百倍的弹性优势。AutoMQ 通过构建在S3上的流存储库 S3Stream，将存储卸载至云厂商提供的共享云存储 EBS 和 S3，提供低成本、低延时、高可用、高可靠和无限容量的流存储能力。与传统的Shared Nothing 架构相比，AutoMQ 采用了 Shared Storage 架构，显著降低了存储和运维的复杂性，同时提升了系统的弹性和可靠性。</p><p>AutoMQ 的设计理念和技术优势使其成为替换企业现有 Kafka 集群的理想选择。通过采用 AutoMQ，企业可以显著降低存储成本，简化运维，并实现集群的自动扩缩容和流量自平衡，从而更高效地应对业务需求的变化。</p><p><img src="/images/a3128234-2cc4-4e0a-9561-2f8c5654e2ec.gif"></p><h3 id="CloudCanal-概述"><a href="#CloudCanal-概述" class="headerlink" title="CloudCanal 概述"></a><strong>CloudCanal 概述</strong></h3><p><a href="https://www.clougence.com/?src=cc-doc">CloudCanal</a> [2] 是一款数据同步、迁移工具，帮助企业构建高质量数据管道，具备实时高效、精确互联、稳定可拓展、一站式、混合部署、复杂数据转换等优点。CloudCanal 支持数据迁移、数据同步、结构迁移和同步、数据校验和订正等功能，能够满足企业在数据管理过程中对于数据质量和稳定性的高要求。通过消费源端数据源的增量操作日志，CloudCanal 可以准实时地在对端数据源重放操作，以达到数据同步的目的。</p><h3 id="数据迁移的必要性"><a href="#数据迁移的必要性" class="headerlink" title="数据迁移的必要性"></a><strong>数据迁移的必要性</strong></h3><p>在企业的日常运营中，数据系统的升级和迁移是不可避免的。例如，当企业的电商平台面临流量激增和数据量爆炸式增长时，现有的 Kafka 集群可能无法满足需求，导致性能瓶颈和存储成本的显著增加。为了应对这些挑战，企业可能决定迁移到更具成本效益和弹性的 AutoMQ 系统。</p><p>在这种迁移过程中，全量同步和增量同步都是关键步骤。全量同步可以将 Kafka 中的所有现有数据迁移到 AutoMQ，确保基础数据的完整性。增量同步则在全量同步完成后，实时捕捉和同步 Kafka 中的新增和变更数据，确保在迁移过程中，两个系统之间的数据保持一致。接下来，我将以增量同步为例，详细介绍如何使用 CloudCanal 实现从 Kafka 到 AutoMQ 的数据迁移，确保数据在迁移过程中保持一致和完整。</p><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>在进行数据迁移之前，需要确保以下前提条件已经满足。本文将以一个 Kafka 节点和一个 AutoMQ 节点为例，演示增量同步的过程。</p><ol><li><p><strong>Kafka</strong> <strong>节点</strong>：一个已部署并运行的 Kafka 节点，确保 Kafka 节点能够正常接收和处理消息，Kafka节点的网络配置允许与 CloudCanal 服务通信。</p></li><li><p><strong>AutoMQ 节点</strong>：一个已部署并运行的 AutoMQ 节点，确保 AutoMQ 节点能够正常接收和处理消息，AutoMQ 节点的网络配置允许与 CloudCanal 服务通信。</p></li><li><p><strong>CloudCanal 服务</strong>: 已部署和配置好的 CloudCanal 服务。</p></li></ol><h2 id="部署-AutoMQ、kafka-以及-CloudCanal"><a href="#部署-AutoMQ、kafka-以及-CloudCanal" class="headerlink" title="部署 AutoMQ、kafka 以及 CloudCanal"></a>部署 AutoMQ、kafka 以及 CloudCanal</h2><h3 id="部署-AutoMQ"><a href="#部署-AutoMQ" class="headerlink" title="部署 AutoMQ"></a>部署 AutoMQ</h3><p>参考 AutoMQ 官网文档: <a href="https://docs.automq.com/zh/docs/automq-opensource/EvqhwAkpriAomHklOUzcUtybn7g">QuickStart | AutoMQ</a> [3]</p><h3 id="部署-Kafka"><a href="#部署-Kafka" class="headerlink" title="部署 Kafka"></a>部署 Kafka</h3><p>参考 Apache Kafka 官方文档：<a href="https://kafka.apache.org/quickstart">QuickStart | Kafka</a> [4]</p><h3 id="部署-CloudCanal"><a href="#部署-CloudCanal" class="headerlink" title="部署 CloudCanal"></a>部署 CloudCanal</h3><h4 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h4><ol><li>安装基础工具</li></ol><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">## ubuntusudo apt updatesudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-commonsudo apt-get install -y lsofsudo apt-get install -y bcsudo apt-get install -y p7zip-full<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>下载安装包</li></ol><p>登录 <a href="https://www.clougence.com/?src=cc-doc-install-linux">CloudCanal 官方网站</a> [5]，点击下载私有部署版按钮，获取软件包下载链接。下载并解压到文件夹<code>/opt/</code></p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">cd &#x2F;opt# 下载wget -cO cloudcanal.7z &quot;$&#123;软件包下载链接&#125;&quot;# 解压7z x cloudcanal.7z -o.&#x2F;cloudcanal_homecd cloudcanal_home&#x2F;install_on_docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>install_on_docker</code>目录内容包括</p><ul><li><strong>镜像</strong>: images 目录下四个 tar 结尾的压缩文件</li><li><strong>docker 容器编排文件</strong>: docker-compose.yml 文件</li><li><strong>脚本</strong>：一些管理 CloudCanal 容器以及维护的脚本</li></ul><ol start="3"><li>准备 Docker 环境</li></ol><p>请确保以下端口未被占用</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>组件</td><td>端口</td><td>用途</td></tr><tr><td>cloudcanal-mysql</td><td>25000</td><td>元数据库 mysql 对外映射端口</td></tr><tr><td>cloudcanal-prometheus</td><td>19090</td><td>prometheuse 监控指标查询端口</td></tr><tr><td>cloudcanal-console</td><td>7007</td><td>console 和 sidecar 通信端口</td></tr><tr><td>cloudcanal-console</td><td>8111</td><td>console web控制台端口</td></tr><tr><td>cloudcanal-sidecar</td><td>18787</td><td>任务 debug 端口（e.g.,自定义代码 debug）</td></tr></tbody></table><p>如果你没有 docker 和 docker compose 环境，可参考 <a href="https://docs.docker.com/engine/install/">Docker 官方文档</a> [6] (版本 <strong>17.x.x</strong> 及以上)。也可直接使用目录中提供的脚本进行安装：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">## ubuntu,进入 install_on_docker 目录bash .&#x2F;support&#x2F;install_ubuntu_docker.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li>启动 CloudCanal，执行安装脚本以启动：</li></ol><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">## ubuntubash install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>出现如下标识即安装成功<br><img src="/images/sucess.png"></p><h4 id="激活-CloudCanal"><a href="#激活-CloudCanal" class="headerlink" title="激活 CloudCanal"></a>激活 CloudCanal</h4><p>安装成功后，你可以通过 <code>http://&#123;ip&#125;:8111</code> 在浏览器中访问 CloudCanal 的控制台。注意，如果无法正常访问页面，可以尝试通过脚本更新当前 CloudCanal 的版本，可使用如下命令：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML"># 进入安装目录cd &#x2F;opt&#x2F;cloudcanal_home&#x2F;install_on_docker# 停止当前 CloudCanalsudo bash stop.sh# 更新并启动新的 CloudCanalsudo bash upgrade.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>进入登录界面后，通过试用账号登录<ul><li>账号: <code>test@clougence.com</code></li><li>密码: <code>clougence2021</code></li><li>默认验证码: 777777</li></ul></li><li>登录成功，需要激活 CloudCanal 账号即可正常使用。申请免费许可证并激活: <a href="https://www.clougence.com/cc-doc/license/license_use">许可证获取 | CloudCanal</a> [7]，激活成功后，主界面状态为：<br><img src="/images/home.png"></li></ol><h2 id="数据迁移过程"><a href="#数据迁移过程" class="headerlink" title="数据迁移过程"></a>数据迁移过程</h2><h3 id="准备源端-Kafka-数据"><a href="#准备源端-Kafka-数据" class="headerlink" title="准备源端 Kafka 数据"></a>准备源端 Kafka 数据</h3><p>可以选择如下方式：</p><ul><li><p>CloudCanal 提供的 Mysql-&gt;Kafka 数据同步过程，参考：<a href="https://www.clougence.com/cc-doc/bestPractice/mysql_kafka_sync">MySQL 到 Kafka 同步 | CloudCanal</a> [8]</p></li><li><p>通过 Kafka SDK 准备数据</p></li><li><p>通过 Kafka 提供的脚本手动生产消息</p></li></ul><p>这里我将通过 Kafka SDK 的方式进行数据准备，下面是参考代码：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">import org.apache.kafka.clients.admin.AdminClient;import org.apache.kafka.clients.admin.AdminClientConfig;import org.apache.kafka.clients.admin.NewTopic;import org.apache.kafka.clients.producer.KafkaProducer;import org.apache.kafka.clients.producer.ProducerConfig;import org.apache.kafka.clients.producer.ProducerRecord;import org.apache.kafka.clients.producer.RecordMetadata;import org.apache.kafka.common.serialization.StringSerializer;import java.util.ArrayList;import java.util.List;import java.util.Properties;import java.util.concurrent.ExecutionException;public class KafkaTest &#123;    private static final String BOOTSTRAP_SERVERS &#x3D; &quot;$&#123;kafka_broker_ip:port&#125;&quot;; &#x2F;&#x2F;修改为你自己的 Kafka 节点地址    private static final int NUM_TOPICS &#x3D; 50;    private static final int NUM_MESSAGES &#x3D; 500;    public static void main(String[] args) throws Exception &#123;        KafkaTest test &#x3D; new KafkaTest();        test.createTopics();        test.sendMessages();    &#125;        &#x2F;&#x2F; 创建50个 Topic，格式为 Topic-n    public void createTopics() &#123;        Properties props &#x3D; new Properties();        props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, BOOTSTRAP_SERVERS);        try (AdminClient adminClient &#x3D; AdminClient.create(props)) &#123;            List&lt;NewTopic&gt; topics &#x3D; new ArrayList&lt;&gt;();            for (int i &#x3D; 1; i &lt;&#x3D; NUM_TOPICS; i++) &#123;                topics.add(new NewTopic(&quot;Topic-&quot; + i, 1, (short) 1));            &#125;            adminClient.createTopics(topics).all().get();            System.out.println(&quot;Topics created successfully&quot;);        &#125; catch (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;    &#x2F;&#x2F; 为50个 Topic-n 分别发送序号从1到1000共一千条消息，消息格式为 Json格式    public void sendMessages() &#123;        Properties props &#x3D; new Properties();        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, BOOTSTRAP_SERVERS);        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());        try (KafkaProducer&lt;String, String&gt; producer &#x3D; new KafkaProducer&lt;&gt;(props)) &#123;            for (int i &#x3D; 1; i &lt;&#x3D; NUM_TOPICS; i++) &#123;                String topic &#x3D; &quot;Topic-&quot; + i;                for (int j &#x3D; 1; j &lt;&#x3D; NUM_MESSAGES; j++) &#123;                    String key &#x3D; &quot;key-&quot; + j;                    String value &#x3D; &quot;&#123;\&quot;userId\&quot;: &quot; + j + &quot;, \&quot;action\&quot;: \&quot;visit\&quot;, \&quot;timestamp\&quot;: &quot; + System.currentTimeMillis() + &quot;&#125;&quot;;                    ProducerRecord&lt;String, String&gt; record &#x3D; new ProducerRecord&lt;&gt;(topic, key, value);                    producer.send(record, (RecordMetadata metadata, Exception exception) -&gt; &#123;                        if (exception &#x3D;&#x3D; null) &#123;                            System.out.printf(&quot;Sent message to topic %s partition %d with offset %d%n&quot;, metadata.topic(), metadata.partition(), metadata.offset());                        &#125; else &#123;                            exception.printStackTrace();                        &#125;                    &#125;);                &#125;            &#125;            System.out.println(&quot;Messages sent successfully&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建完成后，可以通过各种可视化工具查看 Kafka 节点状态，比如 <a href="https://redpanda.com/redpanda-console-kafka-ui">Redpanda Console</a> [9]、<a href="https://github.com/obsidiandynamics/kafdrop">Kafdrop</a> [10] 等。这里我选择 Redpanda Console，可以看到当前已经有了 50 个Topic，并且每个 Topic 下有500条初始消息。<br><img src="/images/50.png"></p><p>其中消息的格式为 Json：</p><pre class="line-numbers language-JSON" data-language="JSON"><code class="language-JSON">&#123;    &quot;action&quot;: &quot;INSERT&#x2F;UPDATE&#x2F;DELETE&quot;,    &quot;bid&quot;: 1,    &quot;before&quot;: [],    &quot;data&quot;: [&#123;        &quot;id&quot;:&quot;string data&quot;,        &quot;username&quot;:&quot;string data&quot;,        &quot;user_id&quot;:&quot;string data&quot;,        &quot;ip&quot;:&quot;string data&quot;,        &quot;request_time&quot;:&quot;1608782968300&quot;,&quot;request_type&quot;:&quot;string data&quot;&#125;],    &quot;db&quot;: &quot;access_log_db&quot;,    &quot;schema&quot;: &quot;&quot;,    &quot;table&quot;:&quot;access_log&quot;,    &quot;dbValType&quot;: &#123;        &quot;id&quot;:&quot;INT&quot;,        &quot;username&quot;:&quot;VARCHAR&quot;,        &quot;user_id&quot;:&quot;INT&quot;,        &quot;ip&quot;:&quot;VARCHAR&quot;,        &quot;request_time&quot;:&quot;TIMESTAMP&quot;,        &quot;request_type&quot;:&quot;VARCHAR&quot;,&#125;,    &quot;jdbcType&quot;: &#123;        &quot;id&quot;:&quot;0&quot;,        &quot;username&quot;:&quot;0&quot;,        &quot;user_id&quot;:&quot;0&quot;,        &quot;ip&quot;:&quot;0&quot;,        &quot;request_time&quot;:&quot;0&quot;,        &quot;request_type&quot;:&quot;0&quot;,&#125;,    &quot;entryType&quot;: &quot;ROWDATA&quot;,    &quot;isDdl&quot;: false,    &quot;pks&quot;: [&quot;id&quot;],    &quot;execTs&quot;: 0,    &quot;sendTs&quot;: 0,    &quot;sql&quot;: &quot;&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并且，AutoMQ 节点当前并无任何数据：<br><img src="/images/automq.png"></p><h3 id="添加-CloudCanal-数据源"><a href="#添加-CloudCanal-数据源" class="headerlink" title="添加 CloudCanal 数据源"></a>添加 CloudCanal 数据源</h3><p>CloudCanal 界面上方 数据源管理 -&gt; 新增数据源<br><img src="/images/datasource.png"></p><p>同理增加 Kafka 数据源，并对两个节点都进行连接测试，可以得到如下结果：<br><img src="/images/23.png"></p><h3 id="创建数据迁移任务"><a href="#创建数据迁移任务" class="headerlink" title="创建数据迁移任务"></a>创建数据迁移任务</h3><ol><li><p>CloudCanal 界面上方 同步任务-&gt;创建任务<br><img src="/images/task.png"></p></li><li><p>选择任务规格，这取决于你需要迁移的数据量大小：<br><img src="/images/2-2.png"></p></li><li><p>选择需要进行数据迁移的 Topics：<br><img src="/images/topic.png"></p></li><li><p>任务确定<br><img src="/images/task2.png"></p></li><li><p>任务创建完成后默认自动启动，会跳转到任务列表，你还需要更改源数据源配置以开启心跳配置，能及时更新任务状态，步骤为 任务详情-&gt;源数据源配置-&gt;修改配置-&gt;生效配置：<br><img src="/images/5-2.png"></p></li><li><p>随后等待任务重启完成，即可看到如下情况：<br><img src="/images/6-1.png"></p></li><li><p>验证 AutoMQ 中是否已经正确创建了 Topic 结构<br><img src="/images/7-1.png"></p></li></ol><h3 id="准备增量数据"><a href="#准备增量数据" class="headerlink" title="准备增量数据"></a>准备增量数据</h3><p>任务已经正常运行，接下来我们需要准备增量数据，使得迁移任务能够将增量数据同步到 AutoMQ。这里我们仍然通过 Kafka SDK 新增数据。新增数据之后，我们可以通过 <strong>任务详情-&gt;增量同步-&gt;查看日志-&gt;任务运行日志</strong> 中查看任务执行情况：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">2024-07-11 17:16:45.995 [incre-fetch-from-buffer-14-thd-0] INFO  c.c.c.mq.worker.reader.kafka.KafkaIncreEventBroker - getWithoutAck successfully, batch:64, real:642024-07-11 17:16:45.995 [incre-fetch-from-buffer-14-thd-0] INFO  c.c.c.mq.worker.reader.kafka.KafkaIncreEventBroker - getWithoutAck successfully, batch:64, real:642024-07-11 17:16:45.996 [incre-fetch-from-buffer-14-thd-0] INFO  c.c.c.mq.worker.reader.kafka.KafkaIncreEventBroker - getWithoutAck successfully, batch:64, real:642024-07-11 17:16:45.996 [incre-fetch-from-buffer-14-thd-0] INFO  c.c.c.mq.worker.reader.kafka.KafkaIncreEventBroker - getWithoutAck successfully, batch:64, real:642024-07-11 17:16:45.996 [incre-fetch-from-buffer-14-thd-0] INFO  c.c.c.mq.worker.reader.kafka.KafkaIncreEventBroker - getWithoutAck successfully, batch:64, real:642024-07-11 17:16:45.997 [incre-fetch-from-buffer-14-thd-0] INFO  c.c.c.mq.worker.reader.kafka.KafkaIncreEventBroker - getWithoutAck successfully, batch:64, real:642024-07-11 17:16:45.997 [incre-fetch-from-buffer-14-thd-0] INFO  c.c.c.mq.worker.reader.kafka.KafkaIncreEventBroker - getWithoutAck successfully, batch:64, real:642024-07-11 17:16:45.997 [incre-fetch-from-buffer-14-thd-0] INFO  c.c.c.mq.worker.reader.kafka.KafkaIncreEventBroker - getWithoutAck successfully, batch:64, real:642024-07-11 17:16:45.998 [incre-fetch-from-buffer-14-thd-0] INFO  c.c.c.mq.worker.reader.kafka.KafkaIncreEventBroker - getWithoutAck successfully, batch:64, real:642024-07-11 17:16:45.998 [incre-fetch-from-buffer-14-thd-0] INFO  c.c.c.mq.worker.reader.kafka.KafkaIncreEventBroker - getWithoutAck successfully, batch:64, real:642024-07-11 17:16:45.998 [incre-fetch-from-buffer-14-thd-0] INFO  c.c.c.mq.worker.reader.kafka.KafkaIncreEventBroker - getWithoutAck successfully, batch:64, real:642024-07-11 17:16:45.999 [incre-fetch-from-buffer-14-thd-0] INFO  c.c.c.mq.worker.reader.kafka.KafkaIncreEventBroker - getWithoutAck successfully, batch:64, real:64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="验证迁移结果"><a href="#验证迁移结果" class="headerlink" title="验证迁移结果"></a>验证迁移结果</h2><p>验证AutoMQ是否正确同步到消息：<br><img src="/images/11-1.png"></p><p><img src="/images/12-1.png"></p><p>多次新增数据后依旧正常完成迁移：<br><img src="/images/13.png"></p><p>可以看到在增量同步任务执行期间对 Kafka 新增的数据都已经同步到了 AutoMQ 中。至此，我们的迁移过程已经全部完成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>随着企业数据规模的不断扩大和业务需求的多样化，数据迁移和同步变得尤为重要。通过本文的介绍，我们详细探讨了如何利用 CloudCanal 实现从 Kafka 到 AutoMQ 的增量同步数据迁移，以应对存储成本和运维复杂性的问题。在迁移过程中，增量同步技术确保了数据的一致性和业务的连续性，为企业提供了一个高效、可靠的解决方案。</p><p>希望本文能够为你在数据迁移和同步方面提供有价值的参考和指导，帮助实现系统的平滑过渡和性能优化!</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] AutoMQ: <a href="https://docs.automq.com/zh/docs/automq-opensource/HSiEwHVfdiO7rWk34vKcVvcvn2Z">https://docs.automq.com/zh/docs/automq-opensource/HSiEwHVfdiO7rWk34vKcVvcvn2Z</a><br>[2] CloudCanal: <a href="https://www.clougence.com/?src=cc-doc">https://www.clougence.com/?src=cc-doc</a><br>[3] QuickStart | AutoMQ: <a href="https://docs.automq.com/zh/docs/automq-opensource/EvqhwAkpriAomHklOUzcUtybn7g">https://docs.automq.com/zh/docs/automq-opensource/EvqhwAkpriAomHklOUzcUtybn7g</a><br>[4] QuickStart | Kafka: <a href="https://kafka.apache.org/quickstart">https://kafka.apache.org/quickstart</a><br>[5] CloudCanal 官方网站: <a href="https://www.clougence.com/?src=cc-doc-install-linux">https://www.clougence.com/?src=cc-doc-install-linux</a><br>[6] Docker 官方文档: <a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a><br>[7] 许可证获取 | CloudCanal: <a href="https://www.clougence.com/cc-doc/license/license_use">https://www.clougence.com/cc-doc/license/license_use</a><br>[8] MySQL 到 Kafka 同步 | CloudCanal: <a href="https://www.clougence.com/cc-doc/bestPractice/mysql_kafka_sync">https://www.clougence.com/cc-doc/bestPractice/mysql_kafka_sync</a><br>[9] Redpanda Console: <a href="https://redpanda.com/redpanda-console-kafka-ui">https://redpanda.com/redpanda-console-kafka-ui</a><br>[10] Kafdrop: <a href="https://github.com/obsidiandynamics/kafdrop">https://github.com/obsidiandynamics/kafdrop</a><br>[11] FAQ 索引 | CloudCanal: <a href="https://www.clougence.com/cc-doc/faq/cloudcanal_faq_list">https://www.clougence.com/cc-doc/faq/cloudcanal_faq_list</a></p>]]></content>
      
      
      <categories>
          
          <category> AutoMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过三种方式部署 Redpanda？</title>
      <link href="/2024/07/06/ru-he-tong-guo-san-chong-fang-shi-bu-shu-redpanda/"/>
      <url>/2024/07/06/ru-he-tong-guo-san-chong-fang-shi-bu-shu-redpanda/</url>
      
        <content type="html"><![CDATA[<p>刚好工作中用到 Redpanda，这里就写了一篇在部署过程中的操作和小 Tips。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虽然 redpanda 是基于 Kafka 的流处理系统，但是它是用 C++写的，因此启动方式并不一样，不像kafka那样用脚本就可以实现简单的topic管理和收发消息。</p><blockquote><p>Redpanda有自己的工具集，主要是rpk命令行工具，而不是使用Kafka的启动脚本和管理工具。rpk工具旨在提供一种简单、一致的方式来管理Redpanda集群，包括配置、启动、监控和维护等任务。</p></blockquote><p>由于是 C++ 编写，而且不需要 Zookeeper 和 JVM ,因此速度相比 Kafka 提升很多，大概有下三点：</p><ul><li><p>操作简单。只有一个二进制可执行文件，部署简单，无需jvm、zk。</p></li><li><p>尽可能的零数据丢失。使用raft协议保障数据安全。</p></li><li><p>实测比kafka快10倍。Thread-Per-Core架构和io_uring的加持，使得其比kafka更快。</p></li></ul><blockquote><p>参考：<a href="https://blog.csdn.net/yaxuan88521/article/details/128884371">kafka替代者:Redpanda的架构及部署-CSDN博客</a></p></blockquote><p>官方说明：</p><blockquote><ul><li><p>Redpanda 的设计目标是在任何数据流工作负载上实现最佳性能。</p></li><li><p>它可以扩展以使用单台机器上的所有可用资源，也可以扩展以将性能分布到多个节点。Redpanda 基于 C++ 构建，与其他平台相比，它提供更高的吞吐量和低 10 倍的 p99 延迟。这实现了以前难以想象的使用案例，这些用例需要高吞吐量、低延迟和最小的硬件占用空间。</p></li><li><p>Redpanda 被打包为单个二进制文件：它不依赖于任何外部系统。</p></li><li><p>它与 Kafka API 兼容，因此可以与基于 Kafka 构建的完整工具和集成生态系统配合使用。Redpanda 可以部署在数据中心或云中的裸机、容器或虚拟机上。Redpanda 控制台可让您轻松设置、管理和监控集群。此外，分层存储可让您近乎实时地将日志段卸载到对象存储，从而提供长期数据保留和主题恢复。</p></li><li><p>Redpanda在整个平台上使用<a href="https://raft.github.io/">Raft 共识算法来协调将数据写入日志文件并在多个服务器之间复制该数据。</a></p></li><li><p>Raft 促进了 Redpanda 集群中节点之间的通信，以确保它们同意变更并保持同步，即使其中少数节点处于故障状态。这使得 Redpanda 能够容忍部分环境故障，并在高负载下提供可预测的性能。</p></li><li><p>Redpanda 提供数据主权。</p></li></ul></blockquote><ol><li><h2 id="使用-Docker-Compose-快速体验"><a href="#使用-Docker-Compose-快速体验" class="headerlink" title="使用 Docker Compose 快速体验"></a>使用 Docker Compose 快速体验</h2></li></ol><blockquote><p><a href="https://docs.redpanda.com/current/get-started/quick-start/">https://docs.redpanda.com/current/get-started/quick-start/</a></p></blockquote><p>注意需要设置环境变量，或者手动把docker compose 文件修改，用指定的 console 版本或者 redpanda 版本。</p><ul><li>手动设置环境变量：</li></ul><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">export REDPANDA_VERSION&#x3D;&lt;desired_version&gt;   # 如23.3.8 export REDPANDA_CONSOLE_VERSION&#x3D;&lt;desired_version&gt;  # 如 2.6.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>或者直接指定版本 （并声明外部地址）</li></ul><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">version: &quot;3.7&quot;name: redpanda-quickstart-one-brokernetworks:  redpanda_network:    driver: bridgevolumes:  redpanda-0: nullservices:  redpanda-0:    command:      - redpanda      - start      - --kafka-addr internal:&#x2F;&#x2F;0.0.0.0:9092,external:&#x2F;&#x2F;0.0.0.0:19092      # Address the broker advertises to clients that connect to the Kafka API.      # Use the internal addresses to connect to the Redpanda brokers&#39;      # from inside the same Docker network.      # Use the external addresses to connect to the Redpanda brokers&#39;      # from outside the Docker network.      - --advertise-kafka-addr internal:&#x2F;&#x2F;redpanda-0:9092,external:&#x2F;&#x2F;10.1.0.132:19092      - --pandaproxy-addr internal:&#x2F;&#x2F;0.0.0.0:8082,external:&#x2F;&#x2F;0.0.0.0:18082      # Address the broker advertises to clients that connect to the HTTP Proxy.      - --advertise-pandaproxy-addr internal:&#x2F;&#x2F;redpanda-0:8082,external:&#x2F;&#x2F;10.1.0.132:18082      - --schema-registry-addr internal:&#x2F;&#x2F;0.0.0.0:8081,external:&#x2F;&#x2F;0.0.0.0:18081      # Redpanda brokers use the RPC API to communicate with each other internally.      - --rpc-addr redpanda-0:33145      - --advertise-rpc-addr redpanda-0:33145      # Mode dev-container uses well-known configuration properties for development in containers.      - --mode dev-container      # Tells Seastar (the framework Redpanda uses under the hood) to use 1 core on the system.      - --smp 1      - --default-log-level&#x3D;info    image: docker.redpanda.com&#x2F;redpandadata&#x2F;redpanda:v23.3.18-amd64    container_name: redpanda-0    volumes:      - redpanda-0:&#x2F;var&#x2F;lib&#x2F;redpanda&#x2F;data    networks:      - redpanda_network    ports:      - 18081:18081      - 18082:18082      - 19092:19092      - 19644:9644  console:    container_name: redpanda-console    image: docker.redpanda.com&#x2F;redpandadata&#x2F;console:v2.6.0    networks:      - redpanda_network    entrypoint: &#x2F;bin&#x2F;sh    command: -c &#39;echo &quot;$$CONSOLE_CONFIG_FILE&quot; &gt; &#x2F;tmp&#x2F;config.yml; &#x2F;app&#x2F;console&#39;    environment:      CONFIG_FILEPATH: &#x2F;tmp&#x2F;config.yml      CONSOLE_CONFIG_FILE: |        kafka:          brokers: [&quot;redpanda-0:9092&quot;]          schemaRegistry:            enabled: true            urls: [&quot;http:&#x2F;&#x2F;redpanda-0:8081&quot;]        redpanda:          adminApi:            enabled: true            urls: [&quot;http:&#x2F;&#x2F;redpanda-0:9644&quot;]    ports:      - 8080:8080    depends_on:      - redpanda-0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/1-1.png"></p><h3 id="Kafka-原生脚本测试"><a href="#Kafka-原生脚本测试" class="headerlink" title="Kafka 原生脚本测试"></a>Kafka 原生脚本测试</h3><p>使用kafka下的脚本进行测试：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash"># create topicbin&#x2F;kafka-topics.sh --create --topic wangzhichuang --bootstrap-server localhost:19092# 发送消息bin&#x2F;kafka-console-producer.sh --topic wangzhichuang --bootstrap-server localhost:19092# 消费消息bin&#x2F;kafka-console-consumer.sh --topic wangzhichuang --from-beginning --bootstrap-server localhost:19092<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意端口一般是19092。</p><p>结果如下：</p><p><img src="/images/2-1.png"></p><h3 id="Redpanda-提供的-rpk-工具"><a href="#Redpanda-提供的-rpk-工具" class="headerlink" title="Redpanda 提供的 rpk 工具"></a>Redpanda 提供的 rpk 工具</h3><ol><li>获取集群信息：</li></ol><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">docker exec -it redpanda-0 rpk cluster info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/3-2.png"></p><ol start="2"><li>创建一个名为聊天室的主题：</li></ol><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">docker exec -it redpanda-0 rpk topic create chat-room<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/4-1.png"></p><ol start="3"><li>向主题生成一条消息：</li></ol><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">docker exec -it redpanda-0 rpk topic produce chat-room<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/5-1.png"></p><ol start="4"><li>消费一条消息</li></ol><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">docker exec -it redpanda-0 rpk topic consume chat-room --num 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/6.png"></p><ol start="5"><li>测试完销毁资源</li></ol><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">docker compose down<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>手动部署单节点</li></ol><p>官方给出的链接里有在 debian 系统上直接安装的，但是好像有些镜像问题，就不随便搞了，换了一个通用的指令，自己解压。</p><blockquote><ul><li><p>自动部署：<a href="https://docs.redpanda.com/current/deploy/deployment-option/self-hosted/manual/production/production-deployment-automation/">https://docs.redpanda.com/current/deploy/deployment-option/self-hosted/manual/production/production-deployment-automation/</a> 使用 Terraform 和 Ansible 等自动化工具部署 Redpanda。</p></li><li><p>Linux上手动部署：<a href="https://docs.redpanda.com/current/deploy/deployment-option/self-hosted/manual/production/dev-deployment/">https://docs.redpanda.com/current/deploy/deployment-option/self-hosted/manual/production/dev-deployment/</a></p></li></ul></blockquote><ul><li>安装</li></ul><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">curl -1sLf &#39;https:&#x2F;&#x2F;dl.redpanda.com&#x2F;nzc4ZYQK3WRGd9sy&#x2F;redpanda&#x2F;cfg&#x2F;setup&#x2F;bash.deb.sh&#39; | \sudo -E bash &amp;&amp; sudo apt install redpanda -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>可能会遇到这种问题：</p><p><img src="/images/7.png"></p><p>这是因为镜像源的问题，我的解决方法是注释掉该kitware的源： 文件: <code>vim /etc/apt/sources.list.d/kitware.list</code></p><p>注释掉唯一的源。然后重新 apt-get update。最后重新执行上述命令。</p></blockquote><p>正常情况下会得到：</p><p><img src="/images/8.png"></p><p>同理有需要的话安装 redpanda console</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">curl -1sLf &#39;https:&#x2F;&#x2F;dl.redpanda.com&#x2F;nzc4ZYQK3WRGd9sy&#x2F;redpanda&#x2F;cfg&#x2F;setup&#x2F;bash.deb.sh&#39; | \sudo -E bash &amp;&amp; sudo apt-get install redpanda-console -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>接下来就是启动 Redpanda。</p><ol><li>首先确定配置值</li></ol><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">sudo rpk redpanda config bootstrap --self &lt;listener-address&gt; --advertised-kafka &lt;advertised-kafka-address&gt; --ips &lt;seed-server1-ip&gt;,&lt;seed-server2-ip&gt;,&lt;seed-server3-ip&gt; &amp;&amp; \sudo rpk redpanda config set redpanda.empty_seed_starts_cluster false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p><code>listener-address</code> : 你可以将其设置为0.0.0.0:9092，这表示Redpanda将监听所有可用的网络接口上的9092端口，用于接收Kafka客户端的连接。</p></li><li><p><code>advertised-kafka-address</code> : 这个地址是客户端用来连接到Redpanda的地址。在单节点配置中，这通常是该节点的外部或公网IP地址与端口的组合。假设你的服务器IP是192.168.1.100，那么你可以将其设置为192.168.1.100:9092。</p></li><li><p><code>seed-server-ips</code> : 在单节点集群中，这将是该节点自己的IP地址。使用相同的IP地址，例如192.168.1.100。</p></li></ul><blockquote><p>比如我自己的：</p><p>由于redpanda版本在23.3.8以后才能用 rpk 在后面拼接监听器地址，所以我这里之后要手动修改配置文件：<code>/etc/redpanda/redpanda.yaml</code></p><p>如下部分改为</p><p>暂时无法在飞书文档外展示此内容</p><p><img src="/images/9.png"></p></blockquote><p>随后启动：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">sudo rpk redpanda config bootstrap --self 10.1.0.132 --ips 10.1.0.132 &amp;&amp; sudo rpk redpanda config set redpanda.empty_seed_starts_cluster falsesudo rpk redpanda config set redpanda.empty_seed_starts_cluster false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="启动-Redpanda"><a href="#启动-Redpanda" class="headerlink" title="启动 Redpanda"></a>启动 Redpanda</h2><ol><li>系统服务启动</li></ol><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">sudo systemctl start redpanda-tuner redpanda<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>启动成功后可以通过 status 命令查看服务状态如下：</li></ol><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">sudo systemctl status redpanda<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>Redpanda-tuner 是Redpanda提供的一个工具，它的主要目的是自动调整Linux系统的配置，以确保Redpanda能够以最佳性能运行。这个工具专门针对Redpanda的运行环境进行优化，包括内核参数、磁盘设置、网络设置等方面的调整。</p><p>因此不会被启动为持久的可用服务，不需要查看状态。</p></blockquote><p><img src="/images/10.png"></p><blockquote><p>如果出现启动过程中卡住的情况，并且查看状态时提示错误，可以着重检查配置文件，即<code>/etc/redpanda/redpanda.yaml</code>文件，注意地址要填成你的服务器ip地址。</p></blockquote><ol start="3"><li>使用 rpk 工具查看集群状态</li></ol><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">rpk cluster info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/11.png"></p><ul><li>尝试创建 topic</li></ul><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">rpk topic create &lt;topic-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/12.png"></p><p>其他命令和 docker-compose 部署后使用相同，请参考之前的内容。</p><ol start="3"><li>部署集群</li></ol><p>其实和上述类似，只是配置文件需要指定多台机器。</p><p>主要是修改配置文件<code>/etc/redpanda/redpanda.yaml</code>：</p><pre class="line-numbers language-YAML" data-language="YAML"><code class="language-YAML">redpanda:    data_directory: &#x2F;var&#x2F;lib&#x2F;redpanda&#x2F;data    empty_seed_starts_cluster: false    seed_servers:        - host:            address: &lt;seed-server1-ip&gt;            port: 33145        - host:            address: &lt;seed-server2-ip&gt;            port: 33145        - host:            address: &lt;seed-server3-ip&gt;            port: 33145    rpc_server:        address: &lt;listener-address&gt;        port: 33145    kafka_api:        - address: &lt;listener-address&gt;          port: 9092    admin:        - address: &lt;listener-address&gt;          port: 9644    advertised_rpc_api:        address: &lt;listener-address&gt;        port: 33145    advertised_kafka_api:        - address: &lt;advertised-kafka-address&gt;          port: 9092<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此 redpanda 的部署已经完成！</p><p>下面开始集成到 KPC 项目。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redpanda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目优化--冷热数据分离</title>
      <link href="/2024/04/16/xiang-mu-you-hua-leng-re-shu-ju-fen-chi/"/>
      <url>/2024/04/16/xiang-mu-you-hua-leng-re-shu-ju-fen-chi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不一定做，毕竟比较复杂，暂时想点方案。</p></blockquote><h2 id="为什么要做"><a href="#为什么要做" class="headerlink" title="为什么要做"></a>为什么要做</h2><blockquote><p>其实做冷热分离是为了<u>提高性能，降低存储成本</u>的一种存储数据的策略。</p></blockquote><p>单日访问统计表，也就是 <code>t_stats_today</code>  表，没必要做分表，因为这个场景是用户想查询某一天该数据的访问记录或者该分组下所有数据的访问记录，这个实际上用到的可能性很小（因为我们默认的查询区间是最近一个星期的访问记录，对于之前的某一天的访问记录，一般用不到）。</p><p>那我们可以做个优化，也就是<mark style="background: #FFFF00;">冷热数据分离</mark>，把最近一段时间的单日访问记录存到数据表中，但是更早的数据可以通过备份表（用一个 back 标识为单日访问记录的备份表）存储到适合大容量存储的数据库但是查询效率相比于热库较低，比如 Postgresql 等。如果用户真要访问这种冷门的数据再从冷库中查询。</p><p>同时也是为了适应取消 gid 之后，减少查询当日访问统计记录的关联查询次数。那这样我们那个绑定表导致的笛卡尔积问题就不用考虑了。<a href="../%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/4%20%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98--%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9B%B8%E5%90%8C%E5%88%86%E7%89%87%E9%94%AE%E4%BD%BF%E7%94%A8left%20join%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF.md">4 项目问题–分库分表相同分片键使用left join会出现笛卡尔积</a> </p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="怎么实施冷热数据分离"><a href="#怎么实施冷热数据分离" class="headerlink" title="怎么实施冷热数据分离"></a>怎么实施冷热数据分离</h3><blockquote><p>可以看字节的方案：字节跳动技术团队-冷热数据分分离方案: <a href="https://mp.weixin.qq.com/s/ZKRkZP6rLHuTE1wvnqmAPQ">https://mp.weixin.qq.com/s/ZKRkZP6rLHuTE1wvnqmAPQ</a> </p></blockquote><p>实习的时候就有这种场景，把大量的推荐以及推送日志冷热分离，减少对线上数据库的存储压力。（具体还在研究如何实现）</p><ul><li><input disabled="" type="checkbox"> #task 如何实施冷热分离？ 🔽</li></ul><p>应该要结合项目考虑。</p><h3 id="冷热分离有什么问题"><a href="#冷热分离有什么问题" class="headerlink" title="冷热分离有什么问题"></a>冷热分离有什么问题</h3><ol><li>首先你的代码复杂度会提高很多，你划分冷热数据，在比较复杂的场景下很难实行。如果<strong>划分不够好，导致频繁的访问冷库数据</strong>，性能会降低很多。</li><li>还有问题就是<strong>冷热数据的同步</strong>，以及<strong>数据一致性问题</strong>，你打算什么时候进行热库同步数据到冷库呢。</li><li><strong>高可用性</strong>，对于不同的数据库，你维护的方式也不同，不管是冷库还是热库挂掉或者性能下降都会导致系统问题。</li></ol><p>… 大概想到这么点，可能会再补充吧。</p><h3 id="怎么定义冷数据和热数据的"><a href="#怎么定义冷数据和热数据的" class="headerlink" title="怎么定义冷数据和热数据的"></a>怎么定义冷数据和热数据的</h3><p>冷数据一般就是线上环境中<strong>对于一些实时性要求较低的功能</strong>，比如支付，你不可能交给冷库来做，因为性能不够高，而且它的数据是由热库按照一定规则同步过来的，可能会有一些延迟。</p><blockquote><p>冷数据是不经常访问的数据。它可以<u>存储在更便宜、更慢速的存储介质</u>上，如高容量硬盘驱动器或者云存储服务的冷数据层。</p></blockquote><p>热数据相反，<strong>就是对于实时性以及计算要求高的需求</strong>，需要用热库快速查询和返回数据，并且保证数据的准确性。</p><blockquote><p>gpt 参考：- <strong>热数据</strong>：指的是<mark style="background: #FFFF00;">经常被访问和修改的数据</mark>。这类数据应该<u>存储在快速、低延迟的存储系统</u>上，以便快速访问。例如，活跃的数据库记录或者需要实时处理的数据。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 冷热数据分离 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冷热分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ThreadLocal管理资源出现内存泄漏问题的补充</title>
      <link href="/2024/04/10/guan-yu-threadlocal-guan-li-zi-yuan-chu-xian-nei-cun-xie-lou-wen-ti-de-bu-chong/"/>
      <url>/2024/04/10/guan-yu-threadlocal-guan-li-zi-yuan-chu-xian-nei-cun-xie-lou-wen-ti-de-bu-chong/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前没想过这个问题，这里带着一些小疑问整理一下。</p></blockquote><h3 id="ThreadLocal-内存泄漏问题"><a href="#ThreadLocal-内存泄漏问题" class="headerlink" title="ThreadLocal 内存泄漏问题"></a>ThreadLocal 内存泄漏问题</h3><blockquote><p>Tip：2024-04-10</p></blockquote><p><mark style="background: #FFFF00;">为什么会发生内存泄漏问题</mark>？</p><p>首先我们都知道 ThreadLocal 是通过把自身对象作为 key，要管理的资源作为 value 在线程内部 map 对象中进行存储的。</p><p>而这个 <strong>key 是弱引用，vlaue 是强引用</strong>。既然是弱引用，如果这个 ThreadLocal 对象没有被其他程序引用，那可能就会被 JVM 垃圾回收掉，那会出现什么情况？<strong>空 key</strong>！那 <strong>value 永远无法被访问到，而且也不会被清理掉，这就是内存泄漏问题</strong>。</p><p>避免方法：<u>尽量在使用完后，调用 remove 方法</u>，<u>手动删掉资源对象，避免出现内存泄漏问题</u>。</p><p>而且 threadlocal 在设计的时候也会在调用 get，set，remove 方法时判断 key 是否为 null 了，如果为 null 直接就清理掉这个键值对。</p><blockquote><p>小问题：Threadlocal 对象为什么是弱引用？咋判断的？</p><ul><li><mark style="background: #FFFF00;">设计为弱引用是为了避免内存泄漏</mark>!!?？</li></ul><p>原因在于，如果是强引用的 key，说明这个 threadlocalmap 只要用到了这个 ThreadLocal 对象作为 key，那就是强引用。这有啥问题？<u>只要线程一直活跃，那 Threadlocalmap 中就一直保留着 Threadlocal 的对象，哪怕没有被用到，也不会被回收（强引用）</u>，那不就是内存泄漏问题吗？</p><p>所以设计为弱引用，只要我们注意 remove 掉不用的资源，加上 Threadlocal 自己的优化，能尽可能的避免内存泄漏问题。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳表skipList解析</title>
      <link href="/2024/02/28/tiao-biao-skiplist-jie-xi/"/>
      <url>/2024/02/28/tiao-biao-skiplist-jie-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>面试的时候问了这些。所以要弄清楚具体的查询过程，以及跳表的结构，还有实现利用 ZSET 实现<strong>排行榜是怎么从跳表上获取元素的</strong>。怎么获取某个数据的名次。</p><p>老规矩，先来一个对整体的大概了解。</p><blockquote><ol><li>跳表的结构，多层链表，链表节点中有多个指针（从而形成多层链表）</li><li>跳表进行范围查询，不是以两端点为准查到底层后，返回两端点之间的值。而是通过从顶层查询范围查询中的 start 开始，大于等于 start 的第一个元素，找到之后直接往下层走，继续找第一个大于等于 start 的元素，最后到达底层，就在底层链表上，往右遍历，直到遇到第一个大于 end 的元素为止结束查询。</li><li>跳表进行单点查询（也就是查询某个元素的具体权重），是通过哈希表实现的，跳表的多层结构只负责查询节点值，而不负责权重的存储。这样一想确实是，哈希表存储这种键值对不是更好嘛，查询效率是 O（1）。比如 LRU 算法，不也是用哈希表来存储缓存值，并通过双向链表表示元素的使用情况嘛，最新插入的元素在头部或者尾部，具体实现决定。</li></ol></blockquote><p>总之呢，就是范围查询是由跳表实现的，单点查询由哈希表实现。而这两种操作对应了 ZSET 的命令：<code>ZRANGEBYSCORE</code> 返回权重范围内的元素。<code>ZSCORE</code>获取某个元素的权重值。</p><h2 id="2-跳表结构"><a href="#2-跳表结构" class="headerlink" title="2. 跳表结构"></a>2. 跳表结构</h2><p>那现在就开始具体源码分析吧，基本查询过程就上面分析的那样。这里就重在理解其本质。</p><h3 id="2-1-ZSET-的结构体"><a href="#2-1-ZSET-的结构体" class="headerlink" title="2.1. ZSET 的结构体"></a>2.1. ZSET 的结构体</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct zset &#123;    dict *dict;    zskiplist *zsl;&#125; zset;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里要知道，所有的数据结构其底层都是通过 RedisObject 把所有这些数据结构封装了（比如 zset, sds, listpack 等），然后类似哈希表那种，在桶数组上某些节点用指针指向具体的数据结构实体。从而保证 Redis 能存储各式各样的数据。</p></blockquote><p>可以看出嘛，是由字典 dict 以及跳表实现。具体字典实现参考：<a href="Redis--%E6%B0%B8%E4%B9%85%E7%AC%94%E8%AE%B0--dict%E5%AD%97%E5%85%B8%E7%BB%93%E6%9E%84.md">Redis–永久笔记–dict字典结构</a> ，而跳表就仔细讲讲。</p><h3 id="2-2-跳表的节点"><a href="#2-2-跳表的节点" class="headerlink" title="2.2. 跳表的节点"></a>2.2. 跳表的节点</h3><p>比如下面的跳表结构：<br><img src="/images/%E8%B7%B3%E8%A1%A8skipList.png"></p><p>可以看到，在 level 0 上一共有 7 个结点，分别是 3、11、23、33、42、51、62，这些结点会通过指针连接起来，同时头结点中的 level0 指针会指向结点 3。然后，在这 7 个结点中，结点 11、33 和 51 又都包含了一个指针，同样也依次连接起来，且头结点的 level 1 指针会指向结点 11。这样一来，这 3 个结点就组成了 level 1 上的所有结点。</p><p>最后，结点 33 中还包含了一个指针，这个指针会指向尾结点，同时，头结点的 level 2 指针会指向结点 33，这就形成了 level 2，只不过 level 2 上只有 1 个结点。</p><blockquote><p>这时候就想到了，这具体是咋划分的呢，也就是非底层节点到底选哪些下一层的节点作为这一层的节点，选多少个节点呢？</p><p>这个在后面再说。[[Redis–永久笔记–跳表skipList数据结构#3. 跳表的其他参数]] </p></blockquote><hr><p>看一下跳表节点的结构体源码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct zskiplistNode &#123;    sds ele;   &#x2F;&#x2F;Sorted Set中的元素    double score;  &#x2F;&#x2F;元素权重值    struct zskiplistNode *backward;    &#x2F;&#x2F;后向指针        &#x2F;&#x2F;节点的level数组，保存每层上的前向指针和跨度    struct zskiplistLevel &#123;        struct zskiplistNode *forward;        unsigned long span;    &#125; level[];        &#x2F;&#x2F; 就是多层链表中每一层的各节点的前指针以及跨越的节点个数&#125; zskiplistNode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>ele</code> 是 <strong>SDS 类型</strong>的，也就是存储加入到 zset 的元素值，而 <code>score</code> 是该值的权重，用来作为排序的依据。</li><li><code>backward </code> 好奇怪，你<strong>指向前一个节点</strong>，为什么要命名成这样 ,back? 其实好像也可以理解，因为这个指针是为了方便从链表的尾部往前进行遍历，所以从后开始就是 back 喽。</li><li>其实是可以看到里面那个多层链表结构体 <code>zskiplistLevel</code> 是一个数组，也就是说明每个节点都有“向上延申的可能”。并且还有跨度表明当前层每隔几个节点就连接一次，以及 forward 指针指向每个跨度下的节点。连接成一个新的链表。</li></ul><h3 id="2-3-跳表是怎么获取元素对应的在整个跳表中的顺序的"><a href="#2-3-跳表是怎么获取元素对应的在整个跳表中的顺序的" class="headerlink" title="2.3. 跳表是怎么获取元素对应的在整个跳表中的顺序的"></a>2.3. 跳表是怎么获取元素对应的在整个跳表中的顺序的</h3><ul><li>如果没懂的话，可以这样理解，根据跳表假如<strong>想获取某个元素的权重在整个 ZSET 中的元素顺序</strong>（正序或逆序），你遍历之后，不是要到达底部嘛拿元素嘛，但是你遍历到这个元素之后，发现这个顺序你并不知道是在哪（根据权重排序后，元素的顺序），所以你<u>需要往前遍历找到当前层（level 0）的头节点，来判断自己在哪个位置</u>。这样的话，你这个效率就是 <code>O(n)</code> 了，很慢啊。</li></ul><p>跳表咋解决呢？</p><ul><li>Redis 这个跳表的实现就很巧妙，它是在查询过程中，每个 node 节点里面不是有跨度嘛，就是那个 span，只要进行<mark style="background: #FFFF00;">累加</mark>，这样到达底部的时候，就能得到该节点元素在跳表元素中的全局位置。而那个 forward 指针正好起到一个规范查询过程的一个作用。</li></ul><p>还是不懂，我把图标一下。<br><img src="/images/%E8%B7%B3%E8%A1%A8%E6%9F%A5%E8%AF%A2%E9%A1%BA%E5%BA%8F.png"></p><p>比如这个 23，跨度和就是 2+1&#x3D;3，即 level 1 中 11 节点的跨度+level 0 的23 节点跨度。</p><p>这个是用来进行 Zset 特有的排序 RANK 功能。比如命令：<strong>Zrank 正序</strong> 和 <strong>ZREVrank</strong> 反序。</p><p>获得范围查询元素的顺序也很方便，就是找到初始节点 start 所在的位置，因为也进行了累加，所以它的顺序就是确定的，所以呢其他元素只要也依次累加 span 即可（最底层 span 为 1 嘛）就可以得到元素所在的全局顺序。</p><h3 id="2-4-跳表本身的结构体定义"><a href="#2-4-跳表本身的结构体定义" class="headerlink" title="2.4. 跳表本身的结构体定义"></a>2.4. 跳表本身的结构体定义</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct zskiplist &#123;    struct zskiplistNode *header, *tail;    unsigned long length;    int level;&#125; zskiplist;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到有一个头节点，尾节点，说明我们可以从前往后，也可以从后往前遍历这整个跳表，而且刚才也讲了跳表的节点都有指向前者的指针以及后者的指针。</p><blockquote><p>然后呢，这个就是 ZSET 中的一部分，跳表。</p></blockquote><h2 id="3-跳表的其他参数"><a href="#3-跳表的其他参数" class="headerlink" title="3. 跳表的其他参数"></a>3. 跳表的其他参数</h2><p>怎么设置的层数？每层节点个数怎么确定。跳表查询效率怎么样？</p><p><a href="https://zhuanlan.zhihu.com/p/306183653">Redis源码剖析之跳表(skiplist) - 知乎 (zhihu.com)</a>  </p><ol><li>首先看<strong>查询效率</strong></li></ol><p>假如我们要查询元素 13，那么流程大概是这样，也就是发现本层下一个节点值大于目标节点值就从现在的位置下去，继续往后找。<br><img src="/images/%E8%B7%B3%E8%A1%A8%E6%9F%A5%E8%AF%A2.png"></p><p>此时的节点设置的是上一层是下一层的节点的二倍，这样查询的过程相当于二分查找，比如有序数组上的二分，每次找到中间元素进行判断，这个跳表相当于把所有的中间值拿出来到各层链表上，我们每次直接从上层判断中间值，遇到就下去到达底层拿到目标数据。也就提高了单链表 <code> O(n）</code> 的查询效率，变成了 <code>O (logn)</code>。</p><p>而且<u>层数越多，查询的效率越快，但是消耗空间就越多</u>。</p><ol start="2"><li><strong>上层节点的值不固定，由随机算法决定</strong>。</li></ol><p>如上图这种每两个节点之间拿出节点到上层，保证 2：1 的节点比，在进行元素的删除和插入时，你就需要重新调整各层链表的指针，比如上面个节点有多层，这个元素删掉后需要修改大量指针进行重构，以保证有序以及比例关系。所以是很不方便的。</p><p>Redis 的跳表采用的是<strong>zslRandomLevel 函数</strong> 随机决定每个节点的层数。（也就是给每个节点初始化为可能是多级结构，也可能只是底层节点）。</p><blockquote><p>具体是函数内部会生成一个随机数，这个随机数如果小于规定的概率值（大概 1&#x2F;4 概率抽到），这个节点层数就增加一层。所以每个节点增加层数的概率大概为 1&#x2F;4，当插入和删除节点的时候，只要修改待修改的节点的指针即可。</p></blockquote><p><mark style="background: #FFFF00;">可能不太理解，为什么这样就能减少插入和删除时的调整开销了呢</mark>？</p><ul><li>因为上面如果需要保证严格的 2：1 或者其他比例关系，你插入和删除节点就需要保证大部分的节点都需要进行调整以保证比例关系。所以开销大。</li><li>通过随机生成函数，每个节点的层数不定，但是又使全局保证了一种平衡（因为有概率嘛），当插入节点和删除节点的时候，只需要在目标值相邻的节点之间建立指针关联即可。不需要调整其他节点的指针，也就提高了效率。</li></ul><h2 id="4-跳表和哈希表联用"><a href="#4-跳表和哈希表联用" class="headerlink" title="4. 跳表和哈希表联用"></a>4. 跳表和哈希表联用</h2><p>我们上面其实已经知道了，哈希表是用来快速判断整个 ZSET 中是否存在响应的值，并且可以以 <code>O（1）</code> 时间复杂度拿到目标值对应的权重（ZSCORE 命令）。</p><p>然后呢跳表是用来快速定位根据权重排序的元素顺序（累加跨度 span）已经快速查询目标权重范围内的元素（查询到底层进行再遍历）。</p><blockquote><p>这两个算是两个索引，所以需要在插入的时候对两个索引都要进行维护（插入）。</p></blockquote><p><mark style="background: #FFFF00;">插入元素过程</mark>：</p><p>在调用插入元素的函数 ZsetAdd 时，会先通过 dictFind 函数里判断是否存在这个元素是，如果不存在，则分别进行跳表或者压缩列表以及哈希表元素的插入。如果存在，则判断是否需要更新权重，如果需要更新，则会调用 zslUpdateScore 函数进行跳表节点中对应节点的权重值更新，<strong>然后把哈希表的权重指针指向跳表中该节点的权重值</strong>。（这样就能保证哈希表指向的就是最新的权重值）</p><p>zadd 函数具体内容：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"> &#x2F;&#x2F;如果采用ziplist编码方式时，zsetAdd函数的处理逻辑 if (zobj-&gt;encoding &#x3D;&#x3D; OBJ_ENCODING_ZIPLIST) &#123;   ...&#125;&#x2F;&#x2F;如果采用skiplist编码方式时，zsetAdd函数的处理逻辑else if (zobj-&gt;encoding &#x3D;&#x3D; OBJ_ENCODING_SKIPLIST) &#123;        zset *zs &#x3D; zobj-&gt;ptr;        zskiplistNode *znode;        dictEntry *de;        &#x2F;&#x2F;从哈希表中查询新增元素        de &#x3D; dictFind(zs-&gt;dict,ele);        &#x2F;&#x2F;如果能查询到该元素        if (de !&#x3D; NULL) &#123;            &#x2F;* NX? Return, same element already exists. *&#x2F;            if (nx) &#123;                *flags |&#x3D; ZADD_NOP;                return 1;            &#125;            &#x2F;&#x2F;从哈希表中查询元素的权重            curscore &#x3D; *(double*)dictGetVal(de);            &#x2F;&#x2F;如果要更新元素权重值            if (incr) &#123;                &#x2F;&#x2F;更新权重值               ...            &#125;            &#x2F;&#x2F;如果权重发生变化了            if (score !&#x3D; curscore) &#123;                &#x2F;&#x2F;更新跳表结点                znode &#x3D; zslUpdateScore(zs-&gt;zsl,curscore,ele,score);                &#x2F;&#x2F;让哈希表元素的值指向跳表结点的权重                dictGetVal(de) &#x3D; &amp;znode-&gt;score;                 ...            &#125;            return 1;        &#125;       &#x2F;&#x2F;如果新元素不存在        else if (!xx) &#123;            ele &#x3D; sdsdup(ele);            &#x2F;&#x2F;新插入跳表结点            znode &#x3D; zslInsert(zs-&gt;zsl,score,ele);            &#x2F;&#x2F;新插入哈希表元素            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) &#x3D;&#x3D; DICT_OK);            ...            return 1;        &#125;         ..<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><input checked="" disabled="" type="checkbox"> #task 跳表 skipList 数据结构 ✅ 2024-02-29</li></ul><h2 id="5-为什么用跳表，不用红黑树？"><a href="#5-为什么用跳表，不用红黑树？" class="headerlink" title="5. 为什么用跳表，不用红黑树？"></a>5. 为什么用跳表，不用红黑树？</h2><ul><li><strong>内存占用更少</strong>。平衡树每个节点包含 2 个指针，redis 中平均指针 1.33 个。</li><li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。跳表只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li><li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。因为红黑树涉及各种旋转保持平衡的操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis/ziplist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如果不用Cookie怎么统计uv呢</title>
      <link href="/2024/02/24/ru-guo-bu-yong-cookie-zen-me-tong-ji-uv-ni/"/>
      <url>/2024/02/24/ru-guo-bu-yong-cookie-zen-me-tong-ji-uv-ni/</url>
      
        <content type="html"><![CDATA[<p>如题，面试的时候问了这个问题，我当时没想好解决方案，事后就思考了一下。</p><blockquote><p><em>怎么不用 Cookie 来统计 uv</em>. 就在这猜测一下吧，思考过程：</p><ul><li>如果不用 cookie，那就说明用 session 也不行，因为 session 也是需要依赖 Cookie 来保存这个 session ID 嘛。</li><li>然后如果是缓存的话，还能想到<strong>浏览器的 Local Storage 存这个 uv 字段</strong>，但是呢，这样不能绝对的保证这个用户一定是新用户，因为 Local Storage 虽然不容易被删，<strong>但是也能够删掉</strong>。</li><li>想了一下，比如 b 站，哪怕我换个浏览器，登录 b 站账号之后，本应该是没有缓存嘛，但是它确实是能推送你喜欢的视频，所以嘛，我觉得它这个统计是在用户登录上面做了手脚，比如给用户信息加一些字段，来表示这个用户是新用户还是老用户。</li><li>但是呢<u>又想到这个短链接跳转它并不是只给登录用户使用，未登录也可以通过它跳转</u>。那怎么来判断是否为新还是老用户呢？</li></ul><p>然后呢我就查资料啊，问 GPT，都没有绝对的保证判断用户的新老。也就不了了之了。还是那句话，我觉得删完 Cookie，确实算为一个新用户没啥问题，<mark style="background: #FFFF00;">毕竟操作者就是用户</mark>，誰会想到闲着没事删删 Cookie 呢，笑了。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一批大量的 redis 请求都过来, 怎么优化（批处理优化问题）</title>
      <link href="/2024/02/24/yi-pi-da-liang-de-redis-qing-qiu-du-guo-lai-zen-me-you-hua-pi-chu-li-you-hua-wen-ti/"/>
      <url>/2024/02/24/yi-pi-da-liang-de-redis-qing-qiu-du-guo-lai-zen-me-you-hua-pi-chu-li-you-hua-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>面试问到一千条 redis 命令来到，怎么进行优化，来减少处理时间。</p><p>之前没了解过，然后想的一些方案并不是这么有效，所以下来自己总结一下。</p><h1 id="单机模式下"><a href="#单机模式下" class="headerlink" title="单机模式下"></a>单机模式下</h1><blockquote><p>暂时先讲单机模式下的批处理优化。</p></blockquote><h2 id="通信携带命令条数不同导致效率不同"><a href="#通信携带命令条数不同导致效率不同" class="headerlink" title="通信携带命令条数不同导致效率不同"></a>通信携带命令条数不同导致效率不同</h2><ol><li>如果一次客户端到 redis 服务端的通信中只携带一条 redis 指令，那大概的总耗时就是：1 个来回时间 + 1 个 redis 处理命令时间。N 次就是 N 个来回时间 + N 条命令处理时间。</li></ol><p>画个图吧：<br><img src="/images/n%E6%AC%A1%E9%80%9A%E4%BF%A1.png"></p><ol start="2"><li>一次通信携带多条指令，减少总的通信次数。</li></ol><p>这样的 N 条命令的总耗时就为：N&#x2F;M 个来回时间，N 个处理时间。（M 代指每次携带的命令条数）。</p><p>图就不画了，应该能想象出来，不是重点。</p><ol start="3"><li>总之：<mark style="background: #FFFF00;">通信时间在 Redis 的使用过程中占大头，所以减少通信次数就是批处理优化的一个主要攻克点</mark>。</li></ol><h2 id="Redis-中怎么操作"><a href="#Redis-中怎么操作" class="headerlink" title="Redis 中怎么操作"></a>Redis 中怎么操作</h2><blockquote><p>我当时想到了列表 List 数据类型，但是列表好像并不算是一个批处理命令，然后就扯其他的了。</p></blockquote><p>现在才醒悟，对啊，<code>mset </code> 和 <code>hmset</code>。就是专门用来做批处理的命令，怎么没想到类比 Mysql 分批插入大量数据呢。也就是一次把多个 redis 命令封装在一起作为一次通信发给 Redis 客户端。</p><p><strong>语法</strong> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">mset key1 value1 [ key2 value2]hmset key field1 value1 [field2 value2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>代码示例</strong> </p><p>如上，可以通过数组传递需要设置的批量 redis 命令，设置 String 类型的。并且 key 可以不变。而对于 hash 数据类型，其批量插入只能指定一个键。Set 类型的批量插入命令（SADD）也是有局限的（只能指定一个 set 的键）。</p><p>MSET 命令，数组批量插入示例：<br><img src="/images/hset%E5%91%BD%E4%BB%A4.png" alt="|500"></p><h2 id="PipeLine-优化批处理执行"><a href="#PipeLine-优化批处理执行" class="headerlink" title="PipeLine 优化批处理执行"></a>PipeLine 优化批处理执行</h2><p>PipeLine 不管是 Jedis 还是 Redis 都提供的有，这个<u>主要是用来把各种不同的 Redis 命令都装在一起</u>，然后统一发送到 Redis 服务端。</p><p><u>与批处理命令不同的是，这个可以装”不同的命令”，也就是说可以解决 HMSET 和 SADD 中批量插入时只能指定一个 Key 的问题</u>。你只要把多个 SADD 命令和 HMSET 命令装进来就行了。</p><p>示例：</p><ol><li>模拟 MSET<br><img src="/images/Pipeline%E6%A8%A1%E6%8B%9Fmset.png"></li></ol><p>PipeLine 的 <code>sync()</code> 命令就是发起一次通信请求到 Redis 服务端。</p><p>但是命令到达之后可能就会进入队列中等待，执行的顺序是有先后的，所以呢速度可能会比 mset 慢一些，但是好在对更多的数据类型都支持。</p><h1 id="集群模式下"><a href="#集群模式下" class="headerlink" title="集群模式下"></a>集群模式下</h1><p>在集群模式下，如果批处理命令没有分配到同一个槽位（也就是同一个 Redis 节点），就会导致执行失败。所以在集群部署下做批处理就需要其他工具了。</p><p>TODO</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis/批处理优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联合索引进行的范围查询为什么会导致索引失效</title>
      <link href="/2024/02/24/lian-he-suo-yin-jin-xing-de-fan-wei-cha-xun-wei-shi-me-hui-dao-zhi-suo-yin-shi-xiao/"/>
      <url>/2024/02/24/lian-he-suo-yin-jin-xing-de-fan-wei-cha-xun-wei-shi-me-hui-dao-zhi-suo-yin-shi-xiao/</url>
      
        <content type="html"><![CDATA[<p>也是面试问的，由于不够深入底层存储结构，导致对索引的理解不够深刻。加入了 TODO，准备好好的解析底层结构。</p><p>自己想的范围查询过程貌似差不多对了。但是没说清楚索引失效原因，补充一下。</p><h2 id="到底为什么失效呢"><a href="#到底为什么失效呢" class="headerlink" title="到底为什么失效呢"></a>到底为什么失效呢</h2><p>比如有三个字段，A&#x3D;, B&gt;, C&#x3D;. 最后只会走两个索引 A 和 B 的，并不能找到唯一的记录。</p><p>看来面试的时候猜到了一点。就是三个字段先从 A 字段开始匹配，找到某个节点对应的记录后，下到第二层对应的 A 字段相等的节点上，然后 B 字段就从 B 字段这个层往后查询，因为是范围查询吗，没有机会往下走去找 C 字段（不是精确值，下不去）。所以最后能查询的数据不是唯一的，而是很多数据，这时候索引就走不全了。（B+树联合索引的存储结构得看看，还有记录在节点中的存储情况）</p><p>然后呢，由于没有查到需要的 C 字段，所以会<u>进行回表查询</u>，而且是大量的回表查询，那这时候 Mysql 不是在执行 SQL 的时候有一个优化器吗，它<mark style="background: #FFFF00;">发现走索引然后进行回表的开销，比全表扫描更大</mark>。所以它就不走索引，而是通过全表扫描来进行查询。也就是说联合索引失效了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列怎么保证消息不丢失的</title>
      <link href="/2024/02/18/xiao-xi-dui-lie-zen-me-bao-zheng-xiao-xi-bu-diu-shi-de/"/>
      <url>/2024/02/18/xiao-xi-dui-lie-zen-me-bao-zheng-xiao-xi-bu-diu-shi-de/</url>
      
        <content type="html"><![CDATA[<ul><li><input checked="" disabled="" type="checkbox"> #task 消息队列怎么保证消息不丢失的 ✅ 2024-02-18</li></ul><h2 id="为什么会发生消息丢失"><a href="#为什么会发生消息丢失" class="headerlink" title="为什么会发生消息丢失"></a>为什么会发生消息丢失</h2><p>可能因为网络问题导致消息丢失，以及存储时消息队列宕机了等情况。具体发生位置如下。</p><p>还是画个简单的流程图吧，比较清晰：<br><img src="/images/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B.png"></p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>可以从生产者、消息队列本身、消费者解决。</p><h3 id="生产者保证消息不丢失"><a href="#生产者保证消息不丢失" class="headerlink" title="生产者保证消息不丢失"></a>生产者保证消息不丢失</h3><ol><li>事务管理：当发送一条消息后，开启事务，等待消息队列传送回消息处理成功之后才继续发送消息。</li><li>生产者确认机制：开启生产者确认机制，只要消息成功发送到交换机之后 RabbitMQ 就会发送一个 ack 给生产者（即使消息没有 Queue 接收，也会发送 ack）。如果消息没有成功发送到交换机，就会发送一条 nack 消息，提示发送失败。</li></ol><p>当服务端确定一条或多条消息后就会调用生产者提供的回调方法来提醒生产者自己是否成功接收到了消息并处理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 消息是否成功发送到Exchangefinal RabbitTemplate.ConfirmCallback confirmCallback &#x3D; (CorrelationDatacorrelationData, boolean ack, String cause) -&gt; &#123;log.info(&quot;correlationData: &quot; + correlationData);log.info(&quot;ack: &quot; + ack);if(!ack) &#123;log.info(&quot;异常处理....&quot;);&#125;&#125;;rabbitTemplate.setConfirmCallback(confirmCallback)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="路由交换机-Exchange-保证消息不丢失"><a href="#路由交换机-Exchange-保证消息不丢失" class="headerlink" title="路由交换机 Exchange 保证消息不丢失"></a>路由交换机 Exchange 保证消息不丢失</h3><p>生产者只会保证消息到达路由不会丢失，而不能保证从交换机到达某个消息队列，然后从消息队列到达消费者不丢失消息。</p><p><strong>解决方法</strong>：</p><p>开启 <code>Return 消息机制</code>。当从交换机到消息队列 queue 时，如果失败则会调用 return 方法，告诉生产者消息发送失败。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">final RabbitTemplate.ReturnCallback returnCallback &#x3D; (Message message, int replyCode, String replyText, String exchange, String routingKey) -&gt;log.info(&quot;return exchange: &quot; + exchange + &quot;, routingKey: &quot;+ routingKey + &quot;, replyCode: &quot; + replyCode + &quot;, replyText: &quot;+ replyText);rabbitTemplate.setReturnCallback(returnCallback);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="消费者消费失败导致消息丢失的问题"><a href="#消费者消费失败导致消息丢失的问题" class="headerlink" title="消费者消费失败导致消息丢失的问题"></a>消费者消费失败导致消息丢失的问题</h3><p>因为<strong>消费者默认采用自动 ack</strong>，所以当消费者收到消息后，还没有执行完，MQ 宕机了，但是由于是自动 ack，所以消费者收到消息后，直接就返回 ack，消息队列收到后就把这条消息从消息队列中删除了。</p><p>最终消息没有消费成功，但是却返回了 ack，并导致消息丢失。</p><p><strong>解决方法</strong>：</p><p>开启手动发送 ack。</p><p>配置：<code>spring.rabbitmq.listener.simple.acknowledge-mode=manual</code>  </p><p>样例：总之就是执行完自己的处理逻辑再返回 ack。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RabbitListener(queues &#x3D; RabbitMqConfig.MAIL_QUEUE)public void onMessage(Message message, Channel channel) throws IOException &#123;try &#123;Thread.sleep(5000);&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;long deliveryTag &#x3D; message.getMessageProperties().getDeliveryTag();&#x2F;&#x2F;总之就是执行完自己的处理逻辑再返回ack。channel.basicAck(deliveryTag, true);System.out.println(&quot;mail listener receive: &quot; + newString(message.getBody()));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="开启消息队列持久化"><a href="#开启消息队列持久化" class="headerlink" title="开启消息队列持久化"></a>开启消息队列持久化</h3><p>如果不开启持久化，RabbitMQ 异常重启的时候，就会导致消息丢失，因为不能从其他地方恢复数据。</p><p><strong>开启消息队列持久化后，就可以以一定的规则把消息队列的数据同步到磁盘上或者远程服务器上，以保证消息持久化</strong>。</p><blockquote><ul><li><p>具体就是，生产者每发送一条消息到交换机以及消息队列，他们就会把消息存储到各自的持久化日志中。接下来，每当一个消息消息消费成功返回 ack 的时候，就从持久化中删除这个消息。</p></li><li><p>一旦服务宕机，就可以从持久化日志中进行恢复未完成的消息。</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要引入消息队列之异步削峰解耦</title>
      <link href="/2024/02/17/wei-shi-me-yao-yin-ru-xiao-xi-dui-lie-zhi-yi-bu-xue-feng-jie-ou/"/>
      <url>/2024/02/17/wei-shi-me-yao-yin-ru-xiao-xi-dui-lie-zhi-yi-bu-xue-feng-jie-ou/</url>
      
        <content type="html"><![CDATA[<p>消息队列其实就是用一个队列存储消息，我们可以从中获取消息并处理。</p><h2 id="1-消息队列的三大用处"><a href="#1-消息队列的三大用处" class="headerlink" title="1. 消息队列的三大用处"></a>1. 消息队列的三大用处</h2><p><em><strong>异步、削峰、解耦</strong></em>。</p><blockquote><ol><li>异步处理提高系统性能（减少响应时间）</li><li>削峰：就是限流</li><li>解耦：降低系统耦合性，更好维护，拓展性更高</li></ol></blockquote><h3 id="1-1-异步"><a href="#1-1-异步" class="headerlink" title="1.1. 异步"></a>1.1. 异步</h3><ol><li><em>为什么要异步</em>？</li></ol><p>传统场景下，客户端发起某个请求，假如说是下单吧，那负责下单的系统，不仅要进程支付功能的调用，更新库存，还要发送下单成功通知等。最后再返回一个状态说我都做完了，你可以做其他事了。用户这边体验就很差，下个单要等这么久。</p><p>如果全交给这一个系统做这一连串的事，那就很慢。</p><ol start="2"><li><em>加入消息队列怎么解决</em>？</li></ol><p>其实就是负责下单的系统接收到请求后，就发送消息到消息队列，那其他订阅了这个消息队列的系统就可以进行<strong>消费</strong>，然后做自己该干的事，而发送消息的系统直接就返回给用户说明下单成功。这样看来，用户的体验就很快。</p><blockquote><p>比如下单后，要过一段时间才会收到短信提醒。</p></blockquote><h2 id="2-削峰"><a href="#2-削峰" class="headerlink" title="2. 削峰"></a>2. 削峰</h2><p>简单来说就是拿消息队列做一层<strong>类似缓冲的作用</strong>，大量请求来到就先存在消息队列，然后消费者再慢慢吸收这些消息，<strong>防止大量请求打到数据库</strong>，Mysql 数据库一般 QPS 两千就差不多了，如果再多可能就崩了。</p><h2 id="3-解耦"><a href="#3-解耦" class="headerlink" title="3. 解耦"></a>3. 解耦</h2><ol><li><em>为啥需要解耦捏</em>？</li></ol><p>传统场景下，一个系统要给多个系统发送”消息”的时候，需要考虑下面几个问题。</p><ul><li>每个系统是不是都需要这个消息，假如又有新系统也要这个数据怎么办？再重发一次嘛？还是说要存一下，那也太消耗空间了。</li><li>如果消费者系统挂了，要不要重发？</li><li>……</li></ul><blockquote><p>所以对于一个系统来说，压力太大，耦合度太高，万一这个系统也崩了，那整个项目也就寄的差不多了。</p></blockquote><ol start="2"><li><em>引入消息队列后怎么解决的</em>。</li></ol><p>简单来说的话，就是生产者系统<strong>只需要关注消息的发送</strong>，而不用考虑后续出现的问题，比如一个系统想向其他系统发送消息，只需要把消息送到消息队列，然后就不管了，接下来与这个业务相关的系统就可以从消息队列中自行读取。</p><p>通过消息队列中的<strong>订阅-发布模式</strong>就可以让订阅了这个队列的消费者接收到请求并进行处理，也就实现了解耦。</p><ol start="3"><li>结合自己的项目</li></ol><ul><li><input checked="" disabled="" type="checkbox"> #task 结合自己的项目考虑为什么要引入消息队列 🔽 ✅ 2024-01-31</li></ul><p>参考：<a href="../../4%20%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E7%9B%92/%E7%9F%AD%E9%93%BE%E6%8E%A5shortlink/%E9%A1%B9%E7%9B%AE%E4%BA%AE%E7%82%B9%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/%E5%BC%95%E5%85%A5%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E9%87%8D%E6%9E%84%E7%9F%AD%E9%93%BE%E6%8E%A5%E9%87%8D%E5%AE%9A%E5%90%91%E6%97%B6%E8%AE%BF%E9%97%AE%E8%BE%83%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0%EF%BC%89.md">引入消息队列，重构短链接重定向时访问较慢的问题（流量削峰）</a> </p><blockquote><p><strong>面试技巧</strong>：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。在简历中体现出来这块东西，用 MQ 作解耦。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架/中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Synchronized锁升级，锁消除的理解</title>
      <link href="/2024/02/17/dui-synchronized-suo-sheng-ji-suo-xiao-chu-de-li-jie/"/>
      <url>/2024/02/17/dui-synchronized-suo-sheng-ji-suo-xiao-chu-de-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Synchronized 锁升级放下这么久了，今天打算好好学一下。主要方式是通过读<u>《Java 并发编程的艺术》</u>来进行学习。</p><p><mark style="background: #FFFF00;">Synchronized 锁状态共分为无锁、偏向锁、轻量级锁以及重量级锁。锁一旦升级就不能进行降级</mark>。</p><h2 id="先从-Synchronized-锁对对象的影响开始"><a href="#先从-Synchronized-锁对对象的影响开始" class="headerlink" title="先从 Synchronized 锁对对象的影响开始"></a>先从 Synchronized 锁对对象的影响开始</h2><p>先看一下用来判断一个对象是什么的对象头（Mark Word）。</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>4 bit</th><th>1 bit 用来判断是否为偏向锁</th><th>2bit 锁标识</th></tr></thead><tbody><tr><td>无锁状态</td><td>hashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr></tbody></table><p>如表所示，这是一个”未被锁的对象”，其对象头存储了 hashCode ，也就是调用 &#x3D;&#x3D; 时判断对象是否为同一个对象的时候用到的值，原来对象在新建的时候就已经设置好了 hashcode，不是用到的时候再计算的。</p><p>然后就是 4 bit, 我们都知道 GC 垃圾回收过程中，一般对象刚分配会分到新生代 Eden，在多次存活后（先放到 Suvivor 区），<u>当年龄达到后，就会移交到老年代</u>，这样就能减少对新生代进行垃圾回收时的性能消耗。每次存活对象的年龄都会增加，原来就是存储在这里啊。</p><p>然后就是判断偏向锁的标识，很明显就是判断是否给当前对象加了偏向锁，最后的锁标识则是用来标识当前对象被锁的状态到底是什么锁，是偏向锁还是、轻量级锁或者重量级锁。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p><strong>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程获得</strong>。为了减少线程获取锁以及释放锁带来的性能消耗，引入了偏向锁。</p><blockquote><p>意思很明显，就是让这个对象偏向于被某个线程加锁。</p></blockquote><p>实现原理：</p><table><thead><tr><th>锁状态</th><th>23bit</th><th>2bit</th><th>4bit</th><th>1bit 是否是偏向锁</th><th>2bit 锁标识位</th></tr></thead><tbody><tr><td>偏向锁</td><td>偏向线程 ID</td><td>偏向时间戳</td><td>对象分代年龄</td><td>1</td><td>01</td></tr></tbody></table><p>当一个线程访问对象获取锁的时候，会判断这个对象的对象头中的偏向锁标识是否为 1</p><ul><li>如果为 0，则说明未被加锁，于是设置为 1，并把偏向线程 ID 设置为自己的 ID。执行完后不释放锁，下次再访问到这个代码块的时候，判断这个线程 ID 是否是自己的 ID，如果是，<strong>由于没有释放锁，则直接执行代码块</strong>。</li><li>如果为 1，说明被加锁，判断是偏向锁 ID 是否为自己的 ID，如果是则直接执行，因为自己已经获取了锁。如果不是自己的 ID，则尝试用 CAS 修改线程 ID 为自己的。</li></ul><p>此时重点来了，线程尝试修改 CAS 修改线程 ID 为自己的 ID 时，修改失败。也就是说明其他线程还用着呢，你怎么就要获取了，这里就发生了<mark style="background: #FFFF00;">锁的竞争</mark>。</p><p>因此会<strong>发生偏向锁的撤销（偏向锁标识设置为 0，锁标识不变，因为无锁和偏向锁标识一样），然后进一步升级为轻量级锁</strong>。</p><p>画了个流程图：</p><p><img src="/images/%E5%81%8F%E5%90%91%E9%94%81.png"></p><h2 id="轻量级锁（自旋锁）"><a href="#轻量级锁（自旋锁）" class="headerlink" title="轻量级锁（自旋锁）"></a>轻量级锁（自旋锁）</h2><p>既然已经到了轻量级锁，说明出现了竞争。</p><p>从加锁和解锁两部分说明。</p><ol><li>加锁<br>线程通过 CAS 修改对象头内的锁标识</li></ol><ul><li>如果当前锁标识为无锁状态，则直接获取锁，并修改标识为有锁状态。</li><li>如果锁标识为有锁，则等待其他线程释放锁，并频繁的进行”自旋操作”尝试获取锁。</li></ul><ol start="2"><li>释放锁<br>设置标识为无锁状态。</li></ol><p>这样有什么问题？</p><ul><li>造成其他线程一直空转（不执行任务，但占用 CPU）并进行自旋操作，造成资源浪费，如果一直获取不到就会一直等待。</li></ul><p>因此轻量级锁适合于锁竞争不激烈的情况，如果锁竞争太过激烈（<mark style="background: #FFFF00;">比如自旋次数超过 10 次</mark>），就需要升级为重量级锁。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>其他线程在获取锁失败时发现是重量级锁，则<strong>不会等待，而是直接挂起，等待获取锁的线程执行完之后进行唤醒</strong>，其他线程才继续开始获取锁，并执行代码。</p><p>由此可以看到重量级锁，避免了线程空转，减少了 CPU 消耗，但是想对的，线程被阻塞，性能变慢。</p>]]></content>
      
      
      <categories>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么说线程创建的方式只有一种</title>
      <link href="/2024/02/14/wei-shi-me-shuo-xian-cheng-chuang-jian-de-fang-shi-zhi-you-yi-chong/"/>
      <url>/2024/02/14/wei-shi-me-shuo-xian-cheng-chuang-jian-de-fang-shi-zhi-you-yi-chong/</url>
      
        <content type="html"><![CDATA[<p>线程创建的方式说是有四种, 但是<strong>实际上只有一种创建方式</strong>. 为什么?</p><p>因为不管是 Callable 还是线程池创建线程, 看它们的实现方式或者说底层源码,<em>其本质上都是通过创建 Thread 对象来实现真正的创建线程</em>.  而实现 Runable 接口, 给我的感觉就是把重写 Thread 的 run 方法<em>提出来成为一个可重复利用的任务</em>, 这样创建相同任务的线程就比较方便.</p><ul><li>至于线程池为什么用到 Thread, 可以查看线程创建工厂 threadFactory 底层的接口, 就是一系列的判断和 new Thread.</li><li>Callable 就是类似, 不过把任务换成了 <code>FutureTask</code> 作为任务对象, 从而能够拿到线程执行的结果.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal的应用--用户信息上下文记录</title>
      <link href="/2024/02/14/threadlocal-de-ying-yong-yong-hu-xin-xi-shang-xia-wen-ji-lu/"/>
      <url>/2024/02/14/threadlocal-de-ying-yong-yong-hu-xin-xi-shang-xia-wen-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>就拿用户上下文信息保存来说。</p><p><strong>场景</strong>：</p><p>现在有一个场景，客户端请求新建一个短链接的分组，用户只需要输入一个分组名，然后确认即可创建分组。（全局唯一的分组 ID 这些都是由后端进行处理的）。如下请求：<br><img src="/images/%E7%9F%AD%E9%93%BE%E6%8E%A5%E5%88%86%E7%BB%84%E5%88%9B%E5%BB%BA%E8%AF%B7%E6%B1%82.png"></p><p>而且，我们<strong>分组和用户名要进行关联</strong>，不然我们怎么知道某个用户下的分组有哪些，或者说短链接分组的归属是谁？</p><ul><li>然后呢，问题来了，我们这个用户名参数是由<strong>前端传递</strong>嘛，那前端浏览器总不能一直存储用户信息吧，不安全。</li><li>或者说让<strong>用户手动传递用户名</strong>，然后后端验证是否是同一个用户然后再执行请求？这对用户的体验肯定非常不好，（我就是创建个分组而已，你连我是谁都不知道？）</li></ul><p><strong>解决方法</strong>：</p><p>这就可以使用 ThreadLocal 对象，在用户发第一次请求时，拦截器拦截后的处理中，就可以把用户信息作为 value，当前线程 ID 作为 key 存储在 ThreadLocalMap 中，这个 ThreadLocalMap 是封装在 ThreadLocal 中的一个 map 结构，其类似 HashMap，可以存储用户信息对象。</p><p>之后在需要获取用户名的时候，只要用用户上下文对象，通过 get 拿到要用的用户信息。</p><hr><p>如下是封装的一个 UserContext 类，包含 <code>set,get,remove等</code> 方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package org.ktpro.shortlink.admin.common.biz.user;import com.alibaba.ttl.TransmittableThreadLocal;import java.util.Optional;&#x2F;** * 用户上下文 *&#x2F;public final class UserContext &#123;&#x2F;&#x2F;实现ThreadLoal泛型    private static final ThreadLocal&lt;UserInfoDTO&gt; USER_THREAD_LOCAL &#x3D; new TransmittableThreadLocal&lt;&gt;();    &#x2F;**     * 设置用户至上下文     *     * @param user 用户详情信息     *&#x2F;    public static void setUser(UserInfoDTO user) &#123;        USER_THREAD_LOCAL.set(user);    &#125;        &#x2F;**     * 获取上下文中用户 ID     *     * @return 用户 ID     *&#x2F;    public static String getUserId() &#123;        UserInfoDTO userInfoDTO &#x3D; USER_THREAD_LOCAL.get();        return Optional.ofNullable(userInfoDTO).map(UserInfoDTO::getUserId).orElse(null);    &#125;        &#x2F;**     * 获取上下文中用户名称     *     * @return 用户名称     *&#x2F;    public static String getUsername() &#123;        UserInfoDTO userInfoDTO &#x3D; USER_THREAD_LOCAL.get();        return Optional.ofNullable(userInfoDTO).map(UserInfoDTO::getUsername).orElse(null);    &#125;    &#x2F;**     * 获取上下文中用户真实姓名     *     * @return 用户真实姓名     *&#x2F;    public static String getRealName() &#123;        UserInfoDTO userInfoDTO &#x3D; USER_THREAD_LOCAL.get();        return Optional.ofNullable(userInfoDTO).map(UserInfoDTO::getRealName).orElse(null);    &#125;    &#x2F;**     * 清理用户上下文     *&#x2F;    public static void removeUser() &#123;        USER_THREAD_LOCAL.remove();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Redolog持久化的底层理解</title>
      <link href="/2024/02/08/dui-redolog-chi-jiu-hua-de-di-ceng-li-jie/"/>
      <url>/2024/02/08/dui-redolog-chi-jiu-hua-de-di-ceng-li-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RedoLog 如何保证事务特性中的持久性的，之前学习的是只知道是缓存中更新数据，然后刷新到磁盘，这个过程中也知道借助了 Redolog 来实现，但是不知道更细节的层面，比如存储引擎数据页层面。</p><p>所以呢就补充了一点内容记录一下。</p><h2 id="1-Redo-log-保证持久性"><a href="#1-Redo-log-保证持久性" class="headerlink" title="1. Redo log 保证持久性"></a>1. Redo log 保证持久性</h2><p>#redolog</p><p>Redo log，重做日志，记录“<strong>事务提交时数据页的物理修改</strong>”，用来实现事务持久性。</p><blockquote><p>该日志文件由两部分组成: 重做日志缓冲 (redo log buffer)以及重做日志文件 (redo log file), 前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在<strong>刷新脏页到磁盘, 发生错误时，进行数据恢复使用</strong>。</p></blockquote><p>下面根据有无 redo log 日志文件分别区分持久化问题：</p><h3 id="1-1-假设没有-redo-log-日志，正常的持久化过程。"><a href="#1-1-假设没有-redo-log-日志，正常的持久化过程。" class="headerlink" title="1.1. 假设没有 redo log 日志，正常的持久化过程。"></a>1.1. 假设没有 redo log 日志，正常的持久化过程。</h3><blockquote><p>首先要知道 InnoDB 引擎内部的存储结构：一个内存结构和一个磁盘结构；<br><img src="/images/%E4%BA%8B%E5%8A%A1%E6%8C%81%E4%B9%85%E5%8C%96%E8%BF%87%E7%A8%8B.png"></p></blockquote><p>在进行一系列更新和删除操作前，Mysql 首先会从磁盘里读取相应的待修改数据到 <code>buffer pool</code> 内存中，这样一系列操作就会对内存中的这些数据进行修改，在事务提交前，内存中的数据就是所谓的脏数据。事务提交后会将脏数据刷新到磁盘完成持久化。</p><p>但是如果在刷新的过程中出错了，<strong>脏数据没有刷新到磁盘，但是事务已经提交</strong>，持久性就没法保证了。<br><img src="/images/%E8%84%8F%E6%95%B0%E6%8D%AE%E5%88%B7%E6%96%B0%E5%A4%B1%E8%B4%A5.png"></p><h3 id="1-2-使用-redo-log，保证持久性的过程"><a href="#1-2-使用-redo-log，保证持久性的过程" class="headerlink" title="1.2. 使用 redo log，保证持久性的过程"></a>1.2. 使用 redo log，保证持久性的过程</h3><p>先贴图：<br><img src="/images/redolog%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E6%8C%81%E4%B9%85%E6%80%A7.png"><br>具体顺序已用序号标出：</p><ol><li>在对内存中读取到的数据执行更新操作时，会同时将修改的数据存储到 <code>redo log buffer</code> 缓冲中</li><li>并且可以根据一定的策略，将 <u>redo log buffer 的数据同步到本地磁盘上的 redo log 文件</u>中，然后再将修改后的数据同步到磁盘中.（这个应该是在<strong>事务提交之后</strong>，记录全部的数据更新）。</li><li>假如此时数据库宕机（<strong>脏数据刷盘失败</strong>），那数据库重启之后会判断修改的数据是否真正同步到了磁盘，如果没有，那就通过 redo log 在本地磁盘上进行数据的”再”同步。从而实现持久化（并且这个过程是顺序 IO，速度很快）。</li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><blockquote><p>有个问题：<em>redo log buffer 同步到 redo log 到底是事务提交前还是事务提交后？</em>。<br><a href="https://cloud.tencent.com/developer/article/1945809">字节一面：事务还没提交的时候，redolog 能不能被持久化到磁盘呢？-腾讯云开发者社区-腾讯云 (tencent.com)</a> </p></blockquote><blockquote><p>T 2：<em>为什么不直接在页更新之后，就立即刷盘？</em> </p><ul><li>假如我们在页更新之后，也就是数据库对 <code> buffer pool</code> 内的数据更新后, 哪怕只是<u>更新几个字节的数据，那也要把这一整页的 16 kb 数据都同步到磁盘</u>，那语句多了，同步次数也多，性能也就下降了。</li><li>且执行一条 sql 语句，也有可能导致磁盘上的数据进行多次页分配，这个过程是随机 IO，寻址过程比较占内存。</li><li>通过 redo log 的话，由于是顺序写入的 redo log 文件，所以速度会很快。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql/redolog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Session的工作原理以及实操</title>
      <link href="/2024/02/04/session-de-gong-zuo-yuan-li-yi-ji-shi-cao/"/>
      <url>/2024/02/04/session-de-gong-zuo-yuan-li-yi-ji-shi-cao/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><mark style="background: #FFFF00;">Session 依赖于 Cookie</mark>。 </p><p>当客户端首次访问服务器时，服务器会为其创建一个 session 对象，该对象具有一个唯一标识 SESSIONID。并且在响应阶段，服务器会创建一个 cookie，并将 SESSIONID 存入其中。 </p><p>客户端通过响应的 cookie 而持有 SESSIONID，所以当它再次访问服务器时，会<mark style="background: #FFFF00;">通过 cookie 携带这个 SESSIONID。服务器获取到 SESSIONID 后，就可以找到与之对应的 session 对象</mark>，进而从这个 session 中获取该客户端的状态。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>存储用户信息</p><ol><li>用户端发起 POST 请求，服务端进行一定的逻辑处理后把用户信息存储在 Session。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;        String username &#x3D; request.getParameter(&quot;username&quot;);        String email &#x3D; request.getParameter(&quot;email&quot;);        &#x2F;&#x2F; 创建或获取会话对象        HttpSession session &#x3D; request.getSession();                &#x2F;&#x2F; 将用户信息存储在会话中        session.setAttribute(&quot;username&quot;, username);        session.setAttribute(&quot;email&quot;, email);        &#x2F;&#x2F; 重定向到用户信息展示页面        response.sendRedirect(request.getContextPath() + &quot;&#x2F;userInfo.jsp&quot;);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>客户端请求时携带带有 sessionID 的 Cookie，判断是否存在该 sessionID，如果存在则可以取出数据。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        &#x2F;&#x2F; 获取请求中的所有Cookie        Cookie[] cookies &#x3D; request.getCookies();        if (cookies !&#x3D; null) &#123;            &#x2F;&#x2F; 遍历Cookie找到名为 &quot;JSESSIONID&quot; 的Cookie            for (Cookie cookie : cookies) &#123;                if (&quot;JSESSIONID&quot;.equals(cookie.getName())) &#123;                    &#x2F;&#x2F; 获取Session ID                    String sessionID &#x3D; cookie.getValue();                    &#x2F;&#x2F; 获取或创建与该Session ID关联的会话                    HttpSession session &#x3D; request.getSession(false);                    if (session !&#x3D; null &amp;&amp; session.getId().equals(sessionID)) &#123;                        &#x2F;&#x2F; 会话存在且Session ID有效                        &#x2F;&#x2F; 可以在此处验证用户身份或执行其他操作                        &#x2F;&#x2F; 例如：String username &#x3D; (String) session.getAttribute(&quot;username&quot;);                        &#x2F;&#x2F; 返回验证成功的响应                        response.getWriter().println(&quot;Session is valid.&quot;);                        return;                    &#125;                &#125;            &#125;        &#125;        &#x2F;&#x2F; 没有有效的会话或Session ID，需要重定向到登录页面或其他处理方式        response.getWriter().println(&quot;Session is invalid.&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="双链"><a href="#双链" class="headerlink" title="双链"></a>双链</h2><pre class="line-numbers language-dataview" data-language="dataview"><code class="language-dataview">table file.inlinks as 被引用where file &#x3D; this.filelimit 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web/session工作原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql--谈谈自己对索引的理解</title>
      <link href="/2024/01/30/mysql-tan-tan-zi-ji-dui-suo-yin-de-li-jie/"/>
      <url>/2024/01/30/mysql-tan-tan-zi-ji-dui-suo-yin-de-li-jie/</url>
      
        <content type="html"><![CDATA[<p>从下面几点回答：</p><ol><li><em>索引是什么</em>？ （是单独存储在磁盘上的一种数据库结构。能加快数据查询的速度）</li><li><em>索引的底层数据结构包括 B+树索引，B 树索引，还有哈希索引等</em>。在不同的存储引擎中的存储形式是不同的。而且存储引擎也不一定支持所有的索引类型。</li><li><em>索引的优缺点</em>。</li></ol><h2 id="参考回答"><a href="#参考回答" class="headerlink" title="参考回答"></a>参考回答</h2><ul><li>索引是什么</li></ul><blockquote><p>嗯，索引是<strong>单独存储在磁盘上的一种数据库结构</strong>，它呢主要是为了<strong>提高数据查询的速度</strong>，因为当数据量很大的时候，<strong>如果没有索引</strong>，那数据库进行查询的时候会进行全表扫描，会非常慢。而引用了索引之后，<strong>比如 B+树索引</strong>，它的底层是平衡搜索二叉树，查询的效率会提高很多，时间复杂度大概在 O (logn)。</p></blockquote><p><del>（如果可以的话就继续扯下面的）</del> </p><ul><li>索引的底层数据结构</li></ul><blockquote><p>索引的底层数据结构包括，B+树索引，B 树索引，还有 Hash 哈希索引这几种主要的。在不同的存储引擎之间的默认数据结构是不同的。比如 <code>Memory</code> 数据引擎，是基于内存的，额外一提这种数据引擎比较适合创建临时表。回来继续，这个数据引擎其索引的数据结构就是哈希索引。而 Msyql 再 5.5 之后的默认存储引擎 <code>InnoDB</code> 和另一个存储引擎 <code>MyIsam</code> ，默认使用的索引数据类型是 B+树索引。</p></blockquote><blockquote><p>其实可以拿 B+树索引来看，B+树本身是一个平衡搜索二叉树，它的特点是<strong>只有叶子节点存储数据，非叶子节点只存储主键或者其他字段以及指针</strong>，用来快速定位所需要查询的数据，而且由于叶子节点之间通过<strong>双向链表</strong>进行连接，可以更方便的进行范围查询。</p></blockquote><blockquote><p>再看 B 树索引，B 树是 B+树的前身，因此可以说它是 B-树。B 树的话，不只是叶子节点存储数据，而是<strong>所有节点都存储数据</strong>，这样在<u>查询的时候，可能最快只需要一次 IO 就可以拿到数据，而 B+树索引则需要依次判断，最后到叶子节点才能拿到数据</u>，从这里看，其实 B 树的 IO 效率会更高一些。</p></blockquote><ul><li>索引的优缺点</li></ul><p>优点：</p><ol><li>通过<strong>建立唯一索引</strong>，可以保证数据的唯一性，<u>这点在我的项目里就有很大用处，因为要保证短链接以及短链接访问记录等的唯一性</u>，可以减少很多查询的次数。</li><li>刚才说过了，索引能够极大的提高数据查询的效率，原因在上面。</li><li>在分组查询和排序的过程中使用索引也能加快速度。</li></ol><p>缺点：</p><ol><li><strong>创建索引以及维护索引是比较麻烦</strong>的，只<u>要数据表数据更新时，索引可能需要对插入的数据进行存储，这时候树为了保证数据有序，可能就需要进行动态调整</u>，所以维护比较麻烦。而且创建索引会占用一定的存储空间。</li></ol><p>唯一索引应用（自己的项目）：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 记录基础访问监控数据 *&#x2F;@Insert(&quot;INSERT INTO t_link_access_stats (full_short_url, gid, date, pv, uv, uip, hour, weekday, create_time, update_time, del_flag) &quot; +        &quot;VALUES( #&#123;linkAccessStats.fullShortUrl&#125;, #&#123;linkAccessStats.gid&#125;, #&#123;linkAccessStats.date&#125;, #&#123;linkAccessStats.pv&#125;, #&#123;linkAccessStats.uv&#125;, #&#123;linkAccessStats.uip&#125;, #&#123;linkAccessStats.hour&#125;, #&#123;linkAccessStats.weekday&#125;, NOW(), NOW(), 0) ON DUPLICATE KEY UPDATE pv &#x3D; pv +  #&#123;linkAccessStats.pv&#125;, &quot; +        &quot;uv &#x3D; uv + #&#123;linkAccessStats.uv&#125;, &quot; +        &quot; uip &#x3D; uip + #&#123;linkAccessStats.uip&#125;;&quot;)void shortLinkStats(@Param(&quot;linkAccessStats&quot;) LinkAccessStatsDO linkAccessStatsDO);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>希望能够熟练的讲清楚吧，能想出来，但回答不好肯定不行….</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库/索引 </tag>
            
            <tag> 索引是什么 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM--触发GC的时机</title>
      <link href="/2024/01/28/jvm-hong-fa-gc-de-shi-ji/"/>
      <url>/2024/01/28/jvm-hong-fa-gc-de-shi-ji/</url>
      
        <content type="html"><![CDATA[<p>首先这个 GC 主要是针对堆内存的。</p><p>而 HotPot 虚拟机会把堆分为新生代 <code>Eden </code>和老年代以及<code>survivor</code>幸存区。</p><blockquote><p>为什么需要 <code>survivor </code>区，主要是因为如果没有这个区，只有新生代和老年代的话。</p><ol><li>新生代每次内存快满的时候触发 <code>Minor GC </code> 时都直接把幸存的对象加入老年代，就可能导致老年代的内存很快就会满从而触发 <code> Full GC</code> ，而 <code> FULL GC</code> 的耗时是很长的, 会触发 STP 问题，不方便对老年代进行垃圾回收。</li><li>有了幸存区，可以理解成一层缓冲，新生代对象在经历一次垃圾回收后，如果存活就先防、放在 survivor 区中，如果多次都存活，则再加入到老年代，对老年代管理对象比较友好。</li></ol></blockquote><h2 id="触发-GC-的时机"><a href="#触发-GC-的时机" class="headerlink" title="触发 GC 的时机"></a>触发 GC 的时机</h2><ul><li><p>对于新生代内存耗尽的情况，会触发 <code>Minor GC</code>，对新生代进行垃圾回收，然后把存活对象加到 <code>survivor </code> 区，多次存活则转移到老年代。</p></li><li><p>对于老年代而言，是触发 <code>FULL GC</code> （FULL GC 是对整个堆进行垃圾回收）。</p><ul><li>对于 Serial GC <strong>串行垃圾回收器</strong>，会在老年代剩余内存小于”<em>平均转入老年代的新生代所需内存大小</em>“时，会触发 <code>FULL GC</code>。</li><li>对于 CMS 等各种<strong>并发垃圾回收器</strong>，会每隔一段时间检查一下老年代内存空间占用是否超过一定比例，如果超过则进行 <code>FULL GC</code>。</li></ul></li></ul><h2 id="减少-FULL-GC-的次数"><a href="#减少-FULL-GC-的次数" class="headerlink" title="减少 FULL GC 的次数"></a>减少 FULL GC 的次数</h2><p>其实从触发要求来看，可以找到如下解决方法：</p><ol><li><strong>增加新生代或老年代的内存大小</strong>，能装的对象多了，也就能够减少触发的机会。</li><li>一般老年代使用的垃圾回收算法是‘‘<strong>标记-整理</strong>’‘，就是把存活的对象移到内存的一侧，这样能够流出足够的空间存放其他对象，从而减少 GC。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM/什么时候触发GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决消息队列重复消费问题</title>
      <link href="/2024/01/23/jie-jue-xiao-xi-dui-lie-chong-fu-xiao-fei-wen-ti/"/>
      <url>/2024/01/23/jie-jue-xiao-xi-dui-lie-chong-fu-xiao-fei-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="重复消费产生原因"><a href="#重复消费产生原因" class="headerlink" title="重复消费产生原因"></a>重复消费产生原因</h2><ol><li>网络问题</li><li><strong>消息队列一般对消息消费失败都有重试机制</strong>，假如有一个消息消费执行了某些逻辑后在删除标识时失败了 (服务宕机，断电等问题导致中断)，那消息队列就会进行重试，而造成重复消费。</li></ol><p>待补充。</p><h2 id="怎么解决"><a href="#怎么解决" class="headerlink" title="怎么解决"></a>怎么解决</h2><p><strong>通过 Redis 设置幂等标识，当需要进行消费时，判断以当前消息 ID 为后缀的幂等 Key 是否存在于 Redis 中，如果其已经被消费，则直接返回，否则放行进行消费并设置完成标识</strong>。</p><p>完成标识和消息消费的标识是<strong>同一个 Key</strong>，因为消息消费是判断是否存在这条消息消费记录，而完成标识是通过设置这个 key 的 value 为 1 表示完成。</p><p>(<em>双重判定保证消费不会因为异常丢失</em>)这一点也可以写上。</p><p>消费过程如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override   public void onMessage(MapRecord&lt;String, String, String&gt; message) &#123;       String stream &#x3D; message.getStream();       RecordId id &#x3D; message.getId();       &#x2F;&#x2F; 判断当前的这个消息是否已经被消费       if (!messageQueueIdempotentHandler.isMessageProcessed(id.toString())) &#123;           &#x2F;&#x2F;消费失败，但是此时已经设置了消费标识，可能会导致消息未被真实消费，所以设置一个完成标识           if (messageQueueIdempotentHandler.isAccomplish(id.toString())) &#123;               return;           &#125;           throw new ServiceException(&quot;消息未完成流程，需要消息队列重试&quot;);       &#125;       try &#123;           Map&lt;String, String&gt; producerMap &#x3D; message.getValue();           String fullShortUrl &#x3D; producerMap.get(&quot;fullShortUrl&quot;);           if (StrUtil.isNotBlank(fullShortUrl)) &#123;               String gid &#x3D; producerMap.get(&quot;gid&quot;);               ShortLinkStatsRecordDTO statsRecord &#x3D; JSON.parseObject(producerMap.get(&quot;statsRecord&quot;), ShortLinkStatsRecordDTO.class);               &#x2F;&#x2F;核心：调用原本的短链接统计方法               actualSaveShortLinkStats(fullShortUrl, gid, statsRecord);           &#125;           &#x2F;&#x2F;由于Redis自身没有像MQ那种智能的把消费过的信息，待一段时间后自动删除，而且内存珍贵，所以手动删除这个消息（也能避免重复消费）           stringRedisTemplate.opsForStream().delete(Objects.requireNonNull(stream), id.getValue());       &#125; catch (Throwable ex) &#123;           &#x2F;&#x2F; 消息队列宕机处理           messageQueueIdempotentHandler.delMessageProcessed(id.toString());           log.error(&quot;记录短链接监控消费异常&quot;, ex);       &#125;       &#x2F;&#x2F;当完整执行完消费流程，才会设置完成标识。       messageQueueIdempotentHandler.setAccomplish(id.toString());   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目/重复消费 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于项目中的消息队列重复消费问题</title>
      <link href="/2024/01/23/guan-yu-xiang-mu-zhong-de-xiao-xi-dui-lie-chong-fu-xiao-fei-wen-ti/"/>
      <url>/2024/01/23/guan-yu-xiang-mu-zhong-de-xiao-xi-dui-lie-chong-fu-xiao-fei-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="重复消费产生原因"><a href="#重复消费产生原因" class="headerlink" title="重复消费产生原因"></a>重复消费产生原因</h2><ol><li>网络问题</li><li><strong>消息队列一般对消息消费失败都有重试机制</strong>，假如有一个消息消费执行了某些逻辑后在删除标识时失败了 (服务宕机，断电等问题导致中断)，那消息队列就会进行重试，而造成重复消费。</li></ol><p>待补充。</p><h2 id="怎么解决"><a href="#怎么解决" class="headerlink" title="怎么解决"></a>怎么解决</h2><p><strong>通过 Redis 设置幂等标识，当需要进行消费时，判断以当前消息 ID 为后缀的幂等 Key 是否存在于 Redis 中，如果其已经被消费，则直接返回，否则放行进行消费并设置完成标识</strong>。</p><p>完成标识和消息消费的标识是<strong>同一个 Key</strong>，因为消息消费是判断是否存在这条消息消费记录，而完成标识是通过设置这个 key 的 value 为 1 表示完成。</p><p>(<em>双重判定保证消费不会因为异常丢失</em>)这一点也可以写上。</p><p>消费过程如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override   public void onMessage(MapRecord&lt;String, String, String&gt; message) &#123;       String stream &#x3D; message.getStream();       RecordId id &#x3D; message.getId();       &#x2F;&#x2F; 判断当前的这个消息是否已经被消费       if (!messageQueueIdempotentHandler.isMessageProcessed(id.toString())) &#123;           &#x2F;&#x2F;消费失败，但是此时已经设置了消费标识，可能会导致消息未被真实消费，所以设置一个完成标识           if (messageQueueIdempotentHandler.isAccomplish(id.toString())) &#123;               return;           &#125;           throw new ServiceException(&quot;消息未完成流程，需要消息队列重试&quot;);       &#125;       try &#123;           Map&lt;String, String&gt; producerMap &#x3D; message.getValue();           String fullShortUrl &#x3D; producerMap.get(&quot;fullShortUrl&quot;);           if (StrUtil.isNotBlank(fullShortUrl)) &#123;               String gid &#x3D; producerMap.get(&quot;gid&quot;);               ShortLinkStatsRecordDTO statsRecord &#x3D; JSON.parseObject(producerMap.get(&quot;statsRecord&quot;), ShortLinkStatsRecordDTO.class);               &#x2F;&#x2F;核心：调用原本的短链接统计方法               actualSaveShortLinkStats(fullShortUrl, gid, statsRecord);           &#125;           &#x2F;&#x2F;由于Redis自身没有像MQ那种智能的把消费过的信息，待一段时间后自动删除，而且内存珍贵，所以手动删除这个消息（也能避免重复消费）           stringRedisTemplate.opsForStream().delete(Objects.requireNonNull(stream), id.getValue());       &#125; catch (Throwable ex) &#123;           &#x2F;&#x2F; 消息队列宕机处理           messageQueueIdempotentHandler.delMessageProcessed(id.toString());           log.error(&quot;记录短链接监控消费异常&quot;, ex);       &#125;       &#x2F;&#x2F;当完整执行完消费流程，才会设置完成标识。       messageQueueIdempotentHandler.setAccomplish(id.toString());   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 项目/重复消费 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap实现线程安全的方式</title>
      <link href="/2024/01/12/concurrenthashmap-shi-xian-xian-cheng-an-quan-de-fang-shi/"/>
      <url>/2024/01/12/concurrenthashmap-shi-xian-xian-cheng-an-quan-de-fang-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>衍生问题：</p><ul><li>ConcurrentHashMap 和 HashTable 的区别；</li><li>ConcurrentHashMap 和 HashMap 的区别；</li></ul></blockquote><p>本文介绍 ConcurrentHashMap 是怎么实现线程安全的，主要根据其在不同 JDK 版本下的实现。</p><blockquote><p>源码解析：<a href="https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw">还不懂 ConcurrentHashMap ？这份源码分析了解一下 (qq.com)</a></p></blockquote><h2 id="ConcurrentHashMap-的底层数据结构以及线程安全实现"><a href="#ConcurrentHashMap-的底层数据结构以及线程安全实现" class="headerlink" title="ConcurrentHashMap 的底层数据结构以及线程安全实现"></a>ConcurrentHashMap 的底层数据结构以及线程安全实现</h2><p>在 JDK 1.7 时，采用<strong>分段 Segment 数组+链表</strong>实现。JDK 1.8 以后采用和 HashMap 1.8 时的一样，都是<strong>数组 + 链表&#x2F;红黑树</strong>。但是这个数组的节点是一个一个的 Node 节点。</p><h3 id="JDK-1-8-之前："><a href="#JDK-1-8-之前：" class="headerlink" title="JDK 1.8 之前："></a>JDK 1.8 之前：</h3><p><img src="/images/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8JDK1.8%E4%B9%8B%E5%89%8D.png"></p><p><mark style="background: #FFFF00;">实现原理</mark>：指对数据进行分段，对每一部分数据分别加一个<strong>分段锁 Segment</strong>，每一个段对应一个 <strong>HashEntry 数组</strong>，这个数组采用 key-value 结构存储键值对数据，值的类型为链表。当需要对某个 HashEntry 数组进行修改时，会先获取对应的 Segment 锁。</p><blockquote><p>多线程对于同一段的操作会造成堵塞，不同段可以并发。</p></blockquote><p><strong>Segment</strong> ：继承了 ReentrantLock 锁，所以是一种<strong>可重入锁</strong>，由于实现方式的底层是一个 Segment 数组，所以<strong>段的个数是不可改变的</strong>（默认大小 16）。</p><blockquote><p>可重入锁不清楚了可以参考：<a href="../../%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BJUC/JUC--%E6%B0%B8%E4%B9%85%E7%AC%94%E8%AE%B0--AQS%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E4%B8%8EReentrantLock%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.md">JUC–永久笔记–AQS队列同步器与ReentrantLock可重入锁</a> </p></blockquote><h3 id="JDK-1-8-之后"><a href="#JDK-1-8-之后" class="headerlink" title="JDK 1.8 之后"></a>JDK 1.8 之后</h3><p><img src="/images/ConcurrentHashMap%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8JDK1.8%E5%90%8E.png"></p><p>通过 <strong>Node 数组 + CAS + synchronized</strong> 实现并发安全；结构为<strong>数组 + 链表&#x2F;红黑树</strong>。</p><p>与 JDK 1.8 之前的实现方式对比：</p><ol><li><strong>数据结构不同</strong> </li><li><strong>锁的粒度更细</strong>，改用了 Node 作为锁的对象</li><li>优化了出现 Hash 冲突时的数据存储，和 HashMap 1.8 之后类似，数组和链表超过一定长度会转换为红黑树。</li><li>由于是使用 Node 数组，节点个数更多，所以并发度更高。</li></ol><h2 id="和-HashTable-的区别"><a href="#和-HashTable-的区别" class="headerlink" title="和 HashTable 的区别"></a>和 HashTable 的区别</h2><p>底层数据结构：</p><ol><li>HashTable 底层是由桶数组 + 链表实现</li><li>ConcurrentHashMap 1.8 之前是 Segment 数组+链表。1.8 之后是 Node 数组+链表&#x2F;红黑树。</li></ol><p>实现线程安全的方式不同:</p><ol><li>HashTable 是通过 Synchronized 进行加锁，当进行锁的时候会锁住整个桶数组，其他线程不能进行元素的修改和读取，竞争很激烈，因此效率较低。</li><li>ConcurrentHashMap 1.7 的时候，当修改某个 entry 数组下的元素时，会把 entry 所在的 Segment 段加锁，其他线程如果也想访问到同一个 Segment 下的元素，就必须等待锁的释放。此时其实已经比 HashTable 的效率高很多了，但是仍然会发生线程竞争问题。因此 1.8 之后采用了 Node 数组+链表&#x2F;红黑树实现，和 HashMap 的结构类似，一个 Node 数组对应一个链表或者红黑树，每次只需要锁住某个 Node 节点即可实现线程安全问题，这时锁的粒度更细，也就减少了线程竞争访问问题。</li></ol><p>容量问题：</p><ol><li>HashTable 在初始化之后，Segment 数组就不能进行扩容了，是固定的，不够灵活。</li><li>Node 数组由于是链表节点，因此可以无限扩容。</li></ol><p>确实是链表节点。<br><img src="/images/Node%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B.png"></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis--Set集合</title>
      <link href="/2024/01/12/redis-set-ji-he/"/>
      <url>/2024/01/12/redis-set-ji-he/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p><strong>无序并唯一的键值集合</strong>，存储顺序不按照插入顺序。支持交集、并集、差集运算。</p><h3 id="1-1-内部实现"><a href="#1-1-内部实现" class="headerlink" title="1.1. 内部实现"></a>1.1. 内部实现</h3><p><strong>哈希表或整数集合</strong>。</p><ul><li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>否则采用哈希表存储</li></ul><h4 id="1-1-1-哈希表"><a href="#1-1-1-哈希表" class="headerlink" title="1.1.1. 哈希表"></a>1.1.1. 哈希表</h4><p>没有用红黑树，只是<strong>桶数组 + 链表</strong>。</p><h4 id="1-1-2-整数集合"><a href="#1-1-2-整数集合" class="headerlink" title="1.1.2. 整数集合"></a>1.1.2. 整数集合</h4><p>#整数集合  #Redis&#x2F;intset</p><p><code>intset</code> 整数集合其实就是一个数组，但是其会在数组的头部保存当前数组的编码类型，还有数组真实的首部地址。</p><p><img src="/../images/intSet%E7%BB%93%E6%9E%84%E4%BD%93.png"></p><ol><li><p>当进行增加元素的命令时，会<strong>根据插入数据的大小，决定是否需要升级当前的编码</strong>，其内部共有三种编码，<code>int16,int32,int64</code> 分别相当于 java 的 short，int，long 类型的数据范围。</p></li><li><p><strong>查找时采用二分查找</strong>，效率还是很快的。其判断元素地址的时候，会根据当前元素的下标，以及编码类型确定元素的真实所在地址（因为不是默认的 int 数组，所以需要自定义规则）。寻址公式：<code>startPtr + (sizeof(int64) * index)</code> 得到真实地址。</p></li><li><p>intset 插入数据时会保证数据是有序的，并且当编码类型改变时，会进行如下操作：</p><ul><li>进行扩容，接着<strong>申请一段内存</strong> </li><li>然后对所有元素进行复制，复制的时候对所有元素根据<strong>逆序进行插入</strong>，主要是防止其他元素会被当前元素覆盖。</li><li>复制过程中，<strong>会根据新的编码类型和索引进行真实地址的求解</strong>。</li></ul></li></ol><h3 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2. 常用命令"></a>1.2. 常用命令</h3><pre class="line-numbers language-none"><code class="language-none"># 往集合key中存入元素，元素存在则忽略，若key不存在则新建SADD key member [member ...]# 从集合key中删除元素SREM key member [member ...] # 获取集合key中所有元素SMEMBERS key# 获取集合key中的元素个数SCARD key# 判断member元素是否存在于集合key中SISMEMBER key member# 从集合key中随机选出count个元素，元素不从key中删除SRANDMEMBER key [count]# 从集合key中随机选出count个元素，元素从key中删除SPOP key [count]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>交并差集：</p><ul><li>交集：<code>SINTER key [key ...]</code> </li><li>并集：<code>SUNION key [key ...]</code> </li><li>差集：<code>SDIFF key [key ...]</code></li></ul><h3 id="1-3-应用场景"><a href="#1-3-应用场景" class="headerlink" title="1.3. 应用场景"></a>1.3. 应用场景</h3><p>保证数据唯一时，如点赞，每个用户只能点赞同一个帖子一次。</p><p>可以做到：</p><ul><li>获取点赞数量</li><li>获取点赞的所有用户 id</li><li>点赞和取消点赞</li><li><strong>用集合运算得到共同关注的好友、公众号等</strong>。</li><li>抽奖活动：同一个用户只能中奖一次。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis/intset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-String底层</title>
      <link href="/2024/01/05/redis-string-shu-ju-lei-xing/"/>
      <url>/2024/01/05/redis-string-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h2><p>是最基本的 redis 数据类型，比如常见的 <code>set key value</code> 就是 String 类型。</p><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>String 内部是基于<strong>动态字符串 SDS</strong> 实现的，这和 C 语言的字符串不一样。</p><p><img src="/../images/Redis--String%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p><ul><li>SDS 不仅可以保存文本信息<strong>也可以保存二进制数据</strong>，所以视频、音频、图片都可以用 SDS 保存。</li></ul><blockquote><p>为啥可以存储二进制数据，其底层不也是 char 数组吗，而且还有 <code>\0</code> ，存二进制不是会造成误判吗？<br>因为 SDS 底层在对象头里加了一个字段，<strong>记录当前字符串的长度</strong>，忽略了 C 语言字符串的 <code>\0</code> ，所以可以直接用来获取字符串长度。</p><p>但是不建议用 redis 存储，因为一般这些数据的体积很大，而 String 的 value 最大限制为 <code>512M</code> </p></blockquote><ul><li>SDS 自带 <strong>len 变量记录数据长度</strong>，可以很快获得数据长度。</li><li>SDS <strong>拼接字符串不会造成缓冲区溢</strong>出，因为在拼接字符串之前会检测并会自动扩容（预分配机制）。</li></ul><h3 id="常用命令-包含应用场景"><a href="#常用命令-包含应用场景" class="headerlink" title="常用命令 (包含应用场景)"></a>常用命令 (包含应用场景)</h3><p>列举一些常用的：</p><ol><li>设置 key 的值：<code>set key value</code>  获取 key 的值: <code>get key</code> （可用于 <strong>Session 存储和读取</strong>）</li><li><strong>分布式锁的应用</strong>（一种互斥锁）：<code>SETNX key value</code> 存在就不能创建，不存在则可以创建。</li><li>指定多个 key - value ：<code>MSET key1 value1 key2 value2</code> MSET 命令后每一对就是一个键值对。</li><li>获取 key 对应的数据长度：<code>STRLEN key</code> </li><li>删除键值对：<code>DEL key</code>   (通用)</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT登录校验</title>
      <link href="/2023/12/24/jwt-deng-lu-xiao-yan/"/>
      <url>/2023/12/24/jwt-deng-lu-xiao-yan/</url>
      
        <content type="html"><![CDATA[<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><strong>JWT</strong> （JSON Web Token）也是一种 Token，可以基于 JWT 来做权限认证。</p><p>由 Header、Payload 以及 Signature 三部分组成构成。</p><ul><li>其中 Header 是描述 JWT 的元数据，包括 <strong>token 的类型和生成签名的算法</strong>。</li><li>Payload：负载，存的是需要传递的数据；比如<strong>登录的时候需要存储用户的登录信息</strong>。</li><li>Signature：签名，通过 Header 里指定的签名算法，对 Header 和 Payload 配合密钥生成。主要是防止 Token 被篡改。</li></ul><h2 id="基于-JWT-进行身份验证原理（过程）"><a href="#基于-JWT-进行身份验证原理（过程）" class="headerlink" title="基于 JWT 进行身份验证原理（过程）"></a>基于 JWT 进行身份验证原理（过程）</h2><p>客户端发起登录请求（提交登录信息，比如用户名和密码），假设验证成功，服务端会根据 Header 和 Payload 以及 Secret 密钥生成一个 <code> token</code>，并发送给客户端，客户端收到后存储在 <code>Cookies</code> 或 <code>LocalStorage</code> 中，以后客户端每次请求都会在 Header 中携带这个令牌用作登录验证。</p><blockquote><p>tips：LocalStorage 是浏览器中永久存在的，只有主动删除时才会被删除，而 sessionStorage 是会话结束后自动删除。</p></blockquote><p>服务端收到请求后，会对令牌进行验证，验证通过才能放行。</p><h2 id="如何防止-Token-被篡改"><a href="#如何防止-Token-被篡改" class="headerlink" title="如何防止 Token 被篡改"></a>如何防止 Token 被篡改</h2><p>因为服务端收到 Header 和 Payload 后，会再生成一个签名 Signature ，用这个 signature 和 Token 中携带的 signature 进行对比，如果不一致说明被篡改了。</p><blockquote><p>因此密钥要保护好，否则攻击者可以通过该密钥，对 Header 和 Payload 生成一个新的签名，再给服务端就检测不到错误了。</p></blockquote><h2 id="与-Session-相比有什么优缺点"><a href="#与-Session-相比有什么优缺点" class="headerlink" title="与 Session 相比有什么优缺点"></a>与 Session 相比有什么优缺点</h2><p>对服务端空间友好，不需要存额外的数据，而 session 需要存在 Redis 或者 Mysql 里。</p><p>安全性更高，不需要通过 Cookies 进行验证（Cookies 很容易被作为伪造身份的信息），如上述中有一层认证更安全。</p><h2 id="子知识"><a href="#子知识" class="headerlink" title="子知识"></a>子知识</h2><p><a href="../../3%20%E5%AD%90%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0%E7%9B%92/%E9%80%9A%E7%94%A8/%E9%80%9A%E7%94%A8--%E5%AD%90%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0--JWT%20%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.md">通用–子知识笔记–JWT 身份认证常见问题及解决办法</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> JWT </tag>
            
            <tag> 通用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环队列模拟</title>
      <link href="/2023/12/16/lc622.shu-zu-mo-ni-xun-huan-dui-lie-fu-xi/"/>
      <url>/2023/12/16/lc622.shu-zu-mo-ni-xun-huan-dui-lie-fu-xi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大体思路记得，但是具体细节有遗忘，可以参考：<a href="https://blog.csdn.net/u010429311/article/details/51043149">循环队列中判断队满与队空_循环队列判断队空和队满-CSDN博客</a></p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/../images/LC622.%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%88%E5%A4%8D%E4%B9%A0%EF%BC%89.png"></p><p>代码都是自己写的，Debug 也是。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**    普通队列约定：       1. hh &#x3D;&#x3D; tt队空；但是容量有限       2. 元素入队尾指针 q[tt++] &#x3D; val  ; 队头元素，q[hh]; 出队元素头指针 ++hh;    循环队列        1. 队满 hh &#x3D;&#x3D; (tt + 1) % Q_size;   &#x2F;&#x2F;留一个位置判定满元素        2. 队空 hh &#x3D;&#x3D; tt;      *&#x2F;class MyCircularQueue &#123;    &#x2F;&#x2F;设计一个循环队列，一个空间用来存放两指针的交界，判断是为空还是满    int[] MyQueue;    int hh &#x3D; 0, tt &#x3D; 0;    int size &#x3D; 0 ;  &#x2F;&#x2F;存元素个数    int MAX_SIZE &#x3D; 0;        public MyCircularQueue(int k) &#123;        MyQueue &#x3D; new int[k + 1];        MAX_SIZE &#x3D; k + 1;   &#x2F;&#x2F;用来取模的队列长度; 注意是k + 1,因为一个位置要拿来取模    &#125;        &#x2F;&#x2F;元素入队    public boolean enQueue(int value) &#123;        if(isFull()) return false;                MyQueue[tt] &#x3D; value;   &#x2F;&#x2F;入队        tt &#x3D; (tt + 1) % MAX_SIZE;  &#x2F;&#x2F;更新指针        size++;  &#x2F;&#x2F;更新容量        return true;    &#125;        &#x2F;&#x2F;元素删除； 删除头部元素    public boolean deQueue() &#123;        if(isEmpty()) return false;   &#x2F;&#x2F;队空，删除失败        hh &#x3D; (hh + 1) % MAX_SIZE;        size--;  &#x2F;&#x2F;更新容量        return true;    &#125;        public int Front() &#123;        if(isEmpty()) return -1;   &#x2F;&#x2F;队空，弹出元素失败        return MyQueue[hh];    &#125;        public int Rear() &#123;        if(isEmpty()) return -1;   &#x2F;&#x2F;队空，弹出元素失败        return MyQueue[(tt - 1 + MAX_SIZE) % MAX_SIZE];    &#x2F;&#x2F;队尾稍微不太一样，因为可能会在0的位置，但是此时队列并空，所以要求和取模    &#125;        &#x2F;&#x2F;判定队空    public boolean isEmpty() &#123;        return hh &#x3D;&#x3D; tt;    &#125;        &#x2F;&#x2F;判定队满    public boolean isFull() &#123;        return (tt + 1) % MAX_SIZE &#x3D;&#x3D; hh;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间合并-贪心</title>
      <link href="/2023/12/02/qu-jian-he-bing-tan-xin/"/>
      <url>/2023/12/02/qu-jian-he-bing-tan-xin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>反复遇到，因此做个笔记，思想不难，所以直接看注释就够了。</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>LC-56： <a href="https://leetcode.cn/problems/merge-intervals/description/">56. 合并区间 - 力扣（LeetCode）</a> </p><h2 id="Java-代码"><a href="#Java-代码" class="headerlink" title="Java 代码"></a>Java 代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    public int[][] merge(int[][] intervals) &#123;        &#x2F;&#x2F;1.按照左端点排序        Arrays.sort(intervals, (v1, v2) -&gt; v1[0] - v2[0]);        int[][] res &#x3D; new int[intervals.length][2];  &#x2F;&#x2F;存最终合并后的区间        int idx &#x3D; -1;   &#x2F;&#x2F;第index个区间序号        for(int[] interval : intervals)&#123;            &#x2F;&#x2F;初始时idx &#x3D; -1，无区间；或者 上一个区间右端点小于当前区间的左端点，应该新加一个区间            if(idx &#x3D;&#x3D; -1 || interval[0] &gt; res[idx][1])&#123;                res[++idx] &#x3D; interval;            &#125;else &#123;                &#x2F;&#x2F;否则就是区间端点有重叠，需要合并右端点(更新当前合并后区间的右端点)                res[idx][1] &#x3D; Math.max(res[idx][1], interval[1]);            &#125;        &#125;        return Arrays.copyOf(res, idx + 1);           &#x2F;&#x2F;这里为什么要拷贝一个大小为idx + 1的数组？         &#x2F;**        因为最后合并区间的个数肯定是小于等于原区间个数的，而创建的临时数组res的大小就是原区间个数，如果最后合并后的区间个数小了，则会出现[0, 0]的情况。        且个数为 idx + 1个区间，0 --&gt; idx 个         *&#x2F;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        vector&lt;vector&lt;int&gt;&gt; ans;        sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;return a[0] &lt; b[0];&#125;);  &#x2F;&#x2F;按照左端点，递增排序        int st &#x3D; -1, ed &#x3D; -1;        int tmp[2]&#x3D;&#123;0&#125;;        for(auto interval : intervals)&#123;            if(ed &lt; interval[0])&#123;                &#x2F;&#x2F;区间右端点无法覆盖下一个区间，所以是个新区间(除了开始的默认区间-1，-1)                tmp[0] &#x3D; st, tmp[1] &#x3D; ed;                if(st !&#x3D; -1) ans.push_back(&#123;tmp[0], tmp[1]&#125;);                &#x2F;&#x2F;然后更新辅助区间为下一区间                st &#x3D; interval[0], ed &#x3D; interval[1];            &#125;else &#123;                &#x2F;&#x2F;否则能覆盖，更新最大覆盖范围                ed &#x3D; max(ed, interval[1]);            &#125;        &#125;        if(st !&#x3D; -1)&#123;            &#x2F;&#x2F;最后一个区间，由于没有参照物，所以只能判断是否为空，不为空集合则放入答案数组            ans.push_back(&#123;st, ed&#125;);        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch</title>
      <link href="/2023/11/27/countdownlatch/"/>
      <url>/2023/11/27/countdownlatch/</url>
      
        <content type="html"><![CDATA[<ul><li><input checked="" disabled="" type="checkbox"> #task countdownlauch ✅ 2023-11-24</li></ul><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>CountDownLatch 的几个<strong>主要方法</strong>：</p><p><strong>（1）构造函数</strong>：public CountDownLatch(int count) { };<br>它的构造函数是传入一个参数，该参数 count 是需要倒数的数值。</p><p>**（2）await()**：调用 await() 方法的线程<mark style="background: #FFFF00;">开始等待，直到倒数结束</mark>，也就是 count 值为 0 的时候才会继续执行。</p><p>**（3）await(long timeout, TimeUnit unit)**：传入超时参数，这里可以设置超时时间，如果超时就不再等待了。</p><p>**（4）countDown()**：把数值倒数 1，也就是将 count 值减 1，直到减为 0 时，之前等待的线程会被唤起。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>主要有如下两种：<strong>一等多、多等一</strong> </p><h3 id="一个线程等待多个线程执行完毕"><a href="#一个线程等待多个线程执行完毕" class="headerlink" title="一个线程等待多个线程执行完毕"></a>一个线程等待多个线程执行完毕</h3><p>比如一个裁判员和多个跑步运动员，<strong>裁判员必须在所有运动员都完成比赛才能吹哨比赛结束</strong>。就可以通过 <em>CountDownLatch</em> 设置计数器（应该设置为 5，因为要等 5 个线程结束），让”裁判员”最后执行吹哨。</p><blockquote><p>翻译过来就是：<strong>多个线程执行完毕，这个线程才能执行</strong>。</p></blockquote><p>示例代码如下：一个裁判、五个运动员。<br><img src="/images/CountDownLatch1.png"></p><h3 id="多个线程必须等待一个线程执行完才能继续执行"><a href="#多个线程必须等待一个线程执行完才能继续执行" class="headerlink" title="多个线程必须等待一个线程执行完才能继续执行"></a>多个线程必须等待一个线程执行完才能继续执行</h3><p>换个场景，<strong>多个运动员必须等待裁判开枪才能起跑</strong>。</p><blockquote><p><em>CountDownLatch</em> 设置计数器（应该设置为 1，因为要等 1 个线程结束）</p></blockquote><p>那就是让每个运动员线程执行 <em>await</em> 方法等待, 直到”裁判”开枪（调用 <em>countDown</em> ）, 使计数器为 0，才能让运动员开始跑。</p><p>示例代码：<br><img src="/images/carbon%20(2).png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之：CountDownLatch 类在创建实例的时候，需要在构造函数中传入<strong>倒数次数</strong>，然后<strong>由需要等待的线程去调用 await 方法开始等待</strong>，而每一次其他线程调用了 <em><strong>countDown 方法</strong></em>之后，计数便会减 1，直到减为 0 时，之前等待的线程便会继续运行。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理 </tag>
            
            <tag> JUC </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bean的三级缓存解决循环依赖</title>
      <link href="/2023/11/11/bean-de-san-ji-huan-cun-jie-jue-xun-huan-yi-lai/"/>
      <url>/2023/11/11/bean-de-san-ji-huan-cun-jie-jue-xun-huan-yi-lai/</url>
      
        <content type="html"><![CDATA[<blockquote><p>忘了就可以回顾一下黑马的：<a href="https://www.bilibili.com/video/BV15b4y117RJ?p=184&vd_source=1ffd466ed0c5135e3f1bc07afebf6213">框架篇-51-循环依赖_一级缓存作用_哔哩哔哩_bilibili</a> </p></blockquote><p>主要用于<mark style="background: #FFFF00;">解决 Bean 的循环依赖和重复创建问题</mark>。<br><img src="/images/Bean%E7%9A%84%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98.png"></p><h2 id="Bean-的三级缓存是什么"><a href="#Bean-的三级缓存是什么" class="headerlink" title="Bean 的三级缓存是什么"></a>Bean 的三级缓存是什么</h2><p>三级缓存分别如下：</p><ol><li><strong>singletonObjects：</strong> 当一个 <strong>Bean 被完全创建和初始化后</strong>，会被放入 singletonObjects 单例池缓存中。这个缓存存储的是<strong>完全初始化的 Bean 实例</strong>。</li><li><strong>earlySingleObjects</strong>：存放还没走完生命周期的 Bean，也就是半成品 Bean 对象。</li><li><strong>singletonFactories</strong>: 存储创建 Bean 的 ObjectFactory 工厂类对象的缓存。</li></ol><h2 id="为什么要加上三级缓存（怎么解决缓存依赖问题）"><a href="#为什么要加上三级缓存（怎么解决缓存依赖问题）" class="headerlink" title="为什么要加上三级缓存（怎么解决缓存依赖问题）"></a>为什么要加上三级缓存（怎么解决缓存依赖问题）</h2><p>从三级缓存的作用以及不足讲解。</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>singletonObjects ： 单例池缓存。</p><p><strong>作用</strong>：Bean 对象只会在这里保存一份对象，<strong>避免 Bean 重复创建</strong>，实现单例。</p><p><strong>缺点</strong>：<strong>不能解决循环依赖问题</strong> </p><p><img src="/images/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png"><br>在加载 A 的过程中想要使用 B 对象，结果单例池不存在，则需要先去创建 B 对象，然而 B 类的内部也需要 A，则会等 A 创建成功才能使用 A 对象，才能完成 B 的创建。造成了<strong>彼此等待</strong>的情况，也就是循环依赖。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>earlySingleObjects ： 二级缓存</p><p><strong>作用</strong>：存放半成品的 Bean 对象，循环依赖的另一个对象可以通过二级缓存得到半成品对象完成实例化，然后再返回给半成品对象完成实例化。</p><p>解决循环依赖的过程：</p><p><img src="/images/Bean%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.png"></p><blockquote><p>A 的对象创建，<strong>实例化的时候先把半成品的放到二级缓存</strong>，然后需要 B，先查单例池和二级缓存，发现没有 B 对象，然后就去创建 B，B 发现缓存中有半成品的 A 对象，就拿来进行 B 的创建，创建并初始化完成得到<strong>完全体 B 对象</strong>，然后返回给 A 进行下面的创建，就解决了循环依赖问题。</p></blockquote><p><strong>缺点</strong>：虽然看样子解决了问题，但是如果在有代理对象要创建的情况下，还是会有问题。</p><p>通过代理给对象进行功能增强，需要创建代理对象，如果不使用三级缓存，会<mark style="background: #FFFF00;">导致代理功能失效</mark>。比如下图：<br><img src="/images/Bean%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98.png"></p><blockquote><p>可以看到传递给 B 的 <strong>A 对象不是完整的被代理增强过</strong>的，而是半成品的 A 对象，这样 A 的增强就失效了。</p></blockquote><h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>singletonFactories ：存放创建 Bean 的 ObjectFactory 对象。</p><p><strong>作用</strong>：<strong>完全解决循环依赖</strong>的问题。</p><p>解决过程如下：<br><img src="/images/Bean%E7%9A%84%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98-1.png"></p><p>解决方法实际上就是通过三级缓存存储 ObjectFactory 对象（这个对象可以创建某个对象的<strong>代理对象或普通对象</strong>），当创建 A 对象的时候会先把它的 ObjectFactory 比如 Fa 对象放进三级缓存中，然后查询 B，发现没有 B，就去创建 B，同样放进一个 Fb 对象到缓存，然后发现需要 A 的对象，结果找到了 A 的工厂对象 Fa，这个工厂对象就看你<strong>是不是发生了循环依赖</strong>，如果是就会创建代理对象给 B，否则就给普通对象。剩下的过程略。</p><p>所以使用这种三级缓存就可以解决<strong>代理失效</strong>问题，完全解决循环依赖问题。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LC318：最长单词长度乘积</title>
      <link href="/2023/11/06/lc318-zui-chang-dan-ci-chang-du-cheng-ji/"/>
      <url>/2023/11/06/lc318-zui-chang-dan-ci-chang-du-cheng-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这题标准解法位运算，但是确实没想到可以这样做，记录一下。</p></blockquote><blockquote><p>Problem: <a href="https://leetcode.cn/problems/maximum-product-of-word-lengths/description/">318. 最大单词长度乘积</a></p></blockquote><p><img src="/../images/LC318%EF%BC%9A%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF.png"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li><p>暴力做法 167&#x2F;168 ,太🐕了，卡样例</p></li><li><p>位运算，从未设想的道路</p></li></ol><h1 id="位运算思路"><a href="#位运算思路" class="headerlink" title="位运算思路"></a>位运算思路</h1><p><strong>位运算做法，用一个int的数（2^31-1)也就是31位，完全可以存储26个字母对应的位数</strong>。</p><p>举例：一个字符串 abcd,如果用一个 int 的数 x，初始值为0，那它的二进制数就是 <code>000~~~</code>,然后通过位（或）运算把每个出现的字符都放在 x 的二进制数对应位置上，得到 <code>1111000~~</code>，如果再来一个字符串 <code>efgj</code>就得到了对应的数 y 的二进制数<code> 0000111001000 ~~~</code>，这两个二进制数作与运算，如果为0就说明没有重复字符，可以求积。</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><pre class="line-numbers language-Cpp" data-language="Cpp"><code class="language-Cpp">class Solution &#123;public:&#x2F;&#x2F;没想到过用位运算    int maxProduct(vector&lt;string&gt;&amp; words) &#123;            int len &#x3D; words.size();            vector&lt;int&gt; st(len);   &#x2F;&#x2F;每个字符串都对应一个“掩码”            for(int i &#x3D; 0; i &lt; len; i++)&#123;                string word &#x3D; words[i];                int size &#x3D; word.size();                for(int j &#x3D; 0; j &lt; size; j++)&#123;                    st[i] |&#x3D; 1 &lt;&lt; (word[j] - &#39;a&#39;);  &#x2F;&#x2F;出现的字符，映射到对应的位上                &#125;            &#125;            int ans &#x3D; 0;            for(int i &#x3D; 0; i &lt; len; i++)&#123;                for(int j &#x3D; i + 1; j &lt; len; j++)&#123;                    if((st[i] &amp; st[j]) &#x3D;&#x3D; 0)&#123;   &#x2F;&#x2F;不存在相同字符                        ans &#x3D; max(ans, (int)(words[i].size() * words[j].size()));                    &#125;                &#125;            &#125;            return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h1><pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>[]</span></div><code class="language-cpp">class Solution &#123;public:    &#x2F;&#x2F;暴力一发    &#x2F;&#x2F;没两个字符串，先判断是否有重复字符，有的话就跳过，没有就求积    bool check(string &amp;a, string &amp;b)&#123;        int st[26] &#x3D; &#123;0&#125;;   &#x2F;&#x2F;每个字符出现的个数        for(int i &#x3D; 0; i &lt; a.size(); i++)&#123;            st[a[i] - &#39;a&#39;]++;        &#125;        for(int i &#x3D; 0; i &lt; b.size(); i++)&#123;            if(st[b[i]-&#39;a&#39;] &gt; 0) return false;  &#x2F;&#x2F;只要已经存在了这个字符，就说明b与a重复了        &#125;        return true;    &#125;    int maxProduct(vector&lt;string&gt;&amp; words) &#123;        &#x2F;&#x2F;取子串        int len &#x3D; words.size();        int ans &#x3D; 0;        for(int i &#x3D; 0; i &lt; len; i++)&#123;            for(int j &#x3D; i + 1; j &lt; len; j++)&#123;                string a &#x3D; words[i]; string b &#x3D; words[j];                if(check(a, b))&#123;                    ans &#x3D; max(ans, (int)(a.size() * b.size()));                    &#x2F;&#x2F;长见识了，字符串长度返回的是 unsigned long int 类型，和int不匹配                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LC208：Trie前缀树</title>
      <link href="/2023/11/03/lc208-trie-qian-zhui-shu/"/>
      <url>/2023/11/03/lc208-trie-qian-zhui-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>算是对 Acwing 那题的复习了</p></blockquote><p>题目如下：<br><img src="/../images/LC208%EF%BC%9ATrie%E5%89%8D%E7%BC%80%E6%A0%91.png"></p><p><strong>思路就不说了，就是将字符串按照多叉树存储，插入和查询差不多，只要把每个字符串结尾的字符标记一下或者记录一下个数就行。</strong> </p><p>下面是代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Trie &#123;public:    static const int N &#x3D; 100010;    int son[N][26] &#x3D; &#123;0&#125;;  &#x2F;&#x2F;son[1][2] &#x3D; 3; 说明节点1有一个节点3的儿子字符C（0-25）    int cnt[N] &#x3D; &#123;0&#125;; &#x2F;&#x2F;存以当前节点为结尾的字符串有多少个    int idx &#x3D; 0;  &#x2F;&#x2F;存节点序号    Trie() &#123;    &#125;    void insert(string word) &#123;        int p &#x3D; 0;  &#x2F;&#x2F;0是所有节点的根节点        int size &#x3D; word.size();        for(int i &#x3D; 0; i &lt; size; i++)&#123;            int u &#x3D; word[i] - &#39;a&#39;;            if(!son[p][u]) son[p][u] &#x3D; ++idx;  &#x2F;&#x2F;没有值为这个字符的子节点就创建并编号            p &#x3D; son[p][u];  &#x2F;&#x2F;并且就移动到孩子节点,进行下一个字符的插入        &#125;        cnt[p]++;    &#125;    bool search(string word) &#123;        int p &#x3D; 0;        int size &#x3D; word.size();        for(int i &#x3D; 0; i &lt; size; i++)&#123;            int u &#x3D; word[i]-&#39;a&#39;;            if(!son[p][u]) return false; &#x2F;&#x2F;字符断了，说明没有这个前缀单词            p &#x3D; son[p][u];  &#x2F;&#x2F;移动到孩子        &#125;        return cnt[p] &gt; 0;  &#x2F;&#x2F;以当前字符串结尾的单词存在，说明word存在    &#125;    &#x2F;&#x2F;自定义查询前缀    bool startsWith(string prefix) &#123;        int p &#x3D; 0;        int size &#x3D; prefix.size();        for(int i &#x3D; 0; i &lt; size; i++)&#123;            int u &#x3D; prefix[i]-&#39;a&#39;;            if(!son[p][u]) return false; &#x2F;&#x2F;字符断了，说明没有这个前缀单词            p &#x3D; son[p][u];  &#x2F;&#x2F;移动到孩子        &#125;        return true;  &#x2F;&#x2F;到达了当前字符串的尾部，说明存在    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVCC概念和实现原理</title>
      <link href="/2023/10/28/mvcc-gai-nian-he-shi-xian-yuan-li/"/>
      <url>/2023/10/28/mvcc-gai-nian-he-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<blockquote><p>即多版本并发控制，此文会根据以下几个点说明</p><ul><li>相关概念</li><li>当前读</li><li>快照读</li><li>多版本并发控制原理</li></ul></blockquote><h2 id="MVCC-基本概念"><a href="#MVCC-基本概念" class="headerlink" title="MVCC 基本概念"></a>MVCC 基本概念</h2><p>Multi-Version Concurrency Control 多版本并发控制。用于在<strong>多个并发事务同时读写数据库时保持数据的一致性和隔离性</strong>，是通过在每个数据行上维护多个版本的数据实现的。</p><p>如下先介绍当前读和快照读的概念。</p><h3 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h3><p>读取的是<strong>当前的最新版本数据</strong>，读取时要保证其他并发事务不能修改当前记录，所以会对读取的数据进行加锁。</p><blockquote><p>两种方式都是当前读：</p><ul><li>select — lock in share mode (共享锁) </li><li>select — for update&#x2F; insert&#x2F;delete （排他锁）</li></ul></blockquote><p>举个例子（难得自己操作了一次〒▽〒）：</p><blockquote><p>Cmd 下操作 mysql 数据库的命令参考：<a href="https://blog.csdn.net/weixin_43042683/article/details/106779060">mysql-cmd</a> </p></blockquote><ol><li><p>数据准备：一个 dept 表，如下<img src="/images/dept%E8%A1%A8.png"></p></li><li><p>开启两个事务，一个进行查询，一个进行更新；由于默认的 <strong>RR</strong> 隔离级别，第一个事务多次查询不会读取到第二个事务的更新提交内容。<img src="/images/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png"></p><blockquote><p>这样就实现了可重复读，如果使用当前读的命令，第一个事务就能读取到最新的更新后数据。</p></blockquote></li><li><p>使用 <code>lock in share mode</code>; 命令，可以看到显示了最新数据<img src="/images/%E5%BD%93%E5%89%8D%E8%AF%BB%E5%91%BD%E4%BB%A4.png"></p></li><li><p>使用 <code>for update</code> 同样可以<img src="/images/for%20update.png"></p></li></ol><h3 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h3><p>就是<strong>正常的不加锁的 select 查询</strong>，读取到的数据是<strong>可见的版本</strong>，有可能是历史数据，且因为不加锁，不会阻塞其他操作。</p><blockquote><p>读可见的版本，比如 RR 级别下的，同一个事务内的多次查询不会读取到其他事务更新提交的数据。</p></blockquote><h4 id="不同隔离级别下的快照读"><a href="#不同隔离级别下的快照读" class="headerlink" title="不同隔离级别下的快照读"></a>不同隔离级别下的快照读</h4><p>RC 和 RR 隔离级别下的生成快照读的方式不同，与隔离级别的特性有关。</p><ol><li>RC 读已提交：<strong>每次 select 查询都会生成一个快照读</strong>，所以就可以在同一个事务内读取到其他事务更新的最新数据，但是会造成不可重复读。</li><li>RR 可重复读：<strong>只有第一次 select 查询时会生成一个快照读</strong>，以后是 select 都会读取这个快照读，所以结果都一样，保证可重复读。</li></ol><h2 id="MVCC-实现原理"><a href="#MVCC-实现原理" class="headerlink" title="MVCC 实现原理"></a>MVCC 实现原理</h2><p>主要实现需要依靠<strong>三个隐藏字段</strong>、<strong>undo log</strong> 和 <strong>readview</strong>。</p><h3 id="三个隐藏字段"><a href="#三个隐藏字段" class="headerlink" title="三个隐藏字段"></a>三个隐藏字段</h3><p>下面是一张简单的只有三列的数据库表；</p><table><thead><tr><th>id</th><th>age</th><th>name</th><th>DB_TRX_ID</th><th>DB_ROLL_PTR</th><th>DB_ROW_ID</th></tr></thead><tbody><tr><td>1</td><td>18</td><td>wzc</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>19</td><td>abc</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>后面的三列标题即为隐藏字段</p><ol><li><strong>DB_TRX_ID</strong>：最近修改事务 ID，表示插入或修改这条数据的最后一个事务的 ID。</li><li><strong>DB_ROLL_PTR</strong>：回滚指针，执行这条记录的上一个版本，配合 undo log 日志完成回滚。</li><li><strong>DB_ROW_ID</strong>: 实际上就是在表中没有主键时且没有唯一非空索引时会生成的隐藏字段，可能用于生成聚集索引。<blockquote><p>在聚集索引那篇文章我们已经见过了。</p></blockquote></li></ol><h3 id="Undo-log-日志"><a href="#Undo-log-日志" class="headerlink" title="Undo log 日志"></a>Undo log 日志</h3><p>在执行 insert、update、delete 语句时会记录旧数据的日志，便于数据回滚的日志。</p><blockquote><p>关于 undo log 的存储机制和工作原理，这篇文章讲的很好：<a href="https://blog.csdn.net/Weixiaohuai/article/details/117867353">MySQL回滚日志（undo log）总结</a> </p></blockquote><h4 id="undo-log-版本链"><a href="#undo-log-版本链" class="headerlink" title="undo log 版本链"></a>undo log 版本链</h4><p><mark style="background: #FFFF00;">不同事务或者相同事务的对同一记录的修改，会导致该记录的 undo log 生成一个版本链。</mark> </p><blockquote><p>（链表头部是最新的旧纪录，尾部是最早的旧纪录）</p></blockquote><p>假设现在有一个场景：<br><img src="/images/undo%20log%E5%9B%9E%E6%BB%9A%E9%93%BE.png"></p><ol><li>当一个事务插入一条数据时，在数据库中就会存储一条行数据，其隐藏字段 <strong>TRX_ID 初始化为 1，回滚指针 ROLL_ID 为 NULL</strong>（未指向任何上一版本）</li><li>当其他事务更新这条数据前，数据库会先把这条数据存放到 undo log 中，且<strong>将修改后的数据的事务 ID 修改为当前正在操作的事务 ID， ROLL_ID 指向 undo log 中这条数据的存储地址</strong>用于后续回滚操作。</li><li>随着更新操作增多，就形成了版本链。</li></ol><h3 id="Readview"><a href="#Readview" class="headerlink" title="Readview"></a>Readview</h3><p>读视图，是<mark style="background: #FFFF00;">快照读查询 SQL 语句执行时读取哪个版本数据的依据</mark>，记录和维护当前未提及的活跃事务 ID。</p><blockquote><p>就靠这个实现每个事务只能读取到当前事务所处隔离级别内可以读取到的数据。</p></blockquote><h4 id="Readview-规则"><a href="#Readview-规则" class="headerlink" title="Readview 规则"></a>Readview 规则</h4><p><img src="/images/readview%E8%A7%84%E5%88%99.png"><br>其中的四个字段为：<br>（1）<strong>trx_id</strong>: 当前数据的事务 ID（就是最近更新该数据的事务 id）<br>（2）creator_trx_id 创建当前 readview 的事务 ID<br>（3）<strong>min_trx_id</strong>: 当前<strong>活跃事务集合</strong> <strong>trx_ids</strong> 中的最小事务 id<br>（4）max_trx_id：是 <strong>readview 建立时预先生成的 id</strong>，值为集合中的最大 id + 1 。 </p><h4 id="实例一：RC-隔离级别下的-readview"><a href="#实例一：RC-隔离级别下的-readview" class="headerlink" title="实例一：RC 隔离级别下的 readview"></a>实例一：RC 隔离级别下的 readview</h4><p>在 RC 隔离级别下，每次查询操作都会创建一个 readview ，<strong>数据库会根据该 readview 的字段值与待查询数据的 undo log 版本链中的数据进行比较</strong>，以上述规则进行判断当前事务可以读取哪条数据。<br><img src="/images/readview%E5%9C%A8RC%E7%BA%A7%E5%88%AB%E4%B8%8B.png"><br>如图，最终发现事务 5 的第一次查询操作只能读取 undo log 中事务 id 为 2 的数据。</p><blockquote><p>也可以看到和左上角时序图的效果相同，事务 2 提交但是事务 3 未提交，所以只能读取到事务 2 修改的数据。</p></blockquote><h4 id="实例二：RR-隔离级别下的-readview"><a href="#实例二：RR-隔离级别下的-readview" class="headerlink" title="实例二：RR 隔离级别下的 readview"></a>实例二：RR 隔离级别下的 readview</h4><p><strong>同一个事务中的 readview 只会在第一次查询时创建，后续查询复用该 readview。</strong><br><img src="/images/RR%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84readview.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Mysql </tag>
            
            <tag> MVCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/26/innondb-jia-gou-he-shi-wu-yuan-li/"/>
      <url>/2023/10/26/innondb-jia-gou-he-shi-wu-yuan-li/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL性能分析和优化</title>
      <link href="/2023/10/26/sql-xing-neng-fen-xi-he-you-hua/"/>
      <url>/2023/10/26/sql-xing-neng-fen-xi-he-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h2><p>进行 SQL 优化首先需要了解 sql 语句执行的情况，下面有三种分析方式。</p><p>下面三种重要性不高，还是主要看 explain：<a href="https://kris20030907.gitee.io/2023/10/25/mysql-zhi-xing-ji-hua-fen-xi-explain-ming-ling/">Mysql执行计划分析 | KTnoobStation (gitee.io)</a> </p><h4 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a>查看执行频次</h4><p>通过模糊查询语句判断当前数据库哪些操作是使用更多的（一般是查询最多）<br><img src="/images/SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E6%89%A7%E8%A1%8C%E9%A2%91%E6%AC%A1.png"></p><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志会记录所有执行时间超过指定参数的 sql 语句。</p><blockquote><p>默认未开启，可在配置文件中开启。</p></blockquote><p><img src="/images/SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97.png"></p><h3 id="show-profiles"><a href="#show-profiles" class="headerlink" title="show profiles"></a>show profiles</h3><p>主要可以记录所有 sql 语句在<strong>各个阶段</strong>的所花费的时间。</p><blockquote><p>初始化，执行等等的过程耗费的时间。</p></blockquote><h2 id="SQL性能优化"><a href="#SQL性能优化" class="headerlink" title="SQL性能优化"></a>SQL性能优化</h2><p>包括插入优化、主键优化、order by 排序优化、group by 分组优化、limit 分页优化、count 计数优化、update 更新优化。</p><blockquote><p>为避免长篇大论，简要概括每一条</p></blockquote><h3 id="insert-插入优化"><a href="#insert-插入优化" class="headerlink" title="insert 插入优化"></a>insert 插入优化</h3><p>即在<strong>大量数据插入的场景</strong>怎么优化的问题。</p><ol><li>尽量<strong>采用批量插入</strong>，减少 insert 语句调用次数，如果量太多，可以分批次的批量查询。</li><li><strong>手动提交事务</strong>，减少事务的开启和关闭次数。<blockquote><p>执行一系列 insert 语句前开启事务，结束后手动提交。</p></blockquote></li><li>按照主键的顺序插入。（涉及主键优化）<blockquote><p>在待插入数据量极大的时候，可以采用 Mysql 的 load 命令（从文件直接加载到数据库表中）。</p></blockquote></li></ol><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>聚集索引一般都是根据主键建立的，因此主键优化实际上就是优化聚集索引的建立。</p><ol><li><p>插入数据时，尽量按照顺序插入，如数据库自增主键 AUTO_INCREMENT；</p><blockquote><p>即插入时的数据主键值要是有序的，否则会产生<strong>页分裂</strong>和<strong>指针重指向</strong>的现象，导致效率下降。</p><blockquote><p>页分裂，涉及到 InnoDB 的底层存储结构。参考 <a href="InnonDB%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86.md">InnonDB架构和事务原理</a> </p></blockquote></blockquote></li><li><p>在满足业务要求的前提下，降低主键的长度。</p></li></ol><h3 id="Order-By-排序优化"><a href="#Order-By-排序优化" class="headerlink" title="Order By 排序优化"></a>Order By 排序优化</h3><p>尽量将已经<strong>存在有序索引的字段</strong>作为排序字段，这样可以避免排序操作，直接按照索引顺序返回数据。</p><blockquote><p>建立索引时可以指定该字段的顺序，<code>create index index_name on table_name(age asc)</code> 联合索引同理，但是要注意使用 order by 命令时指定的顺序要和创建索引时的顺序相同，否则索引失效，还会走 filesort 。</p></blockquote><ul><li>通过 explain 命令得到的 extra 中可能会提示 using filesort 即表示读取到数据后，会在排序缓冲区 sort buffer 先排序，后面才会返回数据。</li><li>而使用索引就是 using index，不需要排序。</li></ul><blockquote><p>Group by 分组优化，也是尽量使用索引作为分组字段。否则会造成临时表的创建，导致效率降低；对应 using temporal</p></blockquote><h3 id="limit-分页查询优化"><a href="#limit-分页查询优化" class="headerlink" title="limit 分页查询优化"></a>limit 分页查询优化</h3><p>limit 分页语法：<code>select * from table_name limit 0, 10;</code> 指取第一条数据开始的前10 条数据。</p><h4 id="会出现的问题"><a href="#会出现的问题" class="headerlink" title="会出现的问题"></a>会出现的问题</h4><p>在大数据量情况下，比如查询第 5000000 以后的前 10 条数据，会特别慢。</p><blockquote><p>因为 limit 5000000, 10 ，数据库需要排序前 5000010 条记录并只返回这 10 条数据，其他查询记录会丢失。</p></blockquote><h4 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h4><p>使用覆盖索引 + 子查询。比如查询已经存在的聚集索引（或其他的覆盖索引），<code>select id from table_name order by id limit 5000000, 10;</code>  查询到这些 id 之后，外面再套一个父查询（根据 id 查数据），这样就可以极大减少需要查询的数据量，以提高效率。</p><blockquote><p>例：<code>select s.* from tb_sku s, (select id from tb_sku order by id limit 9000000,10) a where s.id = a.id; </code> </p></blockquote><h3 id="count-计数优化"><a href="#count-计数优化" class="headerlink" title="count 计数优化"></a>count 计数优化</h3><p>count 计数语法：<code>select count(*) from table_name</code> </p><h4 id="基于引擎实现产生的问题"><a href="#基于引擎实现产生的问题" class="headerlink" title="基于引擎实现产生的问题"></a>基于引擎实现产生的问题</h4><p>MyIsam 引擎会将一个表的行数存在磁盘中，因此使用 count 效率很高。<br>InnoDB 引擎是将数据读出来，然后再累计计数。</p><blockquote><p>Count 的累计计数有几种情况：</p><ul><li><code>count (*)</code> ,记录总行数，由于不取具体数据，只是计数，效率最高</li><li>count (具体字段)，取具体字段值，如果没加 NOT NULL 约束则判断是否为空 NULL，如果不是则按行计数+1</li><li>count (主键)，取主键值，按行直接累加（主键一定非空）</li></ul><p>InnoDB 引擎对<strong>count</strong>计数做了优化，会选用数据量较小的非聚簇索引进行统计。所以效率：<strong>count(*) ≈ count(常量) &gt; count(id) &gt; count(字段)</strong>  </p></blockquote><blockquote><p>两种引擎在大数据量的情况下，效率差距巨大。</p></blockquote><h4 id="优化方式-1"><a href="#优化方式-1" class="headerlink" title="优化方式"></a>优化方式</h4><p>尽量使用 <code>count (*)</code>, 效率最高。</p><blockquote><p>可参考掘金文章：<a href="https://juejin.cn/post/7130276921534840845">MySQL select count(*)计数很慢，有没有优化方案？ - 掘金 (juejin.cn)</a> </p></blockquote><h3 id="Update-更新优化"><a href="#Update-更新优化" class="headerlink" title="Update 更新优化"></a>Update 更新优化</h3><p>倒也不是优化，但是要规避一些操作；比如更新时，<strong>条件中尽量使用建立了索引的字段</strong>。</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul><li>当条件字段为有索引的字段，如主键值聚集索引或非聚集索引，开启事务后，Mysql 只会给<strong>这一行索引的数据</strong>加“<strong>行级锁</strong>”，这时候其他事务对这个表的其他数据更新或其他操作不会被阻塞。</li><li>当条件字段无索引，Mysql 会给这个表加“<strong>表级锁</strong>”，其他事务对该表的操作会被阻塞导致并发性能下降。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>擅用索引(￣︶￣*))<br><img src="/images/SQL%E6%80%A7%E8%83%BD%E5%8C%96.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql索引</title>
      <link href="/2023/10/26/suo-yin-chong-yao/"/>
      <url>/2023/10/26/suo-yin-chong-yao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考文章: javaGuide <a href="https://javaguide.cn/database/mysql/mysql-index.html">Mysql索引</a> </p></blockquote><h2 id="索引概览"><a href="#索引概览" class="headerlink" title="索引概览"></a>索引概览</h2><p>索引是一种用于<mark style="background: #FFFF00;">快速查询和检索数据的数据结构</mark>，本质是一种排序好的数据结构。</p><h3 id="索引底层数据结构"><a href="#索引底层数据结构" class="headerlink" title="索引底层数据结构"></a>索引底层数据结构</h3><p>索引的底层数据结构包括：B 树，B+树，红黑树，Hash 等，不管是 InnoDB 还是 MyIasm 存储引擎都是采用的 <strong>B＋树</strong>。<br><img src="/images/a948f6cc7342ee12b961f788281e2489.png"><br><img src="/images/d4417fc82edaa5134c034716c756e498.png"><br><img src="/images/cde9eeed9593883bce6e81dbe85bccba.png"><br>B树和 B + 树 区别： B树每个节点都存数据，矮胖树 ；B+树只在叶子节点存储，且可以横向查找范围内的元素</p><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><ol><li>优点</li></ol><ul><li>使用索引可以极大的加快数据库检索数据的效率（减少了需要查询的数据量）</li></ul><ol start="2"><li>缺点</li></ol><ul><li><strong>建立索引和维护索引的过程太耗时</strong>。如果需要建立索引的数据量很大，建立索引的过程和进行数据更新操作时的索引动态更新过程的时间消耗是很大的。</li><li>建立索引还需要占用很大的<strong>物理存储空间</strong>。<blockquote><p>在数据量不是很大的情况下，建立索引不一定比不加索引效率更高。</p></blockquote></li></ul><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>也称聚集和非聚集（二级索引）。</p><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p><strong>聚簇索引</strong>：将索引和数据都放到一起的索引，叶子节点存储行记录（数据）。</p><blockquote><p>必须有，因为要存储行数据，且只有一个。</p></blockquote><p><strong>选取原则</strong>：如果存在主键，则主键索引就是聚簇索引。如果没有主键则将一个唯一索引（UNIQUE 修饰）作为聚簇索引。再没有，其底层就会创建一个虚拟的隐藏 rowid 作为聚集索引。</p><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>数据和索引分开存储，叶子节点只存储这条数据的主键值。<br>如下图，聚集索引和非聚集索引的案例：<br><img src="/images/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.png"></p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>覆盖索引： 就是查询的时候使用索引进行查询，返回的列必须在索引中全部找到。<br>例子： </p><ol><li>聚集索引，根据 id 建立的索引，能够返回所有列，因此是覆盖索引</li><li><mark style="background: #FFFF00;">非聚集索引不一定不是覆盖索引</mark>： 如果根据 name 建立的索引，只需要查询 id 和 name ，那么也是覆盖索引。</li><li>如果查询的列在一个非聚集索引中查不完，那就需要进行<strong>回表查询</strong>。<blockquote><p>因此最好少使用 select * 查询，避免回表查询。</p></blockquote></li></ol><h2 id="索引的-sql-语法"><a href="#索引的-sql-语法" class="headerlink" title="索引的 sql 语法"></a>索引的 sql 语法</h2><p>包括创建、查看、删除索引。</p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><img src="/images/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.png"></p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><img src="/images/%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA.png"></p><ol><li>这里加上 UNIQUE 就是唯一索引，加上 FULLTEXT 就是全文索引，不加就是常规索引。</li><li>ON 后面的表名 + 括号，指明了需要建立索引的列，如果是一个属性，就是单列索引，<strong>多列就是联合索引</strong>（组合索引）。</li></ol><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><p><code>show INDEX FROM table_name</code> </p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p><code>DROP INDEX index_name ON table_name</code> 即删除某个表 table_name 的索引 index_name</p><h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h2><p>主要包括三种情况：<strong>违反最左前缀法则、索引列运算、OR 连接的条件</strong>；</p><h3 id="最左前缀法则（主要）"><a href="#最左前缀法则（主要）" class="headerlink" title="最左前缀法则（主要）"></a>最左前缀法则（主要）</h3><p>概念：如果使用了联合索引，查询时会先从索引最左边的字段开始查询，并且不能跳过索引中的字段。</p><blockquote><p>觉得不太清晰可以去看 JavaGuide ：<a href="https://javaguide.cn/database/mysql/mysql-index.html#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99">索引最左前缀</a> </p></blockquote><p><strong>准备一个联合索引</strong><br>一个根据专业 pro、年龄 age、状态 status 建立的索引。（假设 pro 是索引最左列）</p><p><strong>失效情况</strong> </p><blockquote><p>下面失效情况都统一为查询时的条件出现的问题，可以用 explain 分析。</p></blockquote><ol><li><p>索引全部失效：查询条件只查询了除 pro 以外的列，比如组合 (age) (status) (age, status) 都不会使用到索引。</p></li><li><p>索引部分失效：如果是跳跃字段：如 (pro, status)，中间没有 age，查询只会走 pro 的索引，而不会走 status 索引。</p><blockquote><p>注意，只要包括最左列即可使用到索引，与条件中设置的顺序无关，如组合 (age, status, pro)顺序不是 pro 首位，但是也会使用到整个索引。</p></blockquote></li><li><p>范围查询条件（如 &gt; 或 &lt;）之后的字段不会走索引，如 (pro, age &gt; 10, status)只有 status 不会走索引。</p><blockquote><p>但是对于 <strong><code>&gt;=</code><strong>、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配。</p></blockquote></li></ol><h3 id="索引列上的运算"><a href="#索引列上的运算" class="headerlink" title="索引列上的运算"></a>索引列上的运算</h3><p>在索引列上进行计算、函数、类型转换等操作;</p><blockquote><ul><li>比如取子串函数 substring、数值运算 a + b、连接函数 concat 等。</li><li>还有类型转换：包括”隐式类型转换”，如不加引号的字符串，可能会进行类型转换导致索引失效。详情参考：<a href="https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html#sql-%E6%B5%8B%E8%AF%95">MySQL隐式转换造成索引失效</a><br><img src="/images/%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png"></li></ul></blockquote><h3 id="使用-OR-条件"><a href="#使用-OR-条件" class="headerlink" title="使用 OR 条件"></a>使用 OR 条件</h3><p>查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</p><h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><ol><li>字符串首部模糊匹配，如 like ‘%abc’</li><li>IN 的范围过大，导致索引失效</li></ol><h2 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h2><p>从索引建立和使用来优化查询效率。</p><ol><li><p>针对<strong>数据量大，且查询较频繁</strong>的表建立索引</p></li><li><p>将经常作为查询条件、分组条件、排序条件的字段建立索引</p></li><li><p>尽量使用唯一索引，提高索引使用效率。（唯一索引查询到的数据只有一条）</p></li><li><p>如果要根据字符串类型的字段建立索引，如果过长可以建立”<strong>前缀索引</strong>“，减少空间的使用。</p><blockquote><p>前缀索引：以某个字段字符串的前几个字符为准建立索引，语法：<code>create index index_name on table_name(str(n))</code> n 为截取的字符个数</p></blockquote></li><li><p>如果涉及到多个字段的查询，尽量建立<strong>联合索引</strong>，实现覆盖索引，避免回表查询，提高效率。</p></li><li><p>避免索引冗余：多个索引的功能有重复，造成空间浪费。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql执行计划分析</title>
      <link href="/2023/10/25/mysql-zhi-xing-ji-hua-fen-xi-explain-ming-ling/"/>
      <url>/2023/10/25/mysql-zhi-xing-ji-hua-fen-xi-explain-ming-ling/</url>
      
        <content type="html"><![CDATA[<blockquote><p>可参考：<a href="https://javaguide.cn/database/mysql/mysql-query-execution-plan.html">https://javaguide.cn/database/mysql/mysql-query-execution-plan.html</a>  </p></blockquote><p>优化 sql 语句首先就要知道 sql 执行的情况，则可使用 explain 命令。</p><blockquote><p>其他 sql 性能分析方式可以看：<a href="https://kris20030907.gitee.io/2023/10/26/sql-xing-neng-fen-xi-he-you-hua/">SQL性能分析和优化 | KTnoobStation (gitee.io)</a> </p></blockquote><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p><strong>执行计划</strong>是一条 sql 语句经过 <strong>Mysql 查询优化器</strong>优化后选择的具体执行方式。</p><blockquote><p>使用 explain 命令可以获得 sql 语句具体的执行计划，如查询表的顺序、是否使用了索引，索引的类型，使用了什么索引、每个表被查询了多少条数据等信息。</p></blockquote><h3 id="explain-命令的使用和使用结果"><a href="#explain-命令的使用和使用结果" class="headerlink" title="explain 命令的使用和使用结果"></a>explain 命令的使用和使用结果</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>直接 explain + SQL 语句，CRUD 类型的操作都可支持。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>假设使用命令：</p><pre class="line-numbers language-none"><code class="language-none">mysql&gt; explain SELECT * FROM dept_emp WHERE emp_no IN (SELECT emp_no FROM dept_emp GROUP BY emp_no HAVING COUNT(emp_no)&gt;1);+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+| id | select_type | table    | partitions | type  | possible_keys   | key     | key_len | ref  | rows   | filtered | Extra       |+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+|  1 | PRIMARY     | dept_emp | NULL       | ALL   | NULL            | NULL    | NULL    | NULL | 331143 |   100.00 | Using where ||  2 | SUBQUERY    | dept_emp | NULL       | index | PRIMARY,dept_no | PRIMARY | 16      | NULL | 331143 |   100.00 | Using index |+----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="explain-结果的一些重要字段"><a href="#explain-结果的一些重要字段" class="headerlink" title="explain 结果的一些重要字段"></a>explain 结果的一些重要字段</h4><p>包括：id、select_type、table、type、possible_keys、key、rows、extra 这些。下面简单说明一下。</p><ol><li><p>Id ：标识整个查询中 SELELCT 语句的顺序。</p></li><li><p>Select_type：查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询</p><blockquote><p>可能的取值：<br><strong>SIMPLE</strong>：简单查询，不包含 UNION 或者子查询。<br><strong>PRIMARY</strong>：如果包括子查询，则主查询被这个修饰。<br><strong>SUBQUERY</strong>：子查询中的第一个 SELECT。<br><strong>UNION</strong>：联合查询语句中，UNION 之后出现的 SELECT。</p></blockquote></li><li><p>Table：查询用到的表。</p></li><li><p><strong>Type</strong>：查询执行的连接类型，是<strong>全表查询，还是索引查询</strong>等。</p></li><li><p>Possible_keys：可能会用到的索引，像上面案例中可能会用到主键索引 PRIMARY 和 dept_no 索引。</p></li><li><p>Key：实际用到的索引。</p></li><li><p>Rows：即查询到的数据行数。</p></li><li><p><strong>extra（重要）</strong>：说明数据库执行该 sql 语句具体是干了什么，比如使用了索引就是 using index, 使用了条件查询但是没用到索引：using where 等</p><blockquote><p>其他取值：<br>Using filesort：在排序时使用了外部的索引排序，没用到表内索引进行排序。<br>Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。<br>Using index：表明查询使用了覆盖索引，不用回表，查询效率非常高。Using index condition：表示查询优化器选择使用了索引条件下推这个特性。<br>Using where：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMapPut方法</title>
      <link href="/2023/10/13/hashmap-put-fang-fa/"/>
      <url>/2023/10/13/hashmap-put-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>先上流程图<br><img src="/images/HashMap%20Put%E6%96%B9%E6%B3%95.png"></p><h3 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h3><ol><li>判断键值对 table 数组(存数据的) 是不是空的，如果是需要进行初始化扩容 resize 为 16 大小，且阈值为 12</li><li>如果 table 非空，根据 key 进行哈希运算得到在数组中的（桶）索引，判断该索引的节点是不是空的，如果是空的则直接插入；（<code>tab[i] = newNode(hash, key, value, null);</code>）是新增节点，而不是赋值。</li></ol><ul><li>调用 put 方法时会调用底层的 putVal 方法<pre class="line-numbers language-java" data-language="java"><code class="language-java">public V put(K key, V value) &#123;        return putVal(hash(key), key, value, false, true);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>可以看到确实使用 hash 函数计算 key 对应的索引</li></ul><ol start="3"><li>如果该索引的节点不为空，则判断该位置 table[i]存的是不是红黑树节点</li></ol><ul><li>是红黑树节点：直接按照红黑树的插入方式插入该节点</li><li>不是红黑树节点：遍历链表</li></ul><ol start="4"><li><p>遍历链表时，如果和当前待插入节点 key 一样的链表节点存在，则直接覆盖 value；如果不同则在尾部插入新节点；</p><blockquote><p>拓展：Jdk 8 之后采用尾插法，之前采用头插法, 参考：<a href="HashMap%E6%8B%89%E9%93%BE%E6%B3%95%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98.md">HashMap拉链法可能出现的问题</a> </p></blockquote></li><li><p>链表新增节点后，需要判断当前链表节点值是否超过了 8 个，如果超过，需要将该链表转换为红黑树；</p></li><li><p>最后节点插入完毕，判断当前数组中所有节点数是否大于阈值 threshold，如果大于还需要最后调用一次 resize ()进行扩容；</p><blockquote><p>扩容过程参考：<a href="HashMap%E6%89%A9%E5%AE%B9.md">HashMap扩容</a></p></blockquote></li></ol><p>最后附上 putVal 完整源码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)            n &#x3D; (tab &#x3D; resize()).length;        if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)            tab[i] &#x3D; newNode(hash, key, value, null);        else &#123;            Node&lt;K,V&gt; e; K k;            if (p.hash &#x3D;&#x3D; hash &amp;&amp;                ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))                e &#x3D; p;            else if (p instanceof TreeNode)                e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else &#123;                for (int binCount &#x3D; 0; ; ++binCount) &#123;                    if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;                        p.next &#x3D; newNode(hash, key, value, null);                        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st                            treeifyBin(tab, hash);                        break;                    &#125;                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))                        break;                    p &#x3D; e;                &#125;            &#125;            if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key                V oldValue &#x3D; e.value;                if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)                    e.value &#x3D; value;                afterNodeAccess(e);                return oldValue;            &#125;        &#125;        ++modCount;        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA集合 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股票买卖V</title>
      <link href="/2023/10/05/gu-piao-mai-mai-v/"/>
      <url>/2023/10/05/gu-piao-mai-mai-v/</url>
      
        <content type="html"><![CDATA[<p>在原来几种的基础上多加了一个”冷冻期”的概念，即前一天卖出，今天就不能买入股票。</p><blockquote><p>Acwing 和 Leetcode 本题题干一样，下面以 Acwing 为例。</p></blockquote><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/images/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96V.png"></p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先可以先回顾一下&lt;[股票买卖 IV](<a href="https://kris20030907.gitee.io/2023/10/03/mai-mai-gu-piao-iv-zhuang-tai-ji-dp/">买卖股票IV–状态机DP | KTnoobStation (gitee.io)</a>)&gt;的状态表示, 本题还没限制交易笔数，所以还是有所区别的。</p><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><blockquote><p>根据题目要求，有冷藏期，则可将有货和无货两种状态进行进一步的划分。</p></blockquote><p><img src="/images/%E8%82%A1%E7%A5%A8V-%E7%8A%B6%E6%80%81%E5%88%92%E5%88%86.png"></p><blockquote><p>下面以上面的状态编号进行代指</p></blockquote><p>其中 1 不能买入商品，2 可以买入商品。</p><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p><img src="/images/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96V-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png"><br>状态 0 ： 有货时，可以选择不卖，也可以选择卖出 <code>+ w[ i ]</code>，则状态转为 1 ；<br>状态 1 ： 无货第一天，无法买入股票，自动转移到无货 &gt;&#x3D; 2 天的状态<br>状态 2 ： 无货第二天，可以买入，也可以不买，买的话则 <code>- w[ i ]  </code> 到状态 0 ；</p><h4 id="状态方程"><a href="#状态方程" class="headerlink" title="状态方程"></a>状态方程</h4><p>现在只有状态表示和天数两个因素，则二维数组 <code>f[N][M]</code> 即可 N 为天数，M 为状态</p><blockquote><p>N &#x3D; 100010; M &#x3D; 3;</p></blockquote><p><mark>注意出入口，哪条边能到达当前状态</mark><br>状态 0 的方程： <code>f[i][0] = max(f[i-1][0], f[i-1][2] - w[i]</code><br>状态 1 的方程： <code>f[i][1] = f[i-1][0] + w[i]</code><br>状态 2 的方程： <code>f[i][2] = max(f[i-1][2], f[i-1][1])</code><br>至此，方程写出来就好写代码了；</p><p>初始化的话：<code>dp[0][0] = dp[0][1] = -INF;</code> <code>dp[0][2] = 0;</code> 即第0 天不存在 </p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;import java.io.*;class Main&#123;    public static void main(String[] args) throws Exception&#123;        Scanner sc &#x3D; new Scanner(System.in);        int n &#x3D; sc.nextInt();                int[] w &#x3D; new int[n+1];        int[][] dp &#x3D; new int[n+1][3];                for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;            w[i] &#x3D; sc.nextInt();        &#125;                dp[0][0] &#x3D; dp[0][1] &#x3D; -0x3f3f3f3f;        dp[0][2] &#x3D; 0;                for(int i &#x3D; 1; i &lt;&#x3D; n;i++)&#123;            dp[i][0] &#x3D; Math.max(dp[i-1][0], dp[i-1][2] - w[i]);            dp[i][1] &#x3D; dp[i-1][0] + w[i];            dp[i][2] &#x3D; Math.max(dp[i-1][1], dp[i-1][2]);        &#125;        System.out.println(Math.max(dp[n][1], dp[n][2]));  &#x2F;&#x2F;最后一定是无货的            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>附上 leetcode 上的解答:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution &#123;    static final int INF &#x3D; 0x3f3f3f3f;    public int maxProfit(int[] prices) &#123;        int n &#x3D; prices.length;        if(n &#x3D;&#x3D; 1) return 0;                int[][] dp &#x3D; new int[n+1][3];                dp[0][0] &#x3D; dp[0][1] &#x3D; -INF;        dp[0][2] &#x3D; 0;                for(int i &#x3D; 1; i &lt;&#x3D; n;i++)&#123;            dp[i][0] &#x3D; Math.max(dp[i-1][0], dp[i-1][2] - prices[i-1]);            dp[i][1] &#x3D; dp[i-1][0] + prices[i-1];            dp[i][2] &#x3D; Math.max(dp[i-1][1], dp[i-1][2]);        &#125;        return Math.max(dp[n][1], dp[n][2]); &#x2F;&#x2F;最后一定是无货的    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优惠券</title>
      <link href="/2023/10/04/you-hui-quan/"/>
      <url>/2023/10/04/you-hui-quan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要根据黑马的教学目标进行学习，优惠券秒杀，分布式锁以及超卖问题等的具体实践。</p></blockquote><blockquote><p>具体包括：</p></blockquote><ul><li><a href="#%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%20ID%20%E7%9A%84%E5%AE%9E%E7%8E%B0">全局唯一 ID 的实现</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%20ID%EF%BC%9F">如何实现全局唯一 ID？</a></li></ul></li><li><a href="#%E5%AE%9E%E7%8E%B0%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95%E5%8A%9F%E8%83%BD">实现优惠券秒杀下单功能</a> </li><li><a href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98">超卖问题</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%B6%85%E5%8D%96">为什么会出现超卖</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">解决方法</a></li><li><a href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E6%94%B9%E8%BF%9B-%E6%8F%90%E9%AB%98%E6%88%90%E5%8A%9F%E7%8E%87">乐观锁的改进-提高成功率</a></li></ul></li><li><a href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95">一人一单</a><ul><li><a href="#%E6%96%B9%E6%B3%95%20%EF%BC%9A">方法 ：</a></li><li><a href="#%E5%87%BA%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98">出现多线程安全的问题</a></li><li><a href="#%E4%B8%80%E4%BA%BA%E5%A4%9A%E5%8D%95%E7%9A%84%E6%82%B2%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">一人多单的悲观锁解决方案</a></li></ul></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%20redis%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">使用 redis 实现分布式锁</a></li><li><a href="#%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">下面是代码实现</a><ul><li><a href="#ILock%20%E6%8E%A5%E5%8F%A3">ILock 接口</a></li><li><a href="#%E5%AE%9E%E7%8E%B0%E7%B1%BB%20SimpleRedisLock">实现类 SimpleRedisLock</a></li><li><a href="#%E5%9C%A8%E4%B8%8B%E5%8D%95%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%BA%94%E7%94%A8%20redis%20%E9%94%81">在下单代码中应用 redis 锁</a></li></ul></li><li><a href="#%E6%94%B9%E8%BF%9B%20redis%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">改进 redis 分布式锁</a><ul><li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">解决方法</a></li><li><a href="#%E4%BD%A0%E4%BB%A5%E4%B8%BA%E8%BF%99%E5%B0%B1%E5%AE%8C%E4%BA%86%E5%98%9B%EF%BC%9F">你以为这就完了嘛？</a></li></ul></li><li><a href="#Redis%20Lua%20%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%80%A7">Redis Lua 脚本实现原子性</a></li></ul></li><li><a href="#%E4%BD%BF%E7%94%A8%20Redisson%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">使用 Redisson 实现分布式锁</a><ul><li><a href="#%E5%9F%BA%E4%BA%8E%20redis%20%E7%9A%84%20setnx%20%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">基于 redis 的 setnx 实现的分布式锁有什么问题</a></li><li><a href="#Redisson%20%E5%AE%9E%E7%8E%B0">Redisson 实现</a></li><li><a href="#Redisson%20%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86">Redisson 实现可重入锁的原理</a></li></ul></li><li><a href="#Redis%20%E4%BC%98%E5%8C%96%E7%A7%92%E6%9D%80">Redis 优化秒杀</a><ul><li><a href="#%E4%BC%98%E5%8C%96">优化</a><ul><li><a href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%20%EF%BC%9F">如何实现 ？</a></li><li><a href="#%E4%B8%9A%E5%8A%A1%E5%AE%9E%E7%8E%B0">业务实现</a></li></ul></li></ul></li><li><a href="#%E5%B1%80%E5%A4%96%E8%AF%9D">局外话</a></li><li><a href="#Redis%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80">Redis 消息队列实现异步秒杀</a></li></ul><h3 id="全局唯一-ID-的实现"><a href="#全局唯一-ID-的实现" class="headerlink" title="全局唯一 ID 的实现"></a>全局唯一 ID 的实现</h3><blockquote><p>为什么要使用全局唯一 ID，直接用数据库自增 ID 不好吗？</p></blockquote><p>这样会有一个问题，id 自增，那用户可以根据 id 猜测到一定规律，不够安全，被发现销量很少怎么办（doge）；而且数据库表的最大存储量是有限的，用户量一多就会受限制，多开表的话由于 id 会自增，可能会造成 id 重复，也就是说某些订单的 id 可能相同，这合理吗？不合理！</p><h4 id="如何实现全局唯一-ID？"><a href="#如何实现全局唯一-ID？" class="headerlink" title="如何实现全局唯一 ID？"></a>如何实现全局唯一 ID？</h4><p><mark>全局 ID 生成器</mark> </p><blockquote><p>要满足的特性： </p><ul><li>唯一性，这个不必多说</li><li>高性能，如果生成一个 id 需要很久，那要你何用</li><li>高可用，这个系统不会挂掉</li><li>递增性，必须有一个递增趋势</li><li>安全性，不能有明显规律<br>使用 redis 的 incre 能满足上述特性</li></ul></blockquote><p>可以定义一个全局 ID 生成器; 下面是实现过程：</p><ol><li><p>ID 的组成<br><img src="/images/%E5%85%A8%E5%B1%80ID%E7%9A%84%E7%BB%93%E6%9E%84.png"> </p></li><li><p>Idea 中实现生成过程，带注释</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hmdp.utils;    import org.springframework.data.redis.core.StringRedisTemplate;  import org.springframework.format.annotation.DateTimeFormat;  import org.springframework.stereotype.Component;    import javax.annotation.Resource;  import java.time.LocalDateTime;  import java.time.ZoneOffset;  import java.time.format.DateTimeFormatter;    @Component  public class RedisIdWorker &#123;    @Resource  private StringRedisTemplate stringRedisTemplate;    private final static long BEGIN_TIME &#x3D; 1672531200L; &#x2F;&#x2F;初始时间，用于生成时间戳  private final static int COUNT_BITS &#x3D; 32; &#x2F;&#x2F;序列号的位数，可更改    &#x2F;**  * 生成id，前缀由于区分不同业务  * @param keyPrefix  * @return  *&#x2F;  public long nextId(String keyPrefix)&#123;  &#x2F;&#x2F;1.生成时间戳 : 当前秒数 - 初始时间秒数  LocalDateTime now &#x3D; LocalDateTime.now();  long nowTime &#x3D; now.toEpochSecond(ZoneOffset.UTC);    long timestamp &#x3D; nowTime - BEGIN_TIME;  &#x2F;&#x2F;2.生成序列号 使用redis生成自增长序列号(每一天都对应一个不同的icrKey)    &#x2F;&#x2F;2.1 获取当前的日期，精确到天  String day &#x3D; now.format(DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;));    &#x2F;&#x2F;2.2 redis生成自增长key的值(序列号)  long count &#x3D; stringRedisTemplate.opsForValue().increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + day);    &#x2F;&#x2F;3.拼接并返回,注意这里不是字符串拼接，而是位运算得到32位 long 类型的值    return timestamp &lt;&lt; COUNT_BITS | count ; &#x2F;&#x2F;使用或运算，使空出的32位填充成序列号  &#125;    public static void main(String[] args) &#123;  &#x2F;&#x2F;生成一个初始时间  LocalDateTime time &#x3D; LocalDateTime.of(2023, 1, 1, 0, 0, 0);  long second &#x3D; time.toEpochSecond(ZoneOffset.UTC);  System.out.println(second);    &#125;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试生成 30000 个 id </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Resource  private RedisIdWorker redisIdWorker;    private ExecutorService es &#x3D; Executors.newFixedThreadPool(500); &#x2F;&#x2F;线程池    @Test  void testIdGenerator() throws InterruptedException &#123;  CountDownLatch countDownLatch &#x3D; new CountDownLatch(300); &#x2F;&#x2F;阻塞当前线程    Runnable task &#x3D; ()-&gt;&#123;  for(int i &#x3D; 0; i &lt; 100; i++)&#123;  long id &#x3D; redisIdWorker.nextId(&quot;shop&quot;);  System.out.println(&quot;id &#x3D; &quot; + id);  &#125;  countDownLatch.countDown(); &#x2F;&#x2F;完成一次任务，计数器-1  &#125;;  &#x2F;&#x2F;执行三百次任务，共30000个id  long begin &#x3D; System.currentTimeMillis();    for(int i &#x3D; 0; i &lt; 300;i++)&#123;  es.submit(task);  &#125;  countDownLatch.await();    long end &#x3D; System.currentTimeMillis();    System.out.println(&quot;共耗时:&quot;+ (end - begin));  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>成功，但是 CPU 爆了</p><blockquote><p><img src="/images/30000%20ID%E7%94%9F%E6%88%90%E8%80%97%E6%97%B6.png" alt="|775"> 2134 ms</p></blockquote></li></ol><h3 id="实现优惠券秒杀下单功能"><a href="#实现优惠券秒杀下单功能" class="headerlink" title="实现优惠券秒杀下单功能"></a>实现优惠券秒杀下单功能</h3><blockquote><ul><li>首先要知道优惠券实体类的结构：<br>Voucher 实体内的属性包括特价优惠券的所有属性<br>特价优惠券的表用优惠券 id 与优惠券表进行关联</li><li>业务流程<br><img src="/images/%E4%BC%98%E6%83%A0%E5%88%B8%E4%B8%8B%E5%8D%95%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B.png"></li></ul></blockquote><h4 id="根据流程图，进行业务初步实现-未使用-redis"><a href="#根据流程图，进行业务初步实现-未使用-redis" class="headerlink" title="根据流程图，进行业务初步实现 (未使用 redis)"></a>根据流程图，进行业务初步实现 (未使用 redis)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hmdp.service.impl;import com.hmdp.dto.Result;import com.hmdp.entity.SeckillVoucher;import com.hmdp.entity.User;import com.hmdp.entity.Voucher;import com.hmdp.entity.VoucherOrder;import com.hmdp.mapper.VoucherOrderMapper;import com.hmdp.service.ISeckillVoucherService;import com.hmdp.service.IVoucherOrderService;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.hmdp.service.IVoucherService;import com.hmdp.utils.RedisIdWorker;import com.hmdp.utils.UserHolder;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.time.LocalDateTime;@Servicepublic class VoucherOrderServiceImpl extends ServiceImpl&lt;VoucherOrderMapper, VoucherOrder&gt; implements IVoucherOrderService &#123;    @Resource    private RedisIdWorker redisIdWorker;   &#x2F;&#x2F;生成id    @Resource    private ISeckillVoucherService secKillVoucherService;    &#x2F;**     * 秒杀下单优惠券     *     * @param voucherId     * @return     *&#x2F;    @Override    @Transactional    public Result seckillVoucher(Long voucherId) &#123;        &#x2F;&#x2F;1.查询优惠券        SeckillVoucher seckillVoucher &#x3D; secKillVoucherService.getById(voucherId);        &#x2F;&#x2F;2.判断是否在秒杀时间段内        if(seckillVoucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;            &#x2F;&#x2F;2.1未在秒杀时间内，返回错误            return Result.fail(&quot;秒杀尚未开始!&quot;);        &#125;        if(seckillVoucher.getEndTime().isBefore(LocalDateTime.now()))&#123;            return Result.fail(&quot;秒杀结束!&quot;);        &#125;        &#x2F;&#x2F;2.2 在秒杀时间内        &#x2F;&#x2F;3.判断库存是否充足        Integer stock &#x3D; seckillVoucher.getStock();        if(stock &lt; 1)&#123;            return Result.fail(&quot;库存不足&quot;);        &#125;        &#x2F;&#x2F;4.充足，扣减库存        boolean success &#x3D; secKillVoucherService.update().setSql(&quot;stock &#x3D; stock - 1&quot;).eq(&quot;voucher_id&quot;, voucherId).update();        if(!success) return Result.fail(&quot;库存不足&quot;);        &#x2F;&#x2F;5.进行订单的插入        &#x2F;**         * 1.订单id，使用生成器实现         * 2.用户id         * 3.优惠券id         *&#x2F;        &#x2F;&#x2F;封装订单，其他属性有默认值，暂时不管        VoucherOrder voucherOrder &#x3D; new VoucherOrder();        long orderId &#x3D; redisIdWorker.nextId(&quot;voucher_order:&quot;);        Long userId &#x3D; UserHolder.getUser().getId();        voucherOrder.setId(orderId);        voucherOrder.setUserId(userId);        voucherOrder.setVoucherId(voucherId);        save(voucherOrder);        return Result.ok(orderId);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><blockquote><p>即一瞬间大量请求进来请求该接口并查询数据库，可能会导致库存数量为负数的情况，即超卖；</p></blockquote><h4 id="为什么会出现超卖"><a href="#为什么会出现超卖" class="headerlink" title="为什么会出现超卖"></a>为什么会出现超卖</h4><p>主要因为多线程时，线程 1 进行查询，发现有库存，正要去更新数据库，线程 2 可能会在线程 1 更新库存之前查询数据库导致超卖。<br><img src="/images/%E8%B6%85%E5%8D%96.png" alt="|400"> </p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以通过加锁实现,这里引出了两种锁的概念 [[悲观锁和乐观锁]] </p><blockquote><p>具体概念可跳转到具体文件</p></blockquote><p>使用乐观锁的CAS方法进行实现</p><blockquote><p>CAS方法，不加锁，只通过在查询库存后，更新数据库库存时，加一个判断条件，&#x3D;&#x3D;当前库存等于查询时的库存&#x3D;&#x3D; 可以避免超卖问题。<br><img src="/images/%E4%B9%90%E8%A7%82%E9%94%81CAS%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98.png"></p></blockquote><p>这种方法，会导致原本能卖出去的券卖不出去，即”少卖”的情况；<br>为什么呢，如果很多线程一起来，那就会出现即使库存充足，但是由于数据不同步（查询和更新时的stock）导致失败。</p><h4 id="乐观锁的改进-提高成功率"><a href="#乐观锁的改进-提高成功率" class="headerlink" title="乐观锁的改进-提高成功率"></a>乐观锁的改进-提高成功率</h4><p>上述判断条件会导致成功率大幅下降，所以可以放宽要求，只要&#x3D;&#x3D;更新时的库存大于0就能进行更新&#x3D;&#x3D;。<br><img src="/images/%E4%B9%90%E8%A7%82%E9%94%81CAS-%E6%94%B9%E8%BF%9B.png"></p><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><blockquote><p>即一人只能买一张优惠券</p></blockquote><p><img src="/images/%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95.png"></p><h4 id="方法-："><a href="#方法-：" class="headerlink" title="方法 ："></a>方法 ：</h4><p>在库存充足时，判断数据库中是否已经存在当前用户 user_id 且 voucher 都相等的订单，如果存在则返回异常，否则可以继续下单。<br><img src="/images/%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95-1.png"></p><h4 id="出现多线程安全的问题"><a href="#出现多线程安全的问题" class="headerlink" title="出现多线程安全的问题"></a>出现多线程安全的问题</h4><p>如果只是上述判断，会出现很多请求同时请求到订单数为 0 的情况，这时由于都可以进行订单插入，就会导致一人多单。</p><h4 id="一人多单的悲观锁解决方案"><a href="#一人多单的悲观锁解决方案" class="headerlink" title="一人多单的悲观锁解决方案"></a>一人多单的悲观锁解决方案</h4><p>不用乐观锁是因为，没有更新操作，而是插入操作，不能通过判断某值进行锁。</p><p>%%不得不说，下面加锁和事务的过程实在太复杂，现在听不懂！🤣%%</p><p>将下单和库存判断封装起来进行加锁（针对当前用户的锁）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Override    public Result seckillVoucher(Long voucherId) &#123;        &#x2F;&#x2F;1.查询优惠券        SeckillVoucher seckillVoucher &#x3D; secKillVoucherService.getById(voucherId);        &#x2F;&#x2F;2.判断是否在秒杀时间段内        if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;            &#x2F;&#x2F;2.1未在秒杀时间内，返回错误            return Result.fail(&quot;秒杀尚未开始!&quot;);        &#125;        if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;            return Result.fail(&quot;秒杀结束!&quot;);        &#125;        &#x2F;&#x2F;2.2 在秒杀时间内        &#x2F;&#x2F;3.判断库存是否充足        Integer stock &#x3D; seckillVoucher.getStock();        if (stock &lt; 1) &#123;            return Result.fail(&quot;库存不足&quot;);        &#125;        &#x2F;&#x2F;以用户id‘作为锁的关键字，防止每个用户都要加锁，降低效率        &#x2F;&#x2F; intern是在字符串常量池里找相同的值,否则每次toString都会新建对象，导致不等        synchronized (UserHolder.getUser().getId().toString().intern()) &#123;        &#x2F;&#x2F;获取与事务有关的对象            IVoucherService proxy &#x3D; (IVoucherService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        &#125;    &#125;    @Transactional    public Result createVoucherOrder(Long voucherId) &#123;        &#x2F;&#x2F;一人一单        Long userId &#x3D; UserHolder.getUser().getId();        Integer orders &#x3D; query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();        if (orders &gt; 0) return Result.fail(&quot;用户已经购买过该优惠券！&quot;);        &#x2F;&#x2F;4.充足，扣减库存        boolean success &#x3D; secKillVoucherService.update()                .setSql(&quot;stock &#x3D; stock - 1&quot;)                .eq(&quot;voucher_id&quot;, voucherId)                .gt(&quot;stock&quot;, 0)                .update();        if (!success) return Result.fail(&quot;库存不足&quot;);        &#x2F;&#x2F;5.进行订单的插入        &#x2F;**         * 1.订单id，使用生成器实现         * 2.用户id         * 3.优惠券id         *&#x2F;        &#x2F;&#x2F;封装订单，其他属性有默认值，暂时不管        VoucherOrder voucherOrder &#x3D; new VoucherOrder();        long orderId &#x3D; redisIdWorker.nextId(&quot;voucher_order:&quot;);        voucherOrder.setId(orderId);        voucherOrder.setUserId(userId);        voucherOrder.setVoucherId(voucherId);        save(voucherOrder);        return Result.ok(orderId);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这种一人一单的解决方法在集群模式下还是不能正常实现，因为多个 Tomcat 服务器分别有一个 JVM 存储不同的字符串常量池，导致锁监控器彼此之间无法进行同步，也就无法实现锁住同一个 userId ; 所以需要用到下一部分的知识: &#x3D;&#x3D;分布式锁&#x3D;&#x3D; </p></blockquote><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>满足分布式系统或集群模式下多”&#x3D;&#x3D;进程&#x3D;&#x3D;”之间&#x3D;&#x3D;可见并且互斥&#x3D;&#x3D;的锁</p><blockquote><blockquote><p>可见性是很好实现的，如 redis，mysql，zookeeper 都可以<br>多个服务器之间执行的不同应用就是不同的进程</p></blockquote><p>特性：</p><ol><li>高可用</li><li>高性能</li><li>安全性</li></ol></blockquote><h4 id="使用-redis-实现分布式锁"><a href="#使用-redis-实现分布式锁" class="headerlink" title="使用 redis 实现分布式锁"></a>使用 redis 实现分布式锁</h4><blockquote><p>根据 redis 互斥锁的特性, 获取锁需要具备原子性<br><img src="/images/%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png"></p></blockquote><h4 id="下面是代码实现"><a href="#下面是代码实现" class="headerlink" title="下面是代码实现"></a>下面是代码实现</h4><h5 id="ILock-接口"><a href="#ILock-接口" class="headerlink" title="ILock 接口"></a>ILock 接口</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hmdp.utils;    public interface ILock &#123;  &#x2F;**  * 自己实现redis锁的接口  * timeOutSec是过期时间  * 注意：这里要实现的是非阻塞式的锁，否则会影响性能  *&#x2F;  boolean tryLock(long timeOutSec);    &#x2F;&#x2F;释放锁  void unlock();  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="实现类-SimpleRedisLock"><a href="#实现类-SimpleRedisLock" class="headerlink" title="实现类 SimpleRedisLock"></a>实现类 SimpleRedisLock</h5><p>实现锁时，需要区分每个业务之间的区别，需要加 name 作为区分标识。&#x3D;&#x3D;在调用该锁的对象使用 tryLock 时可以特别写一下业务名称&#x3D;&#x3D;。如 redisLock. TryLock (“order”+userId, 5);</p><blockquote><p>这里加上 userId 就是为了保证”一人一单”。多进程之间也不会额外创建新的订单。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hmdp.utils;import org.springframework.data.redis.core.StringRedisTemplate;import java.util.concurrent.TimeUnit;public class SimpleRedisLock implements ILock&#123;    private StringRedisTemplate stringRedisTemplate;    private String name;   &#x2F;&#x2F;需要加锁的业务名称    public SimpleRedisLock(StringRedisTemplate stringRedisTemplate, String name) &#123;        this.stringRedisTemplate &#x3D; stringRedisTemplate;        this.name &#x3D; name;    &#125;    private static final String KEY_PREFIX &#x3D; &quot;lock:&quot;;    @Override    public boolean tryLock(long timeOutSec) &#123;        &#x2F;&#x2F;当前线程ID        long threadId &#x3D; Thread.currentThread().getId();        &#x2F;&#x2F;1.获取锁        Boolean success &#x3D; stringRedisTemplate.opsForValue()                .setIfAbsent(KEY_PREFIX + name, threadId + &quot; &quot;, timeOutSec, TimeUnit.SECONDS);        return Boolean.TRUE.equals(success);    &#125;    &#x2F;&#x2F;释放锁    @Override    public void unlock() &#123;        stringRedisTemplate.delete(KEY_PREFIX+name);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在下单代码中应用-redis-锁"><a href="#在下单代码中应用-redis-锁" class="headerlink" title="在下单代码中应用 redis 锁"></a>在下单代码中应用 redis 锁</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Result seckillVoucher(Long voucherId) &#123;        -------省略内容-----        Long userId &#x3D; UserHolder.getUser().getId();        SimpleRedisLock redisLock &#x3D; new SimpleRedisLock(&quot;order&quot; + userId, stringRedisTemplate);        boolean locked &#x3D; redisLock.tryLock(5);        if (!locked) &#123;            &#x2F;&#x2F;获取锁失败            return Result.fail(&quot;一个人只允许下一单&quot;);        &#125;        try &#123;            IVoucherOrderService proxy &#x3D; (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        &#125; catch (IllegalStateException e) &#123;            throw new RuntimeException(e);        &#125;finally &#123;            &#x2F;&#x2F;结束后释放锁            redisLock.unlock();        &#125;       &#x2F;*        &#x2F;&#x2F;以用户id‘作为锁的关键字，防止每个用户都要加锁，降低效率        &#x2F;&#x2F; intern是在字符串常量池里找相同的值,否则每次toString都会新建对象，导致不等        synchronized (UserHolder.getUser().getId().toString().intern()) &#123;            &#x2F;&#x2F;获取与事务有关的对象            IVoucherOrderService proxy &#x3D; (IVoucherOrderService) AopContext.currentProxy();            return proxy.createVoucherOrder(voucherId);        &#125;       * *&#x2F;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="改进-redis-分布式锁"><a href="#改进-redis-分布式锁" class="headerlink" title="改进 redis 分布式锁"></a>改进 redis 分布式锁</h4><p>当某个获取到锁的线程阻塞时，一旦过期时间达到，锁过期被删，其他线程就会趁虚而入获取锁，发现可以获取到锁从而导致又一次串行的情况。</p><h5 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h5><p><img src="/images/%E6%94%B9%E8%BF%9Bredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png"></p><blockquote><p>使用 (uuid + 线程 id) 是因为如果按照普通的线程 id，很有可能造成不同服务器之间的线程 id 冲突。</p></blockquote><p>代码实现：修改锁的实现类中的方法<br><img src="/images/%E4%BF%AE%E6%94%B9redis%E5%88%86%E5%B8%83%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">----省略-----    private static final String KEY_PREFIX &#x3D; &quot;lock:&quot;;    private static final String ID_PREFIX &#x3D; UUID.randomUUID().toString(true) + &quot;-&quot;;  &#x2F;&#x2F;作为线程id前缀    @Override    public boolean tryLock(long timeOutSec) &#123;        &#x2F;&#x2F;重新拼接线程ID        String threadId &#x3D; ID_PREFIX + Thread.currentThread().getId();        &#x2F;&#x2F;1.获取锁        Boolean success &#x3D; stringRedisTemplate.opsForValue()                .setIfAbsent(KEY_PREFIX + name, threadId , timeOutSec, TimeUnit.SECONDS);        return Boolean.TRUE.equals(success);    &#125;    &#x2F;&#x2F;释放锁    @Override    public void unlock() &#123;        &#x2F;&#x2F;获取线程标识        String threadId &#x3D; ID_PREFIX + Thread.currentThread().getId();        &#x2F;&#x2F;获取 redis 锁的标识        String id &#x3D; stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);        &#x2F;&#x2F;判断是否一致，如果不一致则说明当前线程无权进行该锁的删除,一致则可以删        if(threadId.equals(id)) stringRedisTemplate.delete(KEY_PREFIX+name);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="你以为这就完了嘛？"><a href="#你以为这就完了嘛？" class="headerlink" title="你以为这就完了嘛？"></a>你以为这就完了嘛？</h5><p>并么有，由于判断和删除是两个动作，即使两者之间没有其他代码，但是由于 &#x3D;&#x3D;JVM GC 垃圾回收时会堵塞线程&#x3D;&#x3D;，如果时间过长，锁由于过期时间达到而被删除，其他线程就会获取锁，一旦 GC 结束，该线程的锁就会被删除（误删）（key 一样都是 prefix + 业务名称 name）。<br><img src="/images/JVM%20GC%E5%A0%B5%E5%A1%9E%E7%BA%BF%E7%A8%8B%E9%87%8A%E6%94%BE%E9%94%81.png"></p><h4 id="Redis-Lua-脚本实现原子性"><a href="#Redis-Lua-脚本实现原子性" class="headerlink" title="Redis Lua 脚本实现原子性"></a>Redis Lua 脚本实现原子性</h4><p>基于 lua 语言特性和 redis 自带的脚本命令 script ，调用 redis 相关的方法进行判断可以满足原子性; 这里只贴图，相关实现不作说明。如果遇到该问题时可以回来看看。</p><p><img src="/images/lua%E8%B0%83%E7%94%A8redis.png"><br>改进 redis 的分布式锁<br><img src="/images/%E4%BD%BF%E7%94%A8lua%E5%86%99redis%E8%84%9A%E6%9C%AC.png"></p><h3 id="使用-Redisson-实现分布式锁"><a href="#使用-Redisson-实现分布式锁" class="headerlink" title="使用 Redisson 实现分布式锁"></a>使用 Redisson 实现分布式锁</h3><h4 id="基于-redis-的-setnx-实现的分布式锁有什么问题"><a href="#基于-redis-的-setnx-实现的分布式锁有什么问题" class="headerlink" title="基于 redis 的 setnx 实现的分布式锁有什么问题"></a>基于 redis 的 setnx 实现的分布式锁有什么问题</h4><blockquote><p>在&#x3D;&#x3D;高要求的情况&#x3D;&#x3D;下，有如下四个问题：<br><img src="/images/%E5%9F%BA%E4%BA%8Esetnx%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E9%97%AE%E9%A2%98.png"><br>基于 setnx 实现已经能够满足大部分的需求，如果需要的话可以使用 Redisson 实现。</p></blockquote><h4 id="Redisson-实现"><a href="#Redisson-实现" class="headerlink" title="Redisson 实现"></a>Redisson 实现</h4><p>Redisson 是一个基于 redis 基础上实现的，能提供一系列分布式服务包括（分布式锁，分布式对象等）的实现。</p><blockquote><p>官方文档的翻译：<a href="https://blog.csdn.net/A_art_xiang/article/details/125525864">redisson使用全解——redisson官方文档+注释（上篇）_redisson官网中文-CSDN博客</a> </p></blockquote><p>下面开始具体实现 redisson 的测试:</p><ol><li>写配置类，将 redissonClent 加入 bean<pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.hmdp.config;import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.config.Config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class RedissonConfig &#123;    @Bean    public RedissonClient redissonClient()&#123;        &#x2F;&#x2F;1. 获取redisson的配置        Config config &#x3D; new Config();        &#x2F;&#x2F;2.配置redis 地址和密码        config.useSingleServer().setAddress(&quot;redis:&#x2F;&#x2F;127.0.0.1:6379&quot;).setPassword(&quot;123456&quot;);        &#x2F;&#x2F;返回redissonClient对象        return Redisson.create(config);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>将之前实现的 simpleLock 方法换成 redisson<br><img src="/images/redisson%E9%94%81.png"><blockquote><p> tryLock () 这里可以查看参数, 分别为</p><ul><li>无参: 默认获取锁失败直接返回</li><li>三参: 分别为获取锁失败重试时间，锁自动过期时间，时间单位</li><li>两参: 自动过期时间和时间单位</li></ul></blockquote></li></ol><p>经过测试发现 redisson 确实可以实现安全性要求和可重入性，且更简单</p><blockquote><p>额外说明一下可重入性：同一个线程内的方法可以获取一个锁两次（多次）</p></blockquote><h4 id="Redisson-实现可重入锁的原理"><a href="#Redisson-实现可重入锁的原理" class="headerlink" title="Redisson 实现可重入锁的原理"></a>Redisson 实现可重入锁的原理</h4><p>先上图：<br><img src="/images/redisson%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86.png"></p><blockquote><p>大概就是，不使用 redis 的 setnx 互斥锁，而是自定义一个 hashMap 结构的值，分别&#x3D;&#x3D;记录线程名和获取锁的次数&#x3D;&#x3D;, 同一个线程内的方法尝试获取锁会允许获取锁，此线程的获取锁次数+1，反之，执行完业务后释放锁，判断如果是当前线程的锁，这个次数就-1，只有当次数回到 0 时，才会将该锁删除，不为 0 就重置锁的有效期，为同线程的其他业务留够时间。</p></blockquote><p>跟踪源码发现确实是使用 Lua 脚本 + redis script 实现的可重入锁<br><img src="/images/redisson%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-1.png"></p><p>后一部分是讲解锁重试机制的源码和看门狗机制，先润了，以后看</p><blockquote><p>WatchDog: Redisson 内部提供了一个监控锁的看门狗，它的作用是在 Redisson 实例被关闭前，不断的延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是 30 秒钟，也可以通过修改 Config. LockWatchdogTimeout 来另行指定。</p></blockquote><p><a href="https://www.bilibili.com/video/BV1cr4y1671t/?p=67&spm_id_from=pageDriver&vd_source=1ffd466ed0c5135e3f1bc07afebf6213">实战篇-20.分布式锁-Redisson的锁重试和WatchDog机制_哔哩哔哩_bilibili</a><br><a href="https://www.bilibili.com/video/BV1cr4y1671t?p=68&vd_source=1ffd466ed0c5135e3f1bc07afebf6213">实战篇-21.分布式锁-Redisson的multiLock原理_哔哩哔哩_bilibili</a> </p><h3 id="Redis-优化秒杀"><a href="#Redis-优化秒杀" class="headerlink" title="Redis 优化秒杀"></a>Redis 优化秒杀</h3><blockquote><p>Tip: 终于回来了＞﹏＜</p></blockquote><p>原本的下订单，除了锁之外有四个部分是直接请求数据库的，因此并发效率不高。<br><img src="/images/redis%E4%BC%98%E5%8C%96%E7%A7%92%E6%9D%80-%E6%95%B0%E6%8D%AE%E5%BA%93.png"></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>将判断库存和校验一人一单的部分分离出来给 redis 做，并通过异步线程完成数据库的其他调用。<br><img src="/images/redis%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96.png"></p><h5 id="如何实现-？"><a href="#如何实现-？" class="headerlink" title="如何实现 ？"></a>如何实现 ？</h5><p><img src="/images/redis%E4%BC%98%E5%8C%96%E4%BC%98%E6%83%A0%E5%88%B8%E4%B8%8B%E5%8D%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><ol><li>判断库存<br>先将优惠券的库存缓存到 redis 中，使用优惠券 id 作为 key 和库存数量作为 value，用户下单则库存 - 1；</li><li>实现一人一单<br>使用 key-set 集合 redis 数据结构，即可满足不重复性，且一张优惠券可被多个用户购买。</li></ol><p>基本流程：</p><blockquote><p>为保证多个操作时的原子性，使用 lua 脚本实现</p></blockquote><p><img src="/images/redis%E4%BC%98%E5%8C%96%E4%B8%8B%E5%8D%95%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png"></p><h5 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h5><ol><li>将秒杀优惠券信息缓存到 redis 中<br> <img src="/images/%E7%BC%93%E5%AD%98%E7%A7%92%E6%9D%80%E4%BC%98%E6%83%A0%E5%88%B8%E4%BF%A1%E6%81%AF.png"></li><li>编写 lua 脚本实现判断库存和一人一单<blockquote><p>根据流程图来，lua 脚本的语法熟悉就好，主要还是 redis 操作的命令。<br><img src="/images/lua%E8%84%9A%E6%9C%AC%E5%88%A4%E6%96%AD%E4%BC%98%E6%83%A0%E5%88%B8%E5%BA%93%E5%AD%98%E5%92%8C%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95-1.png"></p></blockquote></li><li>修改优惠券下单的接口：seckillOrderImpl 里的下单 seckillVoucher ()<blockquote><p><img src="/images/lua%E8%84%9A%E6%9C%AC%E4%B8%8B%E5%8D%95%E5%88%A4%E6%96%AD.png" alt="|450"></p></blockquote></li></ol><p>3.1 redis 脚本 script 执行配置<br><img src="/images/redis%20script.png"></p><p>3.2 剩余代码实现</p><blockquote><p>执行判断库存和一人一单并将下单信息加入到堵塞队列<br>异步下单，开启独立线程进行对应订单的数据库插入<br>不好意思，看不懂 (), 先贴着</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static final DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;&#x2F;&#x2F;redis scriptstatic &#123;    SECKILL_SCRIPT &#x3D; new DefaultRedisScript&lt;&gt;();    SECKILL_SCRIPT.setLocation(new ClassPathResource(&quot;seckill.lua&quot;));    SECKILL_SCRIPT.setResultType(Long.class);&#125;&#x2F;&#x2F;创建堵塞队列  &#x2F;&#x2F;空的时候会堵塞请求的线程，有元素则会接收线程请求消息private BlockingQueue&lt;VoucherOrder&gt; orderTasks &#x3D; new ArrayBlockingQueue&lt;&gt;(1024*1024);&#x2F;&#x2F;线程池private static final ExecutorService SECKILL_ORDER_EXECUTOR &#x3D; Executors.newSingleThreadExecutor();@PostConstructprivate void init()&#123;    SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());&#125;private class VoucherOrderHandler implements Runnable&#123;    private final String queueName &#x3D; &quot;stream.orders&quot;;    @Override    public void run() &#123;        while (true) &#123;            try &#123;                &#x2F;&#x2F; 0.初始化stream                initStream();                &#x2F;&#x2F; 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list &#x3D; stringRedisTemplate.opsForStream().read(                        Consumer.from(&quot;g1&quot;, &quot;c1&quot;),                        StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),                        StreamOffset.create(queueName, ReadOffset.lastConsumed())                );                &#x2F;&#x2F; 2.判断订单信息是否为空                if (list &#x3D;&#x3D; null || list.isEmpty()) &#123;                    &#x2F;&#x2F; 如果为null，说明没有消息，继续下一次循环                    continue;                &#125;                &#x2F;&#x2F; 解析数据                MapRecord&lt;String, Object, Object&gt; record &#x3D; list.get(0);                Map&lt;Object, Object&gt; value &#x3D; record.getValue();                VoucherOrder voucherOrder &#x3D; BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);                &#x2F;&#x2F; 3.创建订单                handleVoucherOrder(voucherOrder);                &#x2F;&#x2F; 4.确认消息 XACK stream.orders g1 id                stringRedisTemplate.opsForStream().acknowledge(queueName, &quot;g1&quot;, record.getId());            &#125; catch (Exception e) &#123;                log.error(&quot;处理订单异常&quot;, e);                handlePendingList();            &#125;        &#125;    &#125;    public void initStream()&#123;        Boolean exists &#x3D; stringRedisTemplate.hasKey(queueName);        if (BooleanUtil.isFalse(exists)) &#123;            log.info(&quot;stream不存在，开始创建stream&quot;);            &#x2F;&#x2F; 不存在，需要创建            stringRedisTemplate.opsForStream().createGroup(queueName, ReadOffset.latest(), &quot;g1&quot;);            log.info(&quot;stream和group创建完毕&quot;);            return;        &#125;        &#x2F;&#x2F; stream存在，判断group是否存在        StreamInfo.XInfoGroups groups &#x3D; stringRedisTemplate.opsForStream().groups(queueName);        if(groups.isEmpty())&#123;            log.info(&quot;group不存在，开始创建group&quot;);            &#x2F;&#x2F; group不存在，创建group            stringRedisTemplate.opsForStream().createGroup(queueName, ReadOffset.latest(), &quot;g1&quot;);            log.info(&quot;group创建完毕&quot;);        &#125;    &#125;    private void handlePendingList() &#123;        while (true) &#123;            try &#123;                &#x2F;&#x2F; 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 STREAMS s1 0                List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list &#x3D; stringRedisTemplate.opsForStream().read(                        Consumer.from(&quot;g1&quot;, &quot;c1&quot;),                        StreamReadOptions.empty().count(1),                        StreamOffset.create(queueName, ReadOffset.from(&quot;0&quot;))                );                &#x2F;&#x2F; 2.判断订单信息是否为空                if (list &#x3D;&#x3D; null || list.isEmpty()) &#123;                    &#x2F;&#x2F; 如果为null，说明没有消息，继续下一次循环                    break;                &#125;                &#x2F;&#x2F; 解析数据                MapRecord&lt;String, Object, Object&gt; record &#x3D; list.get(0);                Map&lt;Object, Object&gt; value &#x3D; record.getValue();                VoucherOrder voucherOrder &#x3D; BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);                &#x2F;&#x2F; 3.创建订单                handleVoucherOrder(voucherOrder);                &#x2F;&#x2F; 4.确认消息 XACK stream.orders g1 id                stringRedisTemplate.opsForStream().acknowledge(queueName, &quot;g1&quot;, record.getId());            &#125; catch (Exception e) &#123;                log.error(&quot;处理订单异常&quot;, e);            &#125;        &#125;    &#125;&#125;private void handleVoucherOrder(VoucherOrder voucherOrder) &#123;    Long userId &#x3D; voucherOrder.getId();    &#x2F;&#x2F; 创建锁对象    &#x2F;&#x2F; SimpleRedisLock lock &#x3D; new SimpleRedisLock(&quot;order:&quot; + userId, stringRedisTemplate);    RLock lock &#x3D; redissonClient.getLock(&quot;lock:order:&quot; + userId);    &#x2F;&#x2F; 获取锁    boolean isLock &#x3D; lock.tryLock();    &#x2F;&#x2F; 判断是否获取锁成功    if(!isLock)&#123;        &#x2F;&#x2F; 获取锁失败，返回错误或重试        log.error(&quot;不允许重复下单&quot;);        return;    &#125;    try &#123;        &#x2F;&#x2F; 获取代理对象（事务）        createVoucherOrder(voucherOrder);    &#125; finally &#123;        &#x2F;&#x2F; 释放锁        lock.unlock();    &#125;&#125;IVoucherOrderService proxy;@Overridepublic Result seckillVoucher(Long voucherId) &#123;    Long userId &#x3D; UserHolder.getUser().getId();    long orderId &#x3D; redisIdWorker.nextId(&quot;order&quot;);    &#x2F;&#x2F; 1.执行lua脚本    Long result &#x3D; stringRedisTemplate.execute(            SECKILL_SCRIPT,            Collections.emptyList(),            voucherId.toString(), userId.toString(), String.valueOf(orderId)    );    int r &#x3D; result.intValue();    &#x2F;&#x2F; 2.判断结果是否为0    if (r !&#x3D; 0) &#123;        &#x2F;&#x2F; 2.1.不为0 ，代表没有购买资格        return Result.fail(r &#x3D;&#x3D; 1 ? &quot;库存不足&quot; : &quot;不能重复下单&quot;);    &#125;    &#x2F;&#x2F; 3.获取代理对象    proxy &#x3D; (IVoucherOrderService) AopContext.currentProxy();    &#x2F;&#x2F; 4.返回订单id    return Result.ok(orderId);&#125;@Transactionalpublic void createVoucherOrder(VoucherOrder voucherOrder) &#123;    &#x2F;&#x2F; 5.一人一单    Long userId &#x3D; voucherOrder.getUserId();    &#x2F;&#x2F; 5.1.查询订单    int count &#x3D; query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherOrder.getVoucherId()).count();    &#x2F;&#x2F; 5.2.判断是否存在    if (count &gt; 0) &#123;        &#x2F;&#x2F; 用户已经购买过了        log.error(&quot;用户已经购买过一次！&quot;);        return;    &#125;    &#x2F;&#x2F; 6.扣减库存    boolean success &#x3D; secKillVoucherService.update()            .setSql(&quot;stock &#x3D; stock - 1&quot;) &#x2F;&#x2F; set stock &#x3D; stock - 1            .eq(&quot;voucher_id&quot;, voucherOrder.getVoucherId()).gt(&quot;stock&quot;, 0) &#x2F;&#x2F; where id &#x3D; ? and stock &gt; 0            .update();    if (!success) &#123;        &#x2F;&#x2F; 扣减失败        log.error(&quot;库存不足！&quot;);        return;    &#125;    &#x2F;&#x2F; 7.创建订单    save(voucherOrder);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="局外话"><a href="#局外话" class="headerlink" title="局外话"></a>局外话</h3><p>这里的秒杀如果只用堵塞队列实现下单还会有问题，大概理解上面这些秒杀的实现方式就好，老师最后讲的那部分真的复杂；<br>下面就看看用 redis 消息队列实现好不好理解吧。</p><h3 id="Redis-消息队列实现异步秒杀"><a href="#Redis-消息队列实现异步秒杀" class="headerlink" title="Redis 消息队列实现异步秒杀"></a>Redis 消息队列实现异步秒杀</h3><blockquote><p> P 72 - P 77 <a href="https://www.bilibili.com/video/BV1cr4y1671t?p=72">redis消息队列</a> </p><blockquote><p>这里的堵塞队列或者消息队列实现很复杂，只能暂时理解过程，想实现和完全搞懂还是有些距离，期待以后什么时候能补掉吧，唉😥</p></blockquote></blockquote><p>暂时停更优惠券专题：date: 2023&#x2F;10&#x2F;4 20:11</p>]]></content>
      
      
      <categories>
          
          <category> 框架/中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>买卖股票IV--状态机DP</title>
      <link href="/2023/10/03/mai-mai-gu-piao-iv-zhuang-tai-ji-dp/"/>
      <url>/2023/10/03/mai-mai-gu-piao-iv-zhuang-tai-ji-dp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文包括 ACWing 提高课一题以及力扣上的一题变式<br>Acwing: <a href="https://www.acwing.com/problem/content/description/1059/">1057. 股票买卖 IV - AcWing题库</a><br>Leetcode: <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/?envType=daily-question&envId=2023-10-03">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a> </p></blockquote><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/images/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8IV--%E7%8A%B6%E6%80%81%E6%9C%BADP.png"> </p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li><p>划分当前持有股票状态有和无</p></li><li><p>如果只是定义 DP 数组位 dp[i][j], 则只能说明前 i 天共有 j 次交易，区分不出状态</p></li><li><p>因此多加一个属性，第 i 天在进行第 j 次交易时，当前是否持有股票，如 dp[i][j][0]; 无股票</p></li><li><p>根据状态转换，<mark>dp[i][j][0] &#x3D; max (dp[i-1][j][0], dp[i-1][j][1] + w[i]);</mark><br> 解释：<br> 第 i 天如果没有持有股票，则由前一天状态过来后，j 次交易的最大利润和是”前一天没股票，<br> 则今天也无法获得收益（因为不持有股票）”   以及<br> “前一天有股票，今天需要卖出股票才能达成 dp[i][j][0]的状态，因此是 dp[i-1][j][1] + w[i]” 中的最大值</p></li></ol><ul><li>同理： dp[i][j][1] ,如果前一天没股票，需要购买当前股票，则 dp[i-1][j-1][0] - w[i]; (买入算一次交易),有的话就不变，因为不能一天内同时进行多笔交易，则 dp[i-1][j][1]; 取 max   </li><li>初始化，刚开始是无货的，j &#x3D;&#x3D; 0 时，f[i][j][0] &#x3D; 0 和 f[i][j][1] &#x3D; -INF（因为没进行交易不可能有货）;  可以先将所有状态都初始化为 -INF, 然后再将 f[i][0][0]都更新为 0</li></ul><blockquote><p>最后因为空间问题，设置 dp 为 dp[2][N][M];  但分析还是上述的</p></blockquote><h4 id="JAVA-版本"><a href="#JAVA-版本" class="headerlink" title="JAVA 版本"></a>JAVA 版本</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;import java.io.*;class Main&#123;    static int N &#x3D; 100010, M &#x3D; 110, INF &#x3D; 0x3f3f3f3f;        static int[][][] dp &#x3D; new int [2][N][M];    static int[] w &#x3D; new int[N];        public static void main(String[] args) throws IOException&#123;        Scanner scan &#x3D; new Scanner(System.in);        BufferedReader bf &#x3D; new BufferedReader(new InputStreamReader(System.in));                String[] t &#x3D; bf.readLine().split(&quot; &quot;);        int n &#x3D; Integer.parseInt(t[0]);        int k &#x3D; Integer.parseInt(t[1]);                String[] str &#x3D; bf.readLine().split(&quot; &quot;);                for(int i &#x3D; 1; i &lt;&#x3D; n;i++)&#123;            w[i] &#x3D; Integer.parseInt(str[i-1]);        &#125;                 &#x2F;&#x2F;初始化状态        for (int i &#x3D; 0; i &lt; 2; i ++)            for (int j &#x3D; 0; j &lt;&#x3D; n; j ++)                Arrays.fill(dp[i][j], -0x3f3f3f3f);                for(int i &#x3D; 0; i &lt;&#x3D; n;i++) dp[0][i][0] &#x3D; 0;  &#x2F;&#x2F;j为0，前 i 天 0 次交易，如果无货则为利润0;                for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;            for(int j &#x3D; 1; j &lt;&#x3D; k; j++)&#123;                dp[0][i][j] &#x3D; Math.max(dp[0][i-1][j], dp[1][i-1][j] + w[i]); &#x2F;&#x2F;后面的是卖出                dp[1][i][j] &#x3D; Math.max(dp[1][i-1][j], dp[0][i-1][j-1] - w[i]); &#x2F;&#x2F;后面的是买入,算一次交易            &#125;        &#125;        int ans &#x3D; 0;   &#x2F;&#x2F;最多进行k次交易，不一定交易笔数越多，利润越高，枚举最大值        for(int i &#x3D; 0 ; i &lt;&#x3D; k; i++)&#123;            ans &#x3D; Math.max(dp[0][n][i], ans);        &#125;                System.out.println(ans);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="力扣题目描述"><a href="#力扣题目描述" class="headerlink" title="力扣题目描述"></a>力扣题目描述</h3><p><img src="/images/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8IV--%E7%8A%B6%E6%80%81%E6%9C%BADP-%E5%8A%9B%E6%89%A3.png"> </p><h4 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">class Solution &#123;public:    static const int N &#x3D; 100010, M &#x3D; 5;        int maxProfit(vector&lt;int&gt;&amp; prices) &#123;        int n &#x3D; prices.size(); int k &#x3D; 2;        int dp[N][M][2];        memset(dp,-0x3f, sizeof dp);        &#x2F;&#x2F;初始化0次交易0利润        for(int i &#x3D; 0; i &lt;&#x3D; n;i++)&#123;            dp[i][0][0] &#x3D; 0;        &#125;        for(int i &#x3D; 1;i &lt;&#x3D; n;i++)&#123;            for(int j &#x3D; 1; j &lt;&#x3D; k; j++)&#123;                dp[i][j][0] &#x3D; max(dp[i-1][j][1] + prices[i-1], dp[i-1][j][0]);                dp[i][j][1] &#x3D; max(dp[i-1][j-1][0] - prices[i-1], dp[i-1][j][1]);            &#125;        &#125;        &#x2F;&#x2F;最多两笔交易，但是可能不会发生交易，万一亏本呢        int ans &#x3D; 0;        for(int i &#x3D; 0; i &lt;&#x3D; k; i++)&#123;            ans &#x3D; max(ans, dp[n][i][0]);  &#x2F;&#x2F;最后一定要是交易完成的结果        &#125;        return ans;      &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双写一致</title>
      <link href="/2023/09/30/shuang-xie-yi-zhi/"/>
      <url>/2023/09/30/shuang-xie-yi-zhi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要说明双写一致性，保证数据一致性<br>Keyword： <strong>延迟双删</strong><br>注意：延迟双删不能保证数据的强一致性，延迟删除时可能也会导致脏数据出现</p></blockquote><p>先上概念<br><strong>双写一致性</strong>： 如果修改了数据库的数据，同时也要更新缓存中的数据，保证缓存和数据库的数据一致性。<br><br/></p><h3 id="一般请求时的查询数据过程"><a href="#一般请求时的查询数据过程" class="headerlink" title="一般请求时的查询数据过程"></a>一般请求时的查询数据过程</h3><p><img src="/images/%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B.png"></p><blockquote><p>简单来说就是，查询数据时，如果缓存存在该数据则直接返回，否则会去数据库中查询，查询后再将该数据存入缓存中, 并且会设置过期时间。</p></blockquote><h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><p>就是上图所述</p><h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p><strong>延迟双删</strong>即修改数据库时，需要删除缓存-&gt;修改数据库-&gt;删除缓存</p><blockquote><p><img src="/images/%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0.png"></p></blockquote><ol><li>是先删缓存，再修改数据库，还是反过来？ 为什么这两种方式都不能保证数据一致性？<blockquote><p><strong>先删缓存，再修改数据库</strong><br><img src="/images/%E5%85%88%E5%88%A0%E7%BC%93%E5%AD%98.png" alt="|450"><br>先修改数据库，再删缓存<br>正常情况<br><img src="/images/%E5%85%88%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5.png" alt="|450"><br>不一致情况<br><img src="/images/%E5%85%88%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E4%B8%80%E8%87%B4.png" alt="|475"></p></blockquote></li><li>为什么需要延迟删除?<blockquote><p>数据库主从复制需要时间进行同步数据</p></blockquote></li></ol><h3 id="强一致性（加锁）"><a href="#强一致性（加锁）" class="headerlink" title="强一致性（加锁）"></a>强一致性（加锁）</h3><blockquote><p>这种会导致性能下降，只适用于<strong>读多写少</strong>的场景<br><img src="/images/%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7.png" alt="|450"></p></blockquote><h3 id="使用异步通信（MQ）"><a href="#使用异步通信（MQ）" class="headerlink" title="使用异步通信（MQ）"></a>使用异步通信（MQ）</h3><blockquote><p>缺点：太过依赖于 MQ 的可靠性<br><img src="/images/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架/中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存三兄弟</title>
      <link href="/2023/09/30/redis-huan-cun-san-xiong-di/"/>
      <url>/2023/09/30/redis-huan-cun-san-xiong-di/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Date: 2023&#x2F;9&#x2F;29</p></blockquote><blockquote><p>本文目的是记录三种 redis 缓存出错的场景</p><ul><li>缓存击穿</li><li>缓存穿透</li><li>缓存雪崩</li></ul></blockquote><h2 id="一-缓存穿透"><a href="#一-缓存穿透" class="headerlink" title="一 . 缓存穿透"></a>一 . 缓存穿透</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>如果用户请求一个数据库中永远不存在的数据，比如查询 id 为 0 或负数时，服务端会先查 redis，发现没有，就会去转发到数据库查询，数据库中一定不会查询到该数据（id 自增），但是也会对数据库造成压力，如果有人知道了请求路径，就可以通过大量请求这样的 id，可能会导致数据库崩溃。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h3><p>如果 redis 中不存在，转发到数据库中查询，如果查询不到，就把需要查询的 <code>id</code> (id &lt;&#x3D; 0)作为 key，value 设为 NULL，存到 redis 中，这样再次有一样的请求，就会直接返回 redis 中对应的空值；</p><blockquote><p>当然，这里的 key 需要设置一个过期时间，否则会造成内存压力过大。</p></blockquote><h2 id="二-缓存击穿"><a href="#二-缓存击穿" class="headerlink" title="二 . 缓存击穿"></a>二 . 缓存击穿</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>当一个 redis 中某个 key 刚好失效的瞬间，大量请求该数据的请求就会被转发到数据库进行查询，只要数据量够大，也会导致数据库压力大甚至崩溃。</p><blockquote><p>还有一种想法是：这个 key 长时间处于高并发状态，这时如果 key 突然失效，就会导致上述结果。</p></blockquote><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li><p>互斥锁<br>给线程添加互斥锁，当前线程 1 如果查询 redis 缓存查询不到就会获取互斥锁，此时其他线程 2 的查询就会被堵塞，随后该线程 1 就进行查询数据库和缓存更新，更新完成后释放锁，线程 2 也可以查询到数据了。</p><blockquote><p><strong>能保持 redis 和 mysql 的强一致性，但是性能差（阻塞其他线程）</strong></p></blockquote></li></ol><p><img src="/images/%E4%BA%92%E6%96%A5%E9%94%81.png"></p><ol start="2"><li><p>逻辑过期</p><blockquote><p>高可用，性能优，但是不能保证数据强一致性</p></blockquote></li></ol><p><img src="/images/%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F.png"><br>如图，线程 1 在查询时发现缓存过期后会先获取锁，然后新建一个子线程进行<strong>数据库查询</strong>和<strong>缓存更新</strong> 等子线程完成后就释放锁，在得到锁的过程中其他线程如果要查询该缓存，发现过期后，也想进行更新，但是发现被锁了，就直接返回过期的缓存数据。只有当锁释放后，其他线程才能获得最新数据。</p><blockquote><p>由此可见，不会阻塞其他线程的查询，所以效率高，但会导致查询的数据不一定是最新的，即非时效性。</p></blockquote><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义:"></a>定义:</h3><p>当一段时间内 (同一时刻)有大量 key 同时失效，就会导致大量数据查询请求抓发到数据库进行查询，可能会导致数据库崩溃。</p><h3 id="解决方法-："><a href="#解决方法-：" class="headerlink" title="解决方法 ："></a>解决方法 ：</h3><ol><li><p>给每个 key 设置不同的过期时间，防止大量 key 同时失效。</p><blockquote><p>如：给每个 key 的过期时间 TTL 加上一个随机值</p></blockquote></li><li><p>搭建 Redis 集群，提高服务可用性 (涉及到[[集群模式]] 和[[哨兵]])</p></li></ol><ul><li><input disabled="" type="checkbox"> #todo 写 Redis 集群和哨兵</li></ul><ol start="4"><li><p>给缓存业务添加限流策略</p><blockquote><p>Spring cloud gateway 或 nginx 等</p></blockquote></li><li><p>添加多级缓存</p><blockquote><p>一级缓存用 Caffeine 或 Guava</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架/中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test for ob</title>
      <link href="/2023/09/28/test-for-ob/"/>
      <url>/2023/09/28/test-for-ob/</url>
      
        <content type="html"><![CDATA[<h3 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h3><p>hello<br><img src="/../images/test%20for%20ob.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU缓存</title>
      <link href="/2023/09/24/lru-huan-cun/"/>
      <url>/2023/09/24/lru-huan-cun/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希表-双链表实现LRU缓存机制"><a href="#哈希表-双链表实现LRU缓存机制" class="headerlink" title="哈希表+双链表实现LRU缓存机制"></a>哈希表+双链表实现LRU缓存机制</h2><p>将有下面四个问题待解决：</p><ol><li><p>什么是LRU缓存机制？</p></li><li><p>为什么要用哈希表存？</p></li><li><p>为什么要用双链表，而不用队列？</p></li><li><p>如何实现？</p></li></ol><hr><h3 id="什么是LRU缓存机制"><a href="#什么是LRU缓存机制" class="headerlink" title="什么是LRU缓存机制"></a>什么是LRU缓存机制</h3><blockquote><p><a href="https://baike.baidu.com/item/LRU">LRU_百度百科 (baidu.com)</a></p></blockquote><p>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的<a href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/7626091?fromModule=lemma_inlink">页面置换算法</a>，选择最近最久未使用的页面予以淘汰。该算法赋予每个<a href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2/5544813?fromModule=lemma_inlink">页面</a>一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。</p><h4 id="先把题目贴出来吧"><a href="#先把题目贴出来吧" class="headerlink" title="先把题目贴出来吧"></a>先把题目贴出来吧</h4><blockquote><p><a href="https://leetcode.cn/problems/lru-cache/description/?envType=daily-question&envId=2023-09-24">146. LRU 缓存 - 力扣（LeetCode）</a> </p></blockquote><p><img src="/images/LRU.png"></p><hr><h3 id="为什么要用哈希表"><a href="#为什么要用哈希表" class="headerlink" title="为什么要用哈希表"></a>为什么要用哈希表</h3><p>因为很明显要用到键值对存key和value</p><hr><h3 id="为什么要用双链表而不用队列？"><a href="#为什么要用双链表而不用队列？" class="headerlink" title="为什么要用双链表而不用队列？"></a>为什么要用双链表而不用队列？</h3><p>因为题目说，要在满足Cache满的时候将最久未使用过的关键字剔除，所以我一开始是打算用队列来实现的，只要容量满了就把队头元素中的key对应键值对删了（先进先出），但是题目说了 <strong>“删除最久未使用的关键字”</strong> ，关键点就在这,假设这个关键字是key，只要我们取出该元素，或者插入该元素，或者修改该元素就算使用过，这时候这个元素就不应该在队列的队头，而应该在队尾（刚使用过）。因此队列无法满足要求（wa一次: 8&#x2F;22）；且题目要求在O(1)内完成，而双链表就能在O(1)的平均时间复杂度里执行各种操作。</p><hr><h3 id="下面开始实现"><a href="#下面开始实现" class="headerlink" title="下面开始实现"></a>下面开始实现</h3><blockquote><p>初见参考b站<a href="https://www.bilibili.com/video/BV15Y4y1574Q/?vd_source=1ffd466ed0c5135e3f1bc07afebf6213">【LeetCode 每日一题】146. LRU 缓存 | 手写图解版思路 + 代码讲解_哔哩哔哩_bilibili</a> </p></blockquote><h4 id="准备双链表"><a href="#准备双链表" class="headerlink" title="准备双链表"></a>准备双链表</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;双链表数据结构struct Node&#123;    int key, val;    Node *pre;    Node *next;    Node(): key(0),val(0),pre(NULL),next(NULL)&#123;&#125;    Node(int _key,int _val): key(_key),val(_val),pre(NULL),next(NULL)&#123;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="初始化哈希表和双链表"><a href="#初始化哈希表和双链表" class="headerlink" title="初始化哈希表和双链表"></a>初始化哈希表和双链表</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Node *head, *tail;    &#x2F;&#x2F;双链表虚拟头尾指针   unordered_map&lt;int, Node*&gt; cache;   int capacity, size;   &#x2F;&#x2F;最大容量，当前元素个数   LRUCache(int _capacity): capacity(_capacity),size(0)&#123;       head &#x3D; new Node();       tail &#x3D; new Node();       head-&gt;next &#x3D; tail;       tail-&gt;pre &#x3D; head;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="双链表删除节点以及插入节点到头部的操作"><a href="#双链表删除节点以及插入节点到头部的操作" class="headerlink" title="双链表删除节点以及插入节点到头部的操作"></a>双链表删除节点以及插入节点到头部的操作</h4><blockquote><p>双链表这部分就不多说了，数据结构基础</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;删除节点    void removeNode(Node *node)&#123;        node-&gt;pre-&gt;next &#x3D; node-&gt;next;        node-&gt;next-&gt;pre &#x3D; node-&gt;pre;    &#125;    &#x2F;&#x2F;将节点插到链表头部    void addToHead(Node* node)&#123;        node-&gt;pre &#x3D; head;        node-&gt;next &#x3D; head-&gt;next;        head-&gt;next-&gt;pre &#x3D; node;        head-&gt;next &#x3D; node;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="最后根据题目逻辑给出完整代码"><a href="#最后根据题目逻辑给出完整代码" class="headerlink" title="最后根据题目逻辑给出完整代码"></a>最后根据题目逻辑给出完整代码</h4><blockquote><p>注释很完整了</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;双链表数据结构struct Node&#123;    int key, val;    Node *pre;    Node *next;    Node(): key(0),val(0),pre(NULL),next(NULL)&#123;&#125;    Node(int _key,int _val): key(_key),val(_val),pre(NULL),next(NULL)&#123;&#125;&#125;;class LRUCache &#123;public:    Node *head, *tail;    &#x2F;&#x2F;双链表虚拟头尾指针    unordered_map&lt;int, Node*&gt; cache;    int capacity, size;   &#x2F;&#x2F;最大容量，当前元素个数    LRUCache(int _capacity): capacity(_capacity),size(0)&#123;        head &#x3D; new Node();        tail &#x3D; new Node();        head-&gt;next &#x3D; tail;        tail-&gt;pre &#x3D; head;    &#125;    int get(int key) &#123;        &#x2F;&#x2F;不存在该key键值对        if(!cache.count(key)) return -1;        &#x2F;&#x2F;存在        Node *node &#x3D; cache[key];        &#x2F;&#x2F;取出后，算使用过，则更新其位置到链表头部        removeNode(node);        addToHead(node);        return node-&gt;val;    &#125;    void put(int key, int value) &#123;        if(cache.count(key))&#123;            &#x2F;&#x2F;存在key，则修改key对应的value，更新使用状态            Node* node &#x3D; cache[key];            node-&gt;val &#x3D; value;            removeNode(node);            addToHead(node);        &#125;else &#123;            &#x2F;&#x2F;不存在，则插入一个新节点，且更新状态            &#x2F;&#x2F;1.判断容量是否超过capacity,如果超了需要删去链表尾部元素还有哈希表的对应元素            if(size &#x3D;&#x3D; capacity)&#123;                Node *removedNode &#x3D; tail-&gt;pre;                removeNode(removedNode);                cache.erase(removedNode-&gt;key);    &#x2F;&#x2F;注意删的不是当前要插入的key！！（这里找了好久的bug，要删掉的是链表头部节点对应的key）                size--;            &#125;            &#x2F;&#x2F;2.未超过，则将新节点插入哈希表，且插入到链表            Node *node &#x3D; new Node(key, value);            addToHead(node);            cache[key] &#x3D; node;            size++;           &#125;    &#125;    &#x2F;&#x2F;删除节点    void removeNode(Node *node)&#123;        node-&gt;pre-&gt;next &#x3D; node-&gt;next;        node-&gt;next-&gt;pre &#x3D; node-&gt;pre;    &#125;    &#x2F;&#x2F;将节点插到链表头部    void addToHead(Node* node)&#123;        node-&gt;pre &#x3D; head;        node-&gt;next &#x3D; head-&gt;next;        head-&gt;next-&gt;pre &#x3D; node;        head-&gt;next &#x3D; node;    &#125;&#125;;&#x2F;** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj &#x3D; new LRUCache(capacity); * int param_1 &#x3D; obj-&gt;get(key); * obj-&gt;put(key,value); *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="JAVA-版本"><a href="#JAVA-版本" class="headerlink" title="JAVA 版本"></a>JAVA 版本</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LRUCache &#123;    &#x2F;&#x2F;双链表  从左往右使用减少    class DLinkedNode&#123;        int key, val;        DLinkedNode pre;        DLinkedNode next;        public DLinkedNode()&#123;&#125;        public DLinkedNode(int _key, int _val) &#123;            this.key &#x3D; _key;            this.val &#x3D; _val;        &#125;    &#125;    DLinkedNode tail, head;  &#x2F;&#x2F;双链表头指针和尾部指针    HashMap&lt;Integer, DLinkedNode&gt; cache &#x3D; new HashMap&lt;&gt;();    int size;    &#x2F;&#x2F;当前元素数量    int capacity;  &#x2F;&#x2F;容量    &#x2F;&#x2F;1.初始化    public LRUCache(int _capacity) &#123;        this.capacity &#x3D; _capacity;        this.size &#x3D; 0;        tail &#x3D; new DLinkedNode();        head &#x3D; new DLinkedNode();        head.next &#x3D; tail;        tail.pre &#x3D; head;    &#125;        public int get(int key) &#123;        DLinkedNode node &#x3D; cache.get(key);        if(node &#x3D;&#x3D; null)&#123;            &#x2F;&#x2F;不存在key            return -1;        &#125;else &#123;            &#x2F;&#x2F;使用了该数，更新缓存            deleteNode(node);            addToHead(node);        &#125;        return node.val;    &#125;        public void put(int key, int value) &#123;        DLinkedNode node &#x3D; cache.get(key);        &#x2F;&#x2F;如果存在，修改并更新缓存;        if(node !&#x3D; null)&#123;            node.val &#x3D; value;            deleteNode(node);            addToHead(node);        &#125;else &#123;            &#x2F;&#x2F;不存在            &#x2F;&#x2F;1.判断容量  达到最大容量，删除最近未使用节点(别忘了cache也要删)            if(size &#x3D;&#x3D; capacity)&#123;                DLinkedNode removeNode &#x3D; tail.pre;                deleteNode(removeNode);                cache.remove(removeNode.key);                size--;            &#125;            DLinkedNode newNode &#x3D; new DLinkedNode(key, value);            size++;            addToHead(newNode);            cache.put(key, newNode);        &#125;    &#125;    &#x2F;&#x2F;删除双链表中的节点    public void deleteNode(DLinkedNode node)&#123;        node.pre.next &#x3D; node.next;        node.next.pre &#x3D; node.pre;    &#125;    &#x2F;&#x2F;加入到链表头部    public void addToHead(DLinkedNode node)&#123;        node.pre &#x3D; head;        node.next &#x3D; head.next;        head.next.pre &#x3D; node;        head.next &#x3D; node;    &#125;  &#125;&#x2F;** * Your LRUCache object will be instantiated and called as such: * LRUCache obj &#x3D; new LRUCache(capacity); * int param_1 &#x3D; obj.get(key); * obj.put(key,value); *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片测试</title>
      <link href="/2023/09/10/hello/"/>
      <url>/2023/09/10/hello/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/t.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2023/09/10/tuo-bu-xu-lie/"/>
      <url>/2023/09/10/tuo-bu-xu-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。</p><p>若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。</p><h3 id="拓扑排序过程"><a href="#拓扑排序过程" class="headerlink" title="拓扑排序过程"></a>拓扑排序过程</h3><ol><li><p>将所有入度为0的点入队</p></li><li><p>取出队头节点，输出该点并删去该点，同时将与其相连的边删去，且将与其相连的点的入度减去 1</p></li><li><p>重复此过程，直到所有的点都输出完成</p></li></ol><p>首先我们要明确一个<strong>有向无环图必定存在至少一个入度为0的点</strong>，所以以此为突破口，进行拓扑排序。</p><h4 id="参考例题"><a href="#参考例题" class="headerlink" title="参考例题"></a>参考例题</h4><blockquote><p>链接：[有向图的拓扑排序](<a href="https://www.acwing.com/problem/content/850/">848. 有向图的拓扑序列 - AcWing题库</a>) </p></blockquote><p><img src="/images/t.png"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><blockquote><p>题外话：之前一遇到要用邻接表的题就畏惧了，从来没好好理解过，今天终于能体会到一丝感悟，拓扑排序是个开始！</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)const int N &#x3D; 100010;int e[N], ne[N], h[N], idx;  &#x2F;&#x2F;邻接表相关int d[N];   &#x2F;&#x2F;存序号i的入度int q[N];  &#x2F;&#x2F;队列int n,m;void add(int a, int b)&#123;    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;&#125;bool topsort()&#123;    int hh &#x3D; 0, tt &#x3D; -1;    &#x2F;&#x2F;将所有入度为0的点入队    for(int i &#x3D; 1; i &lt;&#x3D; n;i++)&#123;        if(!d[i]) q[++tt] &#x3D; i;    &#125;    while(hh &lt;&#x3D; tt)&#123;        auto t &#x3D; q[hh++];  &#x2F;&#x2F;取队头:这里可以看出出队时的顺序就是拓扑排序的顺序，且hh只是++，不是覆盖,所以最终直接输出n个元素即可得到拓扑序列        &#x2F;&#x2F;遍历与t相连的边:判断入度以及删边        for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])&#123;            int j &#x3D; e[i];            d[j]--;              if(!d[j]) q[++tt] &#x3D; j;   &#x2F;&#x2F;入度为0入队        &#125;    &#125;    return tt &#x3D;&#x3D; n-1;   &#x2F;&#x2F;若最终恰好输出了n个元素，则说明是拓扑序列&#125;int main()&#123;    IOS;    cin&gt;&gt;n&gt;&gt;m;    memset(h, -1, sizeof h);  &#x2F;&#x2F;初始化头节点    int a,b;    for(int i &#x3D; 0; i &lt; m;i++)&#123;        cin&gt;&gt;a&gt;&gt;b;        add(a,b);   &#x2F;&#x2F;加边a-&gt;b        d[b]++;  &#x2F;&#x2F;入度++    &#125;    &#x2F;&#x2F;判断是否为拓扑排序    if(topsort())&#123;        &#x2F;&#x2F;根据上述分析可知，队列的前n个元素即为拓扑序列        for(int i &#x3D; 0; i &lt; n;i++)&#123;            cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;        &#125;        cout&lt;&lt;endl;    &#125;else cout&lt;&lt;-1&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="力扣：-210课程表II"><a href="#力扣：-210课程表II" class="headerlink" title="力扣： 210课程表II"></a>力扣： 210课程表II</h3><blockquote><p>刚好拿来练习拓扑排序</p><p>要注意一下有向边的指向</p><p>[题目链接](<a href="https://leetcode.cn/problems/course-schedule-ii/description/">210. 课程表 II - 力扣（LeetCode）</a>) </p></blockquote><h4 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下:"></a>题目如下:</h4><p><img src="/images/leetcode.png"></p><h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;public:&#x2F;&#x2F;拓扑排序  数组模拟邻接表    const static int N &#x3D; 4020;    int h[N],e[N],ne[N],idx;    int d[N];   &#x2F;&#x2F;入度    int q[N];  &#x2F;&#x2F;队列    &#x2F;&#x2F;加边    void add(int a,int b)&#123;        e[idx] &#x3D; b, ne[idx] &#x3D; h[a]; h[a] &#x3D; idx++;    &#125;    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;        memset(h,-1,sizeof h);        for(auto v : prerequisites)&#123;            int a &#x3D; v[0],b &#x3D; v[1];    &#x2F;&#x2F;注意是谁指向谁,应该是先修课为起点            add(b,a);   &#x2F;&#x2F;b-&gt;a            d[a]++;   &#x2F;&#x2F;a入度++        &#125;        int hh &#x3D; 0 ,tt &#x3D; -1;        for(int i &#x3D; 0; i &lt; numCourses;i++)&#123;     &#x2F;&#x2F;所有0入度的点入队            if(!d[i]) q[++tt] &#x3D; i;        &#125;        while(hh &lt;&#x3D; tt)&#123;            auto t &#x3D; q[hh++];    &#x2F;&#x2F;取队头，且指针后移（说明队头弹出）            &#x2F;&#x2F;删去与当前队头相连的边            for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])&#123;                int j &#x3D; e[i];                d[j]--;      &#x2F;&#x2F;相当于删边                if(!d[j]) q[++tt] &#x3D; j;   &#x2F;&#x2F;将新增的0入度点入队            &#125;        &#125;        &#x2F;&#x2F;恰好输出n个元素，即为拓扑序列        if(tt &#x3D;&#x3D; numCourses-1) &#123;            return vector&lt;int&gt;(q, q+numCourses);  &#x2F;&#x2F;使用数组初始化vector        &#125;else return vector&lt;int&gt;();   &#x2F;&#x2F;不是则返回空数组    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACWing基础算法模块</title>
      <link href="/2023/01/12/ji-chu-suan-fa/"/>
      <url>/2023/01/12/ji-chu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h3 id="ACWing模板链接"><a href="#ACWing模板链接" class="headerlink" title="ACWing模板链接"></a>ACWing模板链接</h3><blockquote><p>基础算法[基础算法](<a href="https://www.acwing.com/blog/content/277/">常用代码模板1——基础算法 - AcWing</a>)    </p><p>数据结构[数据结构](<a href="https://www.acwing.com/blog/content/404/">常用代码模板2——数据结构 - AcWing</a>) </p><p>搜索与图论[搜索与图论](<a href="https://www.acwing.com/blog/content/405/">常用代码模板3——搜索与图论 - AcWing</a>) </p><p>数学知识[数学知识](<a href="https://www.acwing.com/blog/content/406/">常用代码模板4——数学知识 - AcWing</a>) </p></blockquote><h1 id="AC模板"><a href="#AC模板" class="headerlink" title="AC模板"></a>AC模板</h1><h2 id="一-基础算法"><a href="#一-基础算法" class="headerlink" title="一.基础算法"></a>一.基础算法</h2><h3 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;using namespace std;const int N&#x3D;100010;int n;int q[N];void quick_sort(int q[],int l,int r)&#123;    if(l&gt;&#x3D;r)return ;    int i&#x3D;l-1;    int j&#x3D;r+1;    int x&#x3D;q[l+r&gt;&gt;1];       &#x2F;&#x2F;相当于(l+r)&#x2F;2;    while(i&lt;j)&#123;        do i++;while(q[i]&lt;x);    &#x2F;&#x2F;找到左区间中大于x的元素        do j--;while(q[j]&gt;x);    &#x2F;&#x2F;找到右区间中小于x的元素        if(i&lt;j)&#123;            swap(q[i],q[j]);     &#x2F;&#x2F;将这两个元素交换        &#125;    &#125;   &#x2F;&#x2F;递归遍历左右区间    quick_sort(q,l,j);        quick_sort(q,j+1,r);&#125;int main()&#123;    cin&gt;&gt;n;    for(int i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;q[i]);    &#125;     quick_sort(q,0,n-1);     &#x2F;&#x2F;此处元素从0开始存的，所以区间这样                             &#x2F;&#x2F;如果从有开始存就是(q,1,n);    for(int i&#x3D;0;i&lt;n;i++)&#123;        cout&lt;&lt;q[i]&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序-二路合并"><a href="#归并排序-二路合并" class="headerlink" title="归并排序      二路合并"></a>归并排序      二路合并</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D;100010;int n;int q[N];int ans[N];&#x2F;&#x2F;辅助数组  void merge_sort(int q[],int l, int r)&#123;    if(l&gt;&#x3D;r)return ;    &#x2F;&#x2F;1.找分界点    int mid&#x3D;l+r&gt;&gt;1;    &#x2F;&#x2F;递归左右区间     merge_sort(q,l,mid);  merge_sort(q,mid+1,r);    int k&#x3D;0;&#x2F;&#x2F;表示辅助数组中的元素下标    int i&#x3D;l;    int j&#x3D;mid+1;   &#x2F;&#x2F;分别表示两区间的起始点     while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;r)&#123;        &#x2F;&#x2F;将较小者放入辅助数组中         if(q[i]&lt;&#x3D;q[j]) ans[k++]&#x3D;q[i++];        else ans[k++]&#x3D;q[j++];    &#125;    &#x2F;&#x2F;将两数组中剩余的部分加入到辅助数组中     while(i&lt;&#x3D;mid)  ans[k++]&#x3D;q[i++];     while(j&lt;&#x3D;r) ans[k++]&#x3D;q[j++];     &#x2F;&#x2F;最后要把辅助数组中元素复制回来      for(i&#x3D;l,j&#x3D;0;i&lt;&#x3D;r;i++,j++) q[i]&#x3D;ans[j];&#125;int main()&#123;    cin&gt;&gt;n;    for(int i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;q[i]);    &#125;    merge_sort(q,0,n-1);    for(int i&#x3D;0;i&lt;n;i++)&#123;        printf(&quot;%d &quot;,q[i]);    &#125;    cout&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><blockquote><p>这里以数的范围为例（题目链接[数的范围](<a href="https://www.acwing.com/problem/content/description/791/">789. 数的范围 - AcWing题库</a>)），查找一个有序数组中目标值x的所在范围；</p><p>二分的思想是：能够将整体根据某种性质分成两个部分，通过使用l&#x3D;mid和r&#x3D;mid两个是否加1的模板，对数的范围左或右边界进行缩小和查找。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;using namespace std;const int N &#x3D;100010;int n,m;int q[N];int main() &#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i&#x3D;0; i&lt;n; i++) &#123;        scanf(&quot;%d&quot;,&amp;q[i]);    &#125;    &#x2F;&#x2F;m次询问    while(m--) &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);        int l&#x3D;0,r&#x3D;n-1; &#x2F;&#x2F;定义边界        while(l&lt;r) &#123;            int mid&#x3D;l+r&gt;&gt;1;    &#x2F;&#x2F;刚开始不知道要不要加一，r&#x3D;mid则不用加1            if(q[mid]&gt;&#x3D;x) r&#x3D;mid;  &#x2F;&#x2F;如果中间值大于目标值，说明去区间在mid左边，缩小右边界            else l&#x3D;mid+1;        &#125;        &#x2F;&#x2F;注意：如果不存在目标值，即区间端点值不等于目标值，输出-1 -1&quot;        if(q[l]!&#x3D;x) cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl;        else &#123;                cout&lt;&lt;l&lt;&lt;&quot; &quot;; &#x2F;&#x2F;打印其中一个边界(右边界(根据首先要找的mid范围判断))            l&#x3D;0; r&#x3D;n-1;            while(l&lt;r) &#123;                int mid&#x3D;l+r+1&gt;&gt;1;     &#x2F;&#x2F;需要加1，l&#x3D;mid                if(q[mid]&lt;&#x3D;x) l&#x3D;mid;   &#x2F;&#x2F;中间值小于目标值，说明区间在mid右边，缩小左边界                else  r&#x3D;mid-1;            &#125;            cout&lt;&lt;l&lt;&lt;endl;  &#x2F;&#x2F;打印哪个都一样        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h4><blockquote><p>保证答案一定在区间里面，直到区间非常小时可以当作答案就为端点值；</p><p>浮点数二分不需要考虑整除时的取整问题，因此更简单；</p><p>这里以开平方根为例   <strong>check是判断答案应在区间的函数</strong> </p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool check(double x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质double bsearch_3(double l, double r)&#123;    const double eps &#x3D; 1e-6;   &#x2F;&#x2F; eps 表示精度，取决于题目对精度的要求    while (r - l &gt; eps)    &#123;        double mid &#x3D; (l + r) &#x2F; 2;        if (check(mid)) r &#x3D; mid;        else l &#x3D; mid;    &#125;    return l;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数的三次方根"><a href="#数的三次方根" class="headerlink" title="数的三次方根"></a>数的三次方根</h4><blockquote><p>题目链接[数的三次方根](<a href="https://www.acwing.com/problem/content/792/">790. 数的三次方根 - AcWing题库</a>) </p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;using namespace std;int main()&#123;    double x;    cin&gt;&gt;x;    double l&#x3D;-10000,r&#x3D;10000;    &#x2F;&#x2F;两边界之差小于1e-8说明最终结果在两数之间，在误差范围之内    &#x2F;&#x2F;同时注意题目要求保留多少小数位，要多加两位，如保留6位，则1e-8，保留八位，最后按6位输出    while(r-l&gt;1e-8)    &#123;        &#x2F;&#x2F;确定mid        double mid&#x3D;(l+r)&#x2F;2;        if(mid*mid*mid&gt;&#x3D;x)        r&#x3D;mid; &#x2F;&#x2F;大于等于x，说明mid对应数的三次方大于了目标值，则缩小右边界        else l&#x3D;mid;    &#125;    printf(&quot;%lf\n&quot;,l);&#x2F;&#x2F;l或r都可，两者相差在误差内,而lf默认为6位小数输出，%.4lf则4位小数    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法</h3><h4 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h4><blockquote><p>利用数组对位数过长的数（长度可达到1e6位）进行求和   题目链接[链接](<a href="https://www.acwing.com/problem/content/description/793/">791. 高精度加法 - AcWing题库</a>) </p><p>注意存储两个数时用字符串读入，再按逆序拆分（有进位的情况）后对两个数分别存储。</p></blockquote><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N &#x3D;1e6+10;vector&lt;int&gt; add(vector&lt;int&gt; &amp;v,vector&lt;int&gt; &amp;vs) &#123;    vector&lt;int&gt; ans;    int t&#x3D;0; &#x2F;&#x2F; 保存进位    for(int i&#x3D;0; i&lt;v.size()||i&lt;vs.size(); i++) &#123;        if(i&lt;v.size())  t+&#x3D;v[i];        if(i&lt;vs.size()) t+&#x3D;vs[i];  &#x2F;&#x2F;t每步将两个数加一起，将个位数保留入组，10位数作为进位         ans.push_back(t%10);        t&#x2F;&#x3D;10;    &#125;    if(t) ans.push_back(1); &#x2F;&#x2F;如果还有进位，需要补上     return ans;&#125;void printvec(vector&lt;int&gt; &amp;ans) &#123;    for(vector&lt;int&gt;::iterator it&#x3D;ans.end()-1; it!&#x3D;ans.begin()-1; it--) &#123;        printf(&quot;%d&quot;,*it);    &#125;    cout&lt;&lt;endl;&#125;int main() &#123;    vector&lt;int&gt; v,vs;    string a,b;    cin&gt;&gt;a&gt;&gt;b;    &#x2F;&#x2F;位数太多，要用字符串读入    for(int i&#x3D;a.size()-1; i&gt;&#x3D;0; i--) &#123;        v.push_back(a[i]-&#39;0&#39;);    &#125;    for(int i&#x3D;b.size()-1; i&gt;&#x3D;0; i--) &#123;        vs.push_back(b[i]-&#39;0&#39;);    &#125;    vector&lt;int&gt; ans&#x3D;add(v,vs);&#x2F;&#x2F;    for(int i&#x3D;ans.size()-1;i&gt;&#x3D;0;i--)&#x2F;&#x2F;    printf(&quot;%d&quot;,ans[i]);&#x2F;&#x2F;    &#x2F;&#x2F;    cout&lt;&lt;endl;    printvec(ans);  &#x2F;&#x2F;倒着输出     return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h4><blockquote><p>将减法过程加个判断，当某个位数相减大于等于0时，直接减并减去上一位的借位，当小于0时需要借1位10，同时需要减去上一位的借位 t</p><p>一般是A大于B，如果小于，就反过来减，再加个符号</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N &#x3D;1e6+10;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;v,vector&lt;int&gt; &amp;vs) &#123;    vector&lt;int&gt; ans;    int t&#x3D;0; &#x2F;&#x2F; 保存借位    for(int i&#x3D;0;i&lt;v.size();i++)&#123;    &#x2F;&#x2F;A一定大于B了         t&#x3D;v[i]-t;        if(i&lt;vs.size()) t-&#x3D;vs[i];           &#x2F;&#x2F;如果B当前位数存在才减去，相当于A-B-t         ans.push_back((t+10)%10);           &#x2F;&#x2F;两者相减小于0，则加10再模10，且t为1,否则为0        if(t&lt;0) t&#x3D;1;        else t&#x3D;0;     &#125;    &#x2F;&#x2F;最后如果前导位为0，则需要弹出    while(ans.size()&gt;1&amp;&amp;ans.back()&#x3D;&#x3D;0)  ans.pop_back();     return ans;&#125;&#x2F;&#x2F;判断v是不是&gt;&#x3D;vs 即A&gt;&#x3D;B bool cmp(vector&lt;int&gt; &amp;v,vector&lt;int&gt; &amp;vs)&#123;    if(v.size()!&#x3D;vs.size()) return v.size()&gt;vs.size();    for(int i&#x3D;v.size()-1;i&gt;&#x3D;0;i--)&#123;      &#x2F;&#x2F;注意我们是倒着存的数，但需要从高位依次判断大小         if(v[i]!&#x3D;vs[i])            return v[i]&gt;vs[i];    &#x2F;&#x2F;相同位数下，只要A有一位数大于B的话就说明A较大了    &#125;    return true;        &#x2F;&#x2F;如果都相同，则说明A&#x3D;&#x3D;B &#125; void printvec(vector&lt;int&gt; &amp;ans) &#123;    for(vector&lt;int&gt;::iterator it&#x3D;ans.end()-1; it!&#x3D;ans.begin()-1; it--) &#123;        printf(&quot;%d&quot;,*it);    &#125;    cout&lt;&lt;endl;&#125;int main() &#123;    vector&lt;int&gt; v,vs;    string a,b;    cin&gt;&gt;a&gt;&gt;b;    &#x2F;&#x2F;位数太多，要用字符串读入    for(int i&#x3D;a.size()-1; i&gt;&#x3D;0; i--) &#123;        v.push_back(a[i]-&#39;0&#39;);    &#125;    for(int i&#x3D;b.size()-1; i&gt;&#x3D;0; i--) &#123;        vs.push_back(b[i]-&#39;0&#39;);    &#125;    if(cmp(v,vs)) &#123;        vector&lt;int&gt; ans&#x3D;sub(v,vs);        printvec(ans);     &#125;    else &#123;        vector&lt;int&gt; ans&#x3D;sub(vs,v);        cout&lt;&lt;&quot;-&quot;;    &#x2F;&#x2F;A小于B时需要加负号         printvec(ans);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="高精度乘法（高精度-低精度）"><a href="#高精度乘法（高精度-低精度）" class="headerlink" title="高精度乘法（高精度*低精度）"></a>高精度乘法（高精度*低精度）</h4><blockquote><p>按照模板背住就行，具体思路就是：从低位开始，每一位与低精度数相乘，将进位记录下来，将进位 %10 放入res，后 t&#x2F;10作为下一位的进位 ，最后需要扫尾。题目链接[高精度乘法](<a href="https://www.acwing.com/problem/content/795/">793. 高精度乘法 - AcWing题库</a>) </p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; A;int a;vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A,int a)&#123;    vector&lt;int&gt; res;    int t&#x3D;0;    for(int i&#x3D;0;i&lt;A.size()||t;i++)&#123;        if(i&lt;A.size()) t+&#x3D;A[i]*a;        res.push_back(t%10);        t&#x2F;&#x3D;10;    &#125;&#x2F;&#x2F;    while(t)&#123;&#x2F;&#x2F;        res.push_back(t%10);&#x2F;&#x2F;        t&#x2F;&#x3D;10;&#x2F;&#x2F;    &#125;    while(res.size()&gt;1&amp;&amp;res.back()&#x3D;&#x3D;0) res.pop_back();    return res;&#125;int main()&#123;    string s;    cin&gt;&gt;s&gt;&gt;a;    for(int i&#x3D;s.size()-1;i&gt;&#x3D;0;i--)&#123;        A.push_back(s[i]-&#39;0&#39;);    &#125;    vector&lt;int&gt; ans;    ans&#x3D;mul(A,a);    for(int i&#x3D;ans.size()-1;i&gt;&#x3D;0;i--)&#123;        printf(&quot;%d&quot;,ans[i]);    &#125;    cout&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="高精度除法（高精度-x2F-低精度）"><a href="#高精度除法（高精度-x2F-低精度）" class="headerlink" title="高精度除法（高精度&#x2F;低精度）"></a>高精度除法（高精度&#x2F;低精度）</h4><blockquote><p>高精度除法与其他三种不太相同，是由高位开始进行除的，并且多了一个余数r，最后为了保持一致性，将res翻转了一下，这样在输出的时候也保证了一致（逆序输出）。最后也别忘了消去前导0。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; A;int a;vector&lt;int&gt; div(vector&lt;int&gt; &amp;A,int a,int &amp;r)&#123;    vector&lt;int&gt; res;    r&#x3D;0;  &#x2F;&#x2F;存放余数     &#x2F;&#x2F;除法与其他三种运算不同，需要从高位开始运算     for(int i&#x3D;A.size()-1;i&gt;&#x3D;0;i--)&#123;        r&#x3D;r*10+A[i];        res.push_back(r&#x2F;a);        r%&#x3D;a;    &#125;    &#x2F;&#x2F;存放的商的顺序是从高位到低位的，即顺序的，为了统一模板需要倒置一下     reverse(res.begin(),res.end());    &#x2F;&#x2F;仍然需要将前置0删去     while(res.size()&gt;1&amp;&amp;res.back()&#x3D;&#x3D;0) res.pop_back();    return res;&#125;int main()&#123;    string s;    cin&gt;&gt;s&gt;&gt;a;    for(int i&#x3D;s.size()-1;i&gt;&#x3D;0;i--)&#123;        A.push_back(s[i]-&#39;0&#39;);    &#125;    vector&lt;int&gt; ans;    int r&#x3D;0;    ans&#x3D;div(A,a,r);    for(int i&#x3D;ans.size()-1;i&gt;&#x3D;0;i--)&#123;        printf(&quot;%d&quot;,ans[i]);    &#125;    cout&lt;&lt;endl&lt;&lt;r;    cout&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><h4 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h4><blockquote><p>    快速求一个数组中一段区间内的数的和，解决在某些数据范围很大的情况下会超时的问题</p><p>    思路：利用公式si&#x3D;a1+a2+~~ai;         在录入数组时，初始化前缀和数组s，每个位置存放前i个数的和</p><p>    实现求和时结果是线性的O(1)        </p><p>    特殊：s数组第一个位置存放0 从1开始存，因为s[i]&#x3D;s[i-1]+a[i];  不会越界</p><p>    有时需要注意数据范围，可能需要用long long</p><p>公式：</p><p>    &lt;S[i] &#x3D; a[1] + a[2] + … a[i]&gt;<br>    &lt;a[l] + … + a[r] &#x3D; S[r] - S[l - 1]&gt;</p><p>例：求[l,r]内的数的和，则可以得s[r]-s[l-1] ;    [题目链接](<a href="https://www.acwing.com/problem/content/797/">795. 前缀和 - AcWing题库</a>) </p></blockquote><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int N &#x3D;1e5+10;int n,m;int q[N];int s[N];int main() &#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;    scanf(&quot;%d&quot;,&amp;q[i]);    s[i]&#x3D;s[i-1]+q[i];&#125;    while(m--)&#123;        int l,r;        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);        printf(&quot;%d\n&quot;,s[r]-s[l-1]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="子矩阵的和（二维前缀和）"><a href="#子矩阵的和（二维前缀和）" class="headerlink" title="子矩阵的和（二维前缀和）"></a>子矩阵的和（二维前缀和）</h4><blockquote><p>子矩阵的和也是公式重要，思路是容斥原理吗，即面积的相加相减，最后得到两点之间组成的区域和，录入前缀和数组以及输出区域和配图如下。题目链接[子矩阵的和](<a href="https://www.acwing.com/problem/content/798/">796. 子矩阵的和 - AcWing题库</a>) </p><p>公式： </p><p>    录入：&lt;s[i][j]&#x3D;s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];&gt;</p><p>    输出:  &lt;s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1];&gt;</p></blockquote><p>图一前缀和数组录入：<img title="" src="file:///C:/Users/Lenovo/Desktop/pic/录入前缀和数组.png" alt="前缀和录入" width="680"></p><p>图二目标区域和输出:<img src="C:\Users\Lenovo\Desktop\pic\输出目标区域矩阵和.png" alt="链接"></p><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int N &#x3D;1010;int n,m,q;int a[N][N];int s[N][N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    &#x2F;&#x2F;读入矩阵，从11开始存     for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;        for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;            scanf(&quot;%d&quot;,&amp;a[i][j]);        &#125;    &#125;    &#x2F;&#x2F;前缀和数组，可以合并这两步，以防万一分开     for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;        for(int j&#x3D;1;j&lt;&#x3D;m;j++)&#123;            s[i][j]&#x3D;s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];        &#125;    &#125;    &#x2F;&#x2F;q次询问     while(q--)&#123;        int x1,y1,x2,y2;        scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);        printf(&quot;%d\n&quot;,s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><h4 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h4><blockquote><p>    就是前缀和的逆运算，即构造数组b，使得原数组a是b数组的前缀和数组。</p><p>即：b(n)&#x3D;a(n)-a(n-1);  如 a2&#x3D;b1+b2&#x3D;a1+(a2-a1)&#x3D;a2;</p><p>    目的：让数组中n个子区间[l,r]每个数都加上一个数C，可以用O(n)一个循环，</p><p>但是用差分可以实现O(1)。</p><p>    过程：bi加上C后，对应的ai也会加上一个C（因为：a2&#x3D;b1+b2;），且其后面的剩余数也会加上C，</p><p>    最后再将br+1减去一个C，这样其后的所有数就相当于不加C，最后根据b数组求原数组即可得到。</p><p>    主要是公式：</p><p>       &lt;b[l]+&#x3D;c;  b[r+1]-&#x3D;c;&gt;</p></blockquote><p>大佬的总结：</p><p><img src="C:\Users\Lenovo\Desktop\pic\前缀和与差分理解.png" alt="图"></p><p><img src="C:\Users\Lenovo\Desktop\pic\差分代码详解.png"></p><p>最后代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D;100010;int a[N],b[N];int n,m;void insert(int l,int r,int c) &#123;    b[l]+&#x3D;c;    b[r+1]-&#x3D;c;&#125;int main() &#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i&#x3D;1; i&lt;&#x3D;n; i++) &#123;        scanf(&quot;%d&quot;,&amp;a[i]);        insert(i,i,a[i]);     &#x2F;&#x2F;看作数组是空的，然后在每个单位区间上加上了一个a[i]    &#125;    while(m--) &#123;        int l,r,c;        scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;c);        insert(l,r,c);    &#125;    for(int i&#x3D;1; i&lt;&#x3D;n; i++) &#123;&#x2F;&#x2F;        b[i]+&#x3D;b[i-1];           &#x2F;&#x2F;直接用b[i]作为还原后的前缀和数组         a[i]&#x3D;a[i-1]+b[i];      &#x2F;&#x2F;得到加过的前缀和数组，这样更容易理解，因为a数组是b的前缀和数组     &#125;    for(int i&#x3D;1;i&lt;&#x3D;n;i++) printf(&quot;%d &quot;,a[i]);    &#x2F;&#x2F;如果用b[i]存储前缀和数组，那就输出b[i]     return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h4><blockquote><p>与一维差分差不多，都是容斥原理，主要是公式的应用</p><p>[子矩阵差分](<a href="https://www.acwing.com/problem/content/description/800/">798. 差分矩阵 - AcWing题库</a>) </p><p>公式如下：</p><p>    &lt;**b[x1][y1]+&#x3D;c;**&gt;</p><p>    &lt;**b[x2+1][y1]-&#x3D;c;**&gt;</p><p>    &lt;**b[x1][y2+1]-&#x3D;c;**&gt;</p><p>    &lt;**b[x2+1][y2+1]+&#x3D;c;**&gt;</p><p>最后由b数组按前缀和公式求出答案数组即可，此处用差分数组b代替前缀和数组</p></blockquote><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;using namespace std;const int N &#x3D;1010;int n,m,q;int a[N][N];int b[N][N];void insert(int x1,int y1,int x2,int y2,int c) &#123;    b[x1][y1]+&#x3D;c;    b[x2+1][y1]-&#x3D;c;    b[x1][y2+1]-&#x3D;c;    b[x2+1][y2+1]+&#x3D;c;&#125;int main() &#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i&#x3D;1; i&lt;&#x3D;n; i++)        for(int j&#x3D;1; j&lt;&#x3D;m; j++)            scanf(&quot;%d&quot;,&amp;a[i][j]);    for(int i&#x3D;1; i&lt;&#x3D;n; i++)        for(int j&#x3D;1; j&lt;&#x3D;m; j++)            insert(i,j,i,j,a[i][j]);    while(q--) &#123;        int x1,y1,x2,y2,c;        scanf(&quot;%d%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);        insert(x1,y1,x2,y2,c);    &#125;    for(int i&#x3D;1; i&lt;&#x3D;n; i++)        for(int j&#x3D;1; j&lt;&#x3D;m; j++)        b[i][j]+&#x3D;b[i-1][j]+b[i][j-1]-b[i-1][j-1];    for(int i&#x3D;1; i&lt;&#x3D;n; i++)        &#123;            for(int j&#x3D;1; j&lt;&#x3D;m; j++)              printf(&quot;%d &quot;,b[i][j]);            printf(&quot;\n&quot;);        &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><blockquote><p>核心思想：根据某种性质，将双层循环O(n^2)优化为 O(n);</p><p>背双指针模板，根据题目要求改写check。</p><p>    (check不一定是函数，可以是某个判断条件)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">for(int i&#x3D;0,j&#x3D;0;i&lt;n;i++)&#123;   while(j &lt; i &amp;&amp; check(i,j) j++;    &#x2F;&#x2F;根据题目确定&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="换行输出单词"><a href="#换行输出单词" class="headerlink" title="换行输出单词"></a>换行输出单词</h4><p>例：给定一个由一个空格隔开的几个单词组成的字符串，请换行输出每个单词。</p><blockquote><p>运用双指针算法，可以将两层循环得到单词后的空格的操作时间复杂度缩小为O(n)</p></blockquote><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N &#x3D;10010;&#x2F;&#x2F;将几个相隔一个空格的单词，分别换行输出 int main() &#123;    char str[1000];    gets(str);    int len&#x3D;strlen(str);  &#x2F;&#x2F;得到字符串数组的长度  &lt;string.h&gt;    for(int i&#x3D;0;i&lt;len;i++)&#123;        int j&#x3D;i;         while(j&lt;len&amp;&amp;str[j]!&#x3D;&#39; &#39;) j++;     &#x2F;&#x2F;如果j指向的不是空格，则继续后移，等遇到空格后输出i到j的这一段即可         &#x2F;&#x2F;输出当前区间的单词         for(int k&#x3D;i;k&lt;j;k++)&#123;            cout&lt;&lt;str[k];        &#125;        puts(&quot;&quot;);        &#x2F;&#x2F;        i&#x3D;j;  &#x2F;&#x2F;将i指向j所指的当前空格，随后循环结束一次i++即可进行下一个单词的获取     &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="最长连续不重复子区间"><a href="#最长连续不重复子区间" class="headerlink" title="最长连续不重复子区间"></a>最长连续不重复子区间</h4><blockquote><p>做双指针的思路，先像一个双层循环的暴力做法，再通过双指针优化。</p><p>[题目链接](<a href="https://www.acwing.com/problem/content/801/">799. 最长连续不重复子序列 - AcWing题库</a>) </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">朴素做法：for(int i&#x3D;0;i&lt;n;i++)&#123;&#x2F;&#x2F;每次j从头开始判断i，j区间是否满足不重复条件    for(int j&#x3D;0;j&lt;&#x3D;i;j++)&#123;        if(check(i,j))      &#x2F;&#x2F;不完整    &#123;    res&#x3D;max(res,i-j+1);  &#x2F;&#x2F;子区间长度     &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>双指针代码优化如下：</p><blockquote><p>其中while部分的删去思路：</p><p>    &#x2F;&#x2F;如果当i所指的元素个数大于1时，则当前区间不满足条件，则需要将区间中从第一个数开始进行删除(实际上是减去出现次数，因为没说是有序数组啊，所以要依次删去，直到区间没有重复元素了，i 再往后继续走)，反之如果不重复，i则可以一直往后走，然后更新一下当前的最大长度不重复子区间长度。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;const int N &#x3D;100010;int n;int a[N],s[N];&#x2F;&#x2F;s[N]用于判断当前i，j区间是否有重复元素int res;int main()&#123;    cin&gt;&gt;n;    for(int i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;a[i]);    &#125;    for(int i&#x3D;0,j&#x3D;0;i&lt;n;i++)&#123;        s[a[i]]++; &#x2F;&#x2F;i后移过程中不断更新当前数字的个数        while(s[a[i]]&gt;1)&#123;            s[a[j]]--;            j++;           &#125;        &#x2F;&#x2F;更新区间长度        res&#x3D;max(res,i-j+1);    &#125;    cout&lt;&lt;res&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组元素目标和"><a href="#数组元素目标和" class="headerlink" title="数组元素目标和"></a>数组元素目标和</h4><blockquote><p>[数组元素目标和](<a href="https://www.acwing.com/problem/content/802/">800. 数组元素的目标和 - AcWing题库</a>) </p><p>目的是求两个有序数组中哪两个数的和为目标值x，输出两个下标。</p><p>以传统的双层循环进行判断没问题，但是O(n^2)，对于数据量过大会超限，所以用双指针进行优化，<strong>和纯暴力的O(n^2^)算法的区别就在于j指针不会回退</strong> ，这样就节省了时间和内存。</p><p>记录：第一次提交爆了，换long long 还是爆，确实没想到 j 指针回溯的问题，实际上KMP算法也是 j 不回溯的优化，所以将 j 指针从后往前依次判断即可快速得到两下标，而且 j 不用回溯.</p></blockquote><p>tips： 多画过程就好理解了</p><p>            注意上面加粗的 j 指针不会回溯</p><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;using namespace std;const int N &#x3D;100010;typedef long long LL;int n,m,x;int a[N],b[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;    for(int i&#x3D;0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);    for(int i&#x3D;0;i&lt;m;i++) scanf(&quot;%d&quot;,&amp;b[i]);    for(int i&#x3D;0,j&#x3D;m-1;i&lt;n;i++)&#123;          &#x2F;&#x2F;双指针移动过程可以画一画，很好理解           while(j&gt;&#x3D;0&amp;&amp;(a[i]+b[j])&gt;x) j--;        &#x2F;&#x2F;这样的j就可以移动到第二个数组中能与第一个数组中某元素和为x的元素，        &#x2F;&#x2F;随后i往后移，由于有序数组，便可以找到两个元素        if(j&gt;&#x3D;0&amp;&amp;(a[i]+b[j])&#x3D;&#x3D;x) cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;        &#125;    return 0;&#125;&#x2F;*第一次提交：wa    好像是int爆了,不清楚哎 &#x2F;&#x2F;每次遍历完第二个数组后，j要从第一个位置重新开始匹配 和双层循环没区别了*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h4><blockquote><p>判断a数组是不是b数组的子序列，并不是连续的子序列，但是需要满足原顺序相同</p><p>如1，3，5 是1，2，3，4，5的子序列，其中数组元素可以为重复的</p><p>    刚开始试了下，用双指针，移动的话感觉没问题，样例能过几个，原因有两个：</p><p>1.当是重复元素时，我的 j 指针由于是a[i]!&#x3D;b[j]时才移动，如果a中有重复的话，j就一直不动了，然后当a数组的指针 i 走完，j还是没动（a数组全相同的情况下），所以一定还是输出Yes。解决方法，就算想同了 j 也后移一个，这样可以防止重复元素时的错误，并且可以少一次while判断。</p><p>2.当b数组是逆序时，即1,3,5对应5,4,3,2,1；这时候 j 指针由于一直不等于 i 指向的元素1，直到 j 指向第五个元素5时，j停止移动，i++，然后a中元素肯定不可能与j指向元素相同了，j就++，此时j&gt;m-1(元素从0开始存的话),while就一直不执行了，结果输出的不对。</p><p> 根据2中的错误，可以在移动完j后（while结束），判断此时j是不是大于m-1，是的话就输出No然后ret，如果不是，那就再次j++，开始找下一个相同元素，只要j不越界就说明可以找到与 i 相同的元素，for循环外层输出Yes即可。</p><p>当然，可以记录相同元素的个数，如果等于a的长度，也说明是子序列</p><p>代码给出第二种,但是这个人是 j 作为外层循环，而判断条件是a[i]&#x3D;&#x3D;b[j]时移动 i 而不是 j，循环结束后i到头了，说明匹配成功</p></blockquote><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;using namespace std;const int N &#x3D;1e5+10;int n,m;int a[N],b[N];int main()&#123;  cin&gt;&gt;n&gt;&gt;m;  for(int i&#x3D;0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]);  for(int i&#x3D;0;i&lt;m;i++) scanf(&quot;%d&quot;,&amp;b[i]);int cnt&#x3D;0;  for(int i&#x3D;0,j&#x3D;0;i&lt;n;i++)&#123;    while(j&lt;m&amp;&amp;a[i]!&#x3D;b[j]) j++;    if(j&gt;m-1) &#123;        cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        return 0;    &#125;    j++;        &#x2F;&#x2F;很重要，用来跳过重复元素&#125;  cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;  return 0;&#125;&#x2F;&#x2F;第二种#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N&#x3D;1e5+10;int a[N],b[N];int main()&#123;    int n,m;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i &#x3D; 0;i &lt; n; i++) scanf(&quot;%d&quot;,&amp;a[i]);    for(int j &#x3D; 0;j &lt; m; j++) scanf(&quot;%d&quot;,&amp;b[j]);    int i &#x3D; 0;    for(int j &#x3D; 0;j &lt; m; j++)    &#123;        if(i &lt; n&amp;&amp;a[i] &#x3D;&#x3D; b[j])  i++;    &#125;    if(i &#x3D;&#x3D; n) puts(&quot;Yes&quot;);    else puts(&quot;No&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><blockquote><p>两个常用的位运算你操作    </p><ol><li><p><strong><mark>n&gt;&gt;k&amp;1</mark></strong>    得到n的二进制数的第k位是多少，注意此处的位次是由最右边开始往左边计数，从0开始  即：0101 对应序号3,2,1,0位, 而&amp;1是得到最后一位，则完成上述操作</p><p>例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int n&#x3D;10;for(int k&#x3D;3;k&gt;&#x3D;0;k--) cout&lt;&lt;(n&gt;&gt;k&amp;1);  得到10的二进制<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>lowbit(x)</strong> 操作：返回x的最后一位 1 以及 它后面的数</p><p>如：x&#x3D;1010  lowbit(x)返回 10</p><p>x&#x3D;10100   返回100</p><p>注意lowbit并非是一个内置函数，其内部实现为<mark>x&amp;(~x+1) </mark>或 <mark>x&amp;-x ;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int lowbit(int x)&#123;    return x &amp;-x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>int x&#x3D;10;<br>x-&#x3D;lowbit(x); &#x2F;&#x2F;二进制减去最后一个1以及以后的数，得到10（2进制）</p></li></ol><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D;100010;int n;int lwbit(int x) &#123;    return x&amp;-x;&#125;int main() &#123;    cin&gt;&gt;n;    while(n--) &#123;        int x;        cin&gt;&gt;x;        int ans&#x3D;0;        while(x) &#123;            x-&#x3D;lowbit(x);     &#x2F;&#x2F;每次删去最后一个1             ans++;        &#125;        cout&lt;&lt;ans&lt;&lt;&quot; &quot;;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><blockquote><p>特指整数的离散化。</p><p>离散化的含义：10^5个大小在(0–10^9)范围内的数，有些时候需要用这些数作为下标，就需要开辟很大的数组空间，所以进行映射使序列进行重新连续，大大减少空间浪费和效率，这个映射的过程就是离散化。</p><p>    解决离散化的两个主要问题：</p><p>1.<strong>数组a[]中可能有重复元素，如何进行映射呢    （需要进行去重操作，使用库函数unique……）</strong> </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; v;sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());unique函数返回的尾地址，到end()迭代器之间的区间erase即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>    关于unique函数</p><blockquote><p>该函数的作用是“去除”容器或者数组中相邻元素的重复出现的元素<br>(1) 这里的去除并非真正意义的erase，而是将重复的元素放到容器的末尾，返回值是去重之后的尾地址（迭代器）。<br>(2) unique针对的是相邻元素，所以对于顺序顺序错乱的数组成员，或者容器成员，需要先进行排序，可以调用std::sort()函数</p></blockquote><p>2.<strong>如何算出各个元素对应的离散值（使用二分）</strong> </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int find(int x)&#123;        &#x2F;&#x2F;查找x所在位置O(nlogn)    int l&#x3D;0,r&#x3D;v.size()-1;    while(l&lt;r)&#123;        int mid&#x3D;l+r&gt;&gt;1;        if(v[mid]&gt;&#x3D;x) r&#x3D;mid;        else l&#x3D;mid+1;  &#125;    return r+1;      1.如果加1说明映射到1，2，3，4，……    2.如果不加说明映射到0，1，2，3，……&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>题目[链接](<a href="https://www.acwing.com/problem/content/804/">802. 区间和 - AcWing题库</a>) ：</p><p>    假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p><p>现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。</p><p>接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p><p>    其中各个数据的范围为：  由x，l，r可以看出需要离散化</p><img title="" src="file:///C:/Users/Lenovo/AppData/Roaming/marktext/images/2023-01-08-22-18-38-image.png" alt="" width="235"><p>分析：需要对x以及l，r都进行离散化，因为它们范围太大了，映射后可以对$a[k]+&#x3D;c$,其中k为x映射后的下标，随后求出离散化后的 l，r，对在$[kl,kr]$ 区间内的k进行求和即可。求和可以用前缀和进行快速计算。</p></blockquote></blockquote><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D;3e5+10;  &#x2F;&#x2F;n+2m个下标会被用到，因此需要开300010#define endl &#39;\n&#39;int n,m;vector&lt;int&gt; v; &#x2F;&#x2F;存放所有需要离散化的下标x,l,rint a[N];int s[N];&#x2F;&#x2F;前缀和数组vector&lt;pair&lt;int,int&gt;&gt; add,que;     &#x2F;&#x2F;add存放n次在x位置添加的元素值与该位置                                   &#x2F;&#x2F;que存放待求和的l，r&#x2F;&#x2F;求离散化后的结果kint find(int x) &#123;    int l&#x3D;0,r&#x3D;v.size()-1;    while(l&lt;r) &#123;        int mid&#x3D;l+r&gt;&gt;1;        if(v[mid]&gt;&#x3D;x) r&#x3D;mid;        else l&#x3D;mid+1;    &#125;    return r+1;  &#x2F;&#x2F;映射为1，2，3，4……  映射到1因为前缀和求解从1开始较方便&#125;int main() &#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i&#x3D;0; i&lt;n; i++) &#123;        int x,c;        scanf(&quot;%d%d&quot;,&amp;x,&amp;c);        add.push_back(&#123;x,c&#125;);    &#x2F;&#x2F;加        v.push_back(x); &#x2F;&#x2F;待离散化下标    &#125;    for(int i&#x3D;0; i&lt;m; i++) &#123;        int l,r;        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);        que.push_back(&#123;l,r&#125;);   &#x2F;&#x2F;求        v.push_back(l);        v.push_back(r);  &#x2F;&#x2F;待处理下标    &#125;    &#x2F;&#x2F;去重    sort(v.begin(),v.end());    v.erase(unique(v.begin(),v.end()),v.end());    for(pair&lt;int,int&gt; c:add) &#123;        int x&#x3D;find(c.first); &#x2F;&#x2F;离散化添加的下标        a[x]+&#x3D;c.second;  &#x2F;&#x2F;对应位置加上c    &#125;    &#x2F;&#x2F;预处理前缀和数组 ,经上一步操作，已经将对应的映射位置添加好元素    for(int i&#x3D;1; i&lt;&#x3D;v.size(); i++) &#123;    &#x2F;&#x2F;去重后的v的长度已经是现存元素的个数了        s[i]&#x3D;s[i-1]+a[i];    &#125;    &#x2F;&#x2F;求解区间和    for(pair&lt;int,int&gt; c:que) &#123;        int l&#x3D;find(c.first);        int r&#x3D;find(c.second);        cout&lt;&lt;s[r]-s[l-1]&lt;&lt;endl;  &#x2F;&#x2F;得到映射后的l到r的元素区间和    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><blockquote><p>[区间合并](<a href="https://www.acwing.com/problem/content/805/">803. 区间合并 - AcWing题库</a>) </p><blockquote><p> 给定 n 个区间 [li,ri]，要求合并所有有交集的区间。</p><p>注意如果在端点处相交，也算有交集。</p><p>输出合并完成后的区间个数。</p><p>例如：[1,3] 和 [2,6] 可以合并为一个区间 [1,6]。</p></blockquote><p>         类似贪心的做法（贪心专题中的区间分组，覆盖，选点等问题）</p><p>1.步骤 将区间按左端点进行排序   (可以重载运算operator或者写仿函数)</p><p>2.排序后可能的情况  </p><img title="" src="file:///C:/Users/Lenovo/AppData/Roaming/marktext/images/2023-01-09-10-01-05-image.png" alt="" width="272"><blockquote><p>第一种：包含，区间端点值st，ed不变</p><p>第二种：有交集，ed 更新为该区间的右端点</p><p>第三种：无交集，将之前的区间ans++。目标区间更新成这个无交集的区间。重复操作。</p></blockquote><p>根据每种情况，更新st和ed ，并在第三种情况下加入答案数组{st,ed};</p></blockquote><p>实现代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D;100010;int n;vector&lt;pair&lt;int,int&gt;&gt; v;void merge(vector&lt;pair&lt;int,int&gt;&gt; &amp;v)&#123;    vector&lt;pair&lt;int,int&gt;&gt; res;    &#x2F;&#x2F;sort默认按pair的first值进行升序排序    sort(v.begin(),v.end());    int st&#x3D;-2e9,ed&#x3D;-2e9;            &#x2F;&#x2F;包括最大区间的范围    &#x2F;&#x2F;遍历每个区间    for(pair&lt;int,int&gt; c:v)&#123;        if(ed&lt;c.first)&#123;           &#x2F;&#x2F;第三种情况            if(st!&#x3D;-2e9) res.push_back(&#123;st,ed&#125;);  &#x2F;&#x2F;不包括初始的超长区间            st&#x3D;c.first; ed&#x3D;c.second;  &#x2F;&#x2F;更新待处理区间为当前区间        &#125;else &#123;            &#x2F;&#x2F;区间有交集的情况,取并集 （包含关系或相重合关系，取两区间的右端点最大值即可）            ed&#x3D;max(ed,c.second);          &#125;    &#125;    &#x2F;&#x2F;特判,最后一个区间并没有小于的左端点，因此不会加入到res中，需要在数组不为空的情况下加一个区间    if(st!&#x3D;-2e9) res.push_back(&#123;st,ed&#125;);    v&#x3D;res; &#x2F;&#x2F;更新数组&#125;int main()&#123;    cin&gt;&gt;n;    for(int i&#x3D;0;i&lt;n;i++)&#123;        int l,r;        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);        v.push_back(&#123;l,r&#125;);    &#125;    merge(v);    cout&lt;&lt;v.size()&lt;&lt;endl;  &#x2F;&#x2F;区间合并后被更新了    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一个大佬写的带注释代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std ;typedef pair&lt;int,int&gt; pii ;vector&lt;pii&gt; nums,res ;int main()&#123;    int st&#x3D;-2e9,ed&#x3D;-2e9 ;                           &#x2F;&#x2F;ed代表区间结尾，st代表区间开头    int n ;    scanf(&quot;%d&quot;,&amp;n) ;     while(n--)    &#123;        int l,r ;         scanf(&quot;%d%d&quot;,&amp;l,&amp;r) ;        nums.push_back(&#123;l,r&#125;) ;    &#125;    sort(nums.begin(),nums.end()) ;                 &#x2F;&#x2F;按左端点排序    for(auto num:nums)                       &#123;        if(ed&lt;num.first)                            &#x2F;&#x2F;情况1：两个区间无法合并        &#123;            if(ed!&#x3D;-2e9) res.push_back(&#123;st,ed&#125;) ;   &#x2F;&#x2F;区间1放进res数组            st&#x3D;num.first,ed&#x3D;num.second ;            &#x2F;&#x2F;维护区间2        &#125;        &#x2F;&#x2F;情况2：两个区间可以合并，且区间1不包含区间2，区间2不包含区间1        else if(ed&lt;num.second)              ed&#x3D;num.second ;                         &#x2F;&#x2F;区间合并    &#125;      &#x2F;&#x2F;(实际上也有情况3：区间1包含区间2，此时不需要任何操作，可以省略)    &#x2F;&#x2F;注：排过序之后，不可能有区间2包含区间1    res.push_back(&#123;st,ed&#125;);    &#x2F;&#x2F;考虑循环结束时的st,ed变量，此时的st,ed变量不需要继续维护，只需要放进res数组即可。    &#x2F;&#x2F;因为这是最后的一个序列，所以不可能继续进行合并。    &#x2F;*    for(auto r:res)        printf(&quot;%d %d\n&quot;,r.first,r.second) ;    puts(&quot;&quot;) ;    *&#x2F;    &#x2F;&#x2F;(把上面的注释去掉，可以在调试时用)    printf(&quot;%d&quot;,res.size()) ;           &#x2F;&#x2F;输出答案    return 0 ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="第一部分就到此结束了……"><a href="#第一部分就到此结束了……" class="headerlink" title="第一部分就到此结束了……"></a>第一部分就到此结束了……</h3><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><blockquote><p>C++ STL简介<br>vector, 变长数组，倍增的思想<br>    size()  返回元素个数<br>    empty()  返回是否为空<br>    clear()  清空<br>    front()&#x2F;back()<br>    push_back()&#x2F;pop_back()<br>    begin()&#x2F;end()<br>    []<br>    支持比较运算，按字典序</p><p>pair&lt;int, int&gt;<br>    first, 第一个元素<br>    second, 第二个元素<br>    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</p><p>string，字符串<br>    size()&#x2F;length()  返回字符串长度<br>    empty()<br>    clear()<br>    substr(起始下标，(子串长度))  返回子串<br>    c_str()  返回字符串所在字符数组的起始地址</p><p>queue, 队列<br>    size()<br>    empty()<br>    push()  向队尾插入一个元素<br>    front()  返回队头元素<br>    back()  返回队尾元素<br>    pop()  弹出队头元素</p><p>priority_queue, 优先队列，默认是大根堆<br>    size()<br>    empty()<br>    push()  插入一个元素<br>    top()  返回堆顶元素<br>    pop()  弹出堆顶元素<br>    定义成小根堆的方式：priority_queue&lt;int, vector<int>, greater<int>&gt; q;</p><p>stack, 栈<br>    size()<br>    empty()<br>    push()  向栈顶插入一个元素<br>    top()  返回栈顶元素<br>    pop()  弹出栈顶元素</p><p>deque, 双端队列<br>    size()<br>    empty()<br>    clear()<br>    front()&#x2F;back()<br>    push_back()&#x2F;pop_back()<br>    push_front()&#x2F;pop_front()<br>    begin()&#x2F;end()<br>    []</p><p>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br>    size()<br>    empty()<br>    clear()<br>    begin()&#x2F;end()<br>    ++, – 返回前驱和后继，时间复杂度 O(logn)</p><pre><code>set/multiset    insert()  插入一个数    find()  查找一个数    count()  返回某一个数的个数    erase()        (1) 输入是一个数x，删除所有x   O(k + logn)        (2) 输入一个迭代器，删除这个迭代器    lower_bound()/upper_bound()        lower_bound(x)  返回大于等于x的最小的数的迭代器        upper_bound(x)  返回大于x的最小的数的迭代器map/multimap    insert()  插入的数是一个pair    erase()  输入的参数是pair或者迭代器    find()    []  注意multimap不支持此操作。 时间复杂度是 O(logn)    lower_bound()/upper_bound()</code></pre><p>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表<br>    和上面类似，增删改查的时间复杂度是 O(1)<br>    不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，–</p><p>bitset, 圧位<br>    bitset&lt;10000&gt; s;<br>    ~, &amp;, |, ^<br>    &gt;&gt;, &lt;&lt;<br>    &#x3D;&#x3D;, !&#x3D;<br>    []</p><pre><code>count()  返回有多少个1any()  判断是否至少有一个1none()  判断是否全为0set()  把所有位置成1set(k, v)  将第k位变成vreset()  把所有位变成0flip()  等价于~flip(k) 把第k位取反</code></pre><p>作者：yxc<br>链接：<a href="https://www.acwing.com/blog/content/404/">https://www.acwing.com/blog/content/404/</a><br>来源：AcWing<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACWing数据结构</title>
      <link href="/2022/08/04/shu-ju-jie-gou/"/>
      <url>/2022/08/04/shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><blockquote><p>本部分用数组模拟<code>单链表</code> </p><p>几个常用的操作，初始化，删除下标为k-1的元素，在头结点插入元素，在下标为k-1的元素后面插入一个元素 。</p><p><img src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-01-10-22-04-52-image.png"></p><blockquote><p>模板：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;&#x2F;&#x2F; 初始化void init()&#123;    head &#x3D; -1;    idx &#x3D; 0;&#125;&#x2F;&#x2F; 在链表头插入一个数avoid add_head(int a)&#123;    e[idx] &#x3D; a, ne[idx] &#x3D; head, head &#x3D; idx ++ ;&#125;&#x2F;&#x2F;在下标为k-1的元素后插入一个元素void insert(int k,int x)&#123;    e[idx]&#x3D;x;    ne[idx]&#x3D;ne[k];    ne[k]&#x3D;idx;    idx++;&#125;&#x2F;&#x2F; 将头结点删除，需要保证头结点存在void remove()&#123;    head &#x3D; ne[head];&#125;&#x2F;&#x2F;如果删除头结点，即：k为0时，直接head&#x3D;ne[head]即可，需要特判<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></blockquote><p>题目链接[单链表](<a href="https://www.acwing.com/problem/content/828/">826. 单链表 - AcWing题库</a>)</p><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;数组模拟单链表      常用于：邻接表存储图和树#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D;100010;&#x2F;&#x2F;head表示头指针，e存元素值，ne存next指针，idx指向当前操作的结点int e[N],ne[N],idx,head;&#x2F;&#x2F;初始化void init() &#123;    head&#x3D;-1;   &#x2F;&#x2F;头指针指向空    idx&#x3D;0;     表示从第一个结点开始使用&#125;&#x2F;&#x2F;插入到头结点位置void add_head(int x) &#123;    e[idx]&#x3D;x;         待插入结点的准备    ne[idx]&#x3D;head;    head&#x3D;idx;        头指针重新指向头结点    idx++;           开始处理下一个位置&#125;&#x2F;&#x2F;将元素插入到下标为k的后面  即：在idx下标为k-1的点的后面加一个元素void add(int k,int x) &#123;    e[idx]&#x3D;x;            idx在每次插入后都会后移到最后一个元素的下一个位置，所以不用担心会误修改    ne[idx]&#x3D;ne[k];       先指向k的下一个结点，前面再接上k    ne[k]&#x3D;idx;    idx++;&#125;&#x2F;&#x2F;删除下标为k的点的后一个点  即：删除idx下标为k-1的点void del(int k) &#123;    ne[k]&#x3D;ne[ne[k]];&#125;注意idx就算插入元素后再删除该元素，idx也不会回溯，而是一直往后，这样就完成了题目要求的第k个数（第k个插入的数）int main() &#123;    int m;    cin&gt;&gt;m;    init(); &#x2F;&#x2F;初始化    while(m--) &#123;        int k,x;        char c;        cin&gt;&gt;c;        if(c&#x3D;&#x3D;&#39;H&#39;) &#123;            cin&gt;&gt;x;            add_head(x);        &#125; else if(c&#x3D;&#x3D;&#39;D&#39;) &#123;            cin&gt;&gt;k;            if(!k)  head&#x3D;ne[head];    特判，当删除头结点时，head指针直接指向头结点的下一个指针即可            del(k-1);        &#125; else if(c&#x3D;&#x3D;&#39;I&#39;) &#123;            cin&gt;&gt;k&gt;&gt;x;            add(k-1,x);        &#125;    &#125;    &#x2F;&#x2F;遍历，从头结点开始走    for(int i&#x3D;head; i!&#x3D;-1; i&#x3D;ne[i]) &#123;        cout&lt;&lt;e[i]&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><blockquote><p>    为省事，将存放元素的数组e的0和1下标对应位置分别存放头和尾指针，这样的话<strong>idx就从2开始存元素，因此第k个插入的元素下标对应k+1</strong> .这点要谨记。</p><p> 模板：</p><blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;e存元素value，l存左指针，r存右指针,idx指向当前操作结点int e[N],l[N],r[N],idx;&#x2F;&#x2F;初始化void init()&#123;    &#x2F;&#x2F;为省事，0表示左端点head，1表示右端点tail    r[0]&#x3D;1; l[1]&#x3D;0;   两端点head和tail分别为对方的左右指针,形成初始闭环    idx&#x3D;2;            0和1已经用于头尾指针了，从2开始存元素&#125;&#x2F;&#x2F;在下标为k的点的右边插入一个数xvoid add(int k,int x)&#123;    e[idx]&#x3D;x;    &#x2F;&#x2F;改四条指针的指向    l[idx]&#x3D;k;           将新结点的左指针指向k    r[idx]&#x3D;r[k];        将当前元素的右指针指向k的下一个元素    l[r[k]]&#x3D;idx;        将原本k右边的数的左指针指向新插入的结点    r[k]&#x3D;idx;    idx++;&#125;&#x2F;&#x2F;如果在k的左边插入一个点，可以直接调用add([l[k]]) ;  即：在k的前一个元素的右边插入一个元素&#x2F;&#x2F;删除第k个元素void remove(int k)&#123;    &#x2F;&#x2F;令其左边的元素的右指针指向其右边的元素，将右边的元素的左指针指向其左边的元素    r[l[k]]&#x3D;r[k];    l[r[k]]&#x3D;l[k];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote></blockquote><blockquote><p>其中需要注意的是：</p><p>1.插入操作函数，默认为在下标为k+1的元素的右边插入一个元素，如果需要在其左侧插入一个元素，使用&lt;add(l[k+1]);&gt;即在其左边的数的右边插入该数。</p><p>2.元素从2开始存，所以第k个插入的数的下标对应k+1，如果将尾指针放在数组尾部，其实可以实现k下标对应k，但是废空间，可以视情况而定（待元素个数很多时，将尾指针定义到尾部）</p><p>3.插入元素到左右端，也是可以根据关系在0的右边和1的左边插入元素  </p><p>    对应&lt;**add(0,x);   add(l[1],x**);&gt;</p></blockquote><p>题目链接[双链表](<a href="https://www.acwing.com/problem/content/829/">827. 双链表 - AcWing题库</a>) </p><p>完整代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;const int N &#x3D;100010;&#x2F;&#x2F;e存元素value，l存左指针，r存右指针,idx指向当前操作结点int e[N],l[N],r[N],idx;&#x2F;&#x2F;初始化void init()&#123;    &#x2F;&#x2F;为省事，0表示左端点head，1表示右端点tail    r[0]&#x3D;1; l[1]&#x3D;0;   &#x2F;&#x2F;两端点head和tail分别为对方的左右指针,形成初始闭环    idx&#x3D;2;          &#x2F;&#x2F;0和1已经用于头尾指针了，从2开始存元素&#125;&#x2F;&#x2F;在下标为k的点的右边插入一个数xvoid add(int k,int x)&#123;    e[idx]&#x3D;x;    &#x2F;&#x2F;改四条指针的指向    l[idx]&#x3D;k;           &#x2F;&#x2F;将新结点的左指针指向k    r[idx]&#x3D;r[k];        &#x2F;&#x2F;将当前元素的右指针指向k的下一个元素    l[r[k]]&#x3D;idx;        &#x2F;&#x2F;将原本k右边的数的左指针指向新插入的结点    r[k]&#x3D;idx;    idx++;&#125;&#x2F;&#x2F;如果在k的左边插入一个点，可以直接调用add([l[k]]) ;  即：在k的前一个元素的右边插入一个元素&#x2F;&#x2F;删除第k个元素void remove(int k)&#123;    &#x2F;&#x2F;令其左边的元素的右指针指向其右边的元素，将右边的元素的左指针指向其左边的元素    r[l[k]]&#x3D;r[k];    l[r[k]]&#x3D;l[k];&#125;&#x2F;&#x2F;在最左端插入一个数    发现就是在0的右边插入一个数  ,在最右侧插入同理在1的左边插入&#x2F;&#x2F; void add_l(int x)&#123;&#x2F;&#x2F;     e[idx]&#x3D;x;&#x2F;&#x2F;     r[idx]&#x3D;r[0];&#x2F;&#x2F;     l[idx]&#x3D;0;&#x2F;&#x2F;     l[r[0]]&#x3D;idx;&#x2F;&#x2F;     r[0]&#x3D;idx++;&#x2F;&#x2F; &#125;int main()&#123;    init();    int m;    cin&gt;&gt;m;    while(m--)&#123;        string c;        int k,x;        cin&gt;&gt;c;        if(c&#x3D;&#x3D;&quot;L&quot;)&#123;            cin&gt;&gt;x;            add(0,x);        &#125;else if(c&#x3D;&#x3D;&quot;R&quot;)&#123;            cin&gt;&gt;x;            add(l[1],x);   &#x2F;&#x2F;在最右端插入一个元素相当于在1的左边元素的右边插入一个元素        &#125;else if(c&#x3D;&#x3D;&quot;D&quot;)&#123;            cin&gt;&gt;k;            remove(k+1);            &#x2F;&#x2F;这里注意第k个插入的点的下标应该是k+1，因为第一个插入的点在下标为2的位置        &#125;else if(c&#x3D;&#x3D;&quot;IL&quot;)&#123;                cin&gt;&gt;k&gt;&gt;x;                &#x2F;&#x2F; cout&lt;&lt;l[k+1]&lt;&lt;&quot;---------&quot;&lt;&lt;endl;                add(l[k+1],x);         &#x2F;&#x2F;k+1同理对应第k个数            &#125;else if(c&#x3D;&#x3D;&quot;IR&quot;)&#123;                cin&gt;&gt;k&gt;&gt;x;                add(k+1,x);            &#125;        &#125;    &#x2F;&#x2F;遍历双链表      从0头结点的下一个结点开始出发，直到遇到右尾结点1    for(int i&#x3D;r[0];i!&#x3D;1;i&#x3D;r[i])&#123;        cout&lt;&lt;e[i]&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><blockquote><p>看模板吧</p></blockquote><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="开放寻址法（最常用）"><a href="#开放寻址法（最常用）" class="headerlink" title="开放寻址法（最常用）"></a>开放寻址法（最常用）</h4><blockquote><p>定义一个一维数组,大小一般开题目要求的2–3倍（2e5,3e5—）；</p><p>1.插入：利用哈希函数得到映射后的k，在数组的对应k位置插入该元素，如果位置已经存在一个元素了，就依次找空的位置插入。</p><p>2.查找：看第映射后的第k个位置，是不是有元素</p><blockquote><p>（1）有元素，并且等于x    （找到）</p><p>（2）有元素，但是不等于x  ，则继续往后找      （如果不为空但是不等于x，可能是被占位了，x则被存在后面的位置或者不存在）</p><p>（3）无元素，则不存在x （因为如果当前为空，说明没有数映射到这个位置）</p></blockquote><p>3.删除：并不是实际删除，而是用一个标记.(0x3f3f3f3f)(大于1e9的数，不在范围内)</p><p>主要部分find</p><blockquote><p><img src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-01-15-15-43-19-image.png"></p><img title="" src="file:///C:/Users/Lenovo/AppData/Roaming/marktext/images/2023-01-15-15-40-06-image.png" alt="" width="459"><p><img src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-01-15-15-43-37-image.png"></p><p>当前位置不等于空位置时，并且不等于该元素时，找下一个可以插入的位置k++（注意k的最大取值，需要判断是否超过数组最大范围）</p><p>如果该位置为空，则返回可以插入的位置，即当前位置</p></blockquote></blockquote><p>例题：<a href="https://www.acwing.com/problem/content/842/">840. 模拟散列表 - AcWing题库</a> </p><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D;200003,null&#x3D;0x3f3f3f3f;int h[N];int find(int x)&#123;    int k&#x3D;(x%N+N)%N;    while(h[k]!&#x3D;null &amp;&amp; h[k]!&#x3D;x)&#123;    &#x2F;&#x2F;如果该位置不是空的并且不是x，则往后找        k++;        if(k&#x3D;&#x3D;N) k&#x3D;0;    &#125;    return k;&#125;int main()&#123;    int n;    cin&gt;&gt;n;        &#x2F;&#x2F;数组该位置为0x3f时 就认为空，因为不在数据范围内    memset(h,0x3f,sizeof h);        memset 以字节set，并且int类型，则4*0x3f 足以超过1e9    while(n--)&#123;        char c;int x;        cin&gt;&gt;c;        if(c&#x3D;&#x3D;&#39;I&#39;)&#123;            cin&gt;&gt;x;            int k&#x3D;find(x);            h[k]&#x3D;x;        &#125;else &#123;            cin&gt;&gt;x;            int k&#x3D;find(x);            if(h[k]!&#x3D;null) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;            else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="拉链法（类似邻接表）"><a href="#拉链法（类似邻接表）" class="headerlink" title="拉链法（类似邻接表）"></a>拉链法（类似邻接表）</h4><blockquote><p>以数组h的每个元素为每个链表的头指针，如果某些数的k值相同，则插入到同一个h[k]的子链表上，最后在该链表上查询目标元素。</p></blockquote><p>题目链接<a href="https://www.acwing.com/problem/content/842/">模拟散列表</a>         注：保存过题解</p><p>代码如下：（附set做法）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">### set<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;int main() &#123;    set&lt;int&gt; s;    int n;    cin&gt;&gt;n;    while(n--) &#123;        char c;        int x;        cin&gt;&gt;c;        if(c&#x3D;&#x3D;&#39;I&#39;) &#123;            cin&gt;&gt;x;            s.insert(x);        &#125; else &#123;            cin&gt;&gt;x;            if(s.find(x)!&#x3D;s.end()) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;            else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">### 哈希函数法<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D;100010;int h[N],e[N],ne[N],idx; &#x2F;&#x2F;类似于邻接表，在哈希函数处理后放入对应位置的链表上，最后查询即可void insert(int x) &#123;    int k&#x3D;(x%N+N)%N; &#x2F;&#x2F;确保余数是正数，否则越界，因为x不一定是正数    e[idx]&#x3D;x;    ne[idx]&#x3D;h[k];    &#x2F;&#x2F;若k相同。则会从头部插入k对应的单链表    h[k]&#x3D;idx++;&#125;bool find(int x) &#123;    int k&#x3D;(x%N+N)%N;    for(int i&#x3D;h[k]; i!&#x3D;-1; i&#x3D;ne[i]) &#123;        if(x&#x3D;&#x3D;e[i]) return true;             &#x2F;&#x2F;遍历当前k的链表    &#125;    return false;&#125;int main() &#123;    int n;    cin&gt;&gt;n;&#x2F;&#x2F;单链表指针指向为空时默认为-1；    memset(h,-1,sizeof h);    while(n--) &#123;        char c;        int x;        cin&gt;&gt;c;        if(c&#x3D;&#x3D;&#39;I&#39;) &#123;            cin&gt;&gt;x;            insert(x);        &#125; else &#123;            cin&gt;&gt;x;            if(find(x)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;            else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串hash-字符串前缀hash法"><a href="#字符串hash-字符串前缀hash法" class="headerlink" title="字符串hash (字符串前缀hash法)"></a>字符串hash (字符串前缀hash法)</h4><blockquote><p>好处：用O(1)的时间复杂度求出任一子字符串的哈希值</p><p>            <strong><mark>对于某些复杂的KMP问题可以用此方法水过去</mark></strong> </p><p>    预处理前缀字符串，假设字符串为p进制的数，求出它的10进制数并对q取模，则可得到所有前缀的哈希值；如h[1]&#x3D;”A”,h[2]&#x3D;”AB”;……其中h[0]规定为0,表示前0个字符为空,且存的不是字符串(“A”,”AB”等)，而是p进制的对应哈希值。</p><p>一般的：p进制取131  或 13331 时，冲突的概率较低</p><p>                q一般取2^64 （类型：unsigned long long）  (此时就可以省去取模的运算，更快)</p><p>结果：将每个前缀字符串映射成一个在[0 , 2^64-1] 范围内的整数</p><p>假如有一个字符串 abcdefs;</p><p>其中abc的哈希值为 hash(abc), 那么abcd的哈希值就为 hash(abc)*131+4 ;  &#x2F;&#x2F;根据计算10进制过程推出，并且由于mod(q)的原因，不用担心hash值大小</p><p>则得出预处理公式：&lt; <mark>**hash(i)&#x3D;hash(i-1)*131+str[i];**</mark> &gt;    <u>hash[0]&#x3D;0;</u> </p><p>&#x2F;&#x2F;str存输入的字符串,需要变为对应的序号，如果是全小写字符，则 <strong>str[i]-‘a’+1;</strong> </p><blockquote><p><strong>纠正：只要str[i]不是0就可以，所以也没必要-‘a’+1，所以就不用担心字符是否为大写小写字母或数字了</strong> </p></blockquote><p><mark>求任一子字符串的哈希值 </mark>   (前提：求出预处理前缀字符串的哈希值)</p><p>    求[L,R]的哈希值，<mark>*<em>h(L–R)   &#x3D; h[R]-h[L-1]<em>131^(R-L+1);</em></em> </mark>     即：在求字符串abcd的子串cd 哈希值的时候，可以用hash(abcd)减去hash(ab)*131^2; 这样就可求出。</p><p>而131的次方 提前预处理存入p[N]数组中, p[i] 对应131^i <mark>*<em>p[i]&#x3D;p[i-1]<em>base</em></em>;  </mark>  </p><p>    又如：区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，<br>乘上 P2 把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。</p><blockquote><img src="file:///C:/Users/Lenovo/AppData/Roaming/marktext/images/2023-01-15-21-52-10-image.png" title="" alt="" width="502"><img src="file:///C:/Users/Lenovo/AppData/Roaming/marktext/images/2023-01-15-22-07-59-image.png" title="" alt="" width="583"></blockquote></blockquote><p>例题：[兔子与兔子](<a href="https://www.acwing.com/problem/content/140/">138. 兔子与兔子 - AcWing题库</a>)    注意：此题字符串仅有小写字母</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D;1000010,base&#x3D;131;typedef unsigned long long ull;char str[N];int m;ull h[N];   &#x2F;&#x2F;存放前缀字符串的哈希值ull p[N];   &#x2F;&#x2F;存放计算10进制时的131次方,可以理解为从个位数往前按位数乘的131次方ull get(int l,int r)&#123;    return h[r]-h[l-1]*p[r-l+1];           &#x2F;&#x2F;得出l到r区间的hash值&#125;int main()&#123;    scanf(&quot;%s&quot;,str+1);       int n&#x3D;strlen(str+1);             &#x2F;&#x2F;加头文件string.h    h[0]&#x3D;0;         &#x2F;&#x2F;初始化0位置    p[0]&#x3D;1;         &#x2F;&#x2F;初始化个位数*的次方    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;        h[i]&#x3D;h[i-1]*base + str[i]-&#39;a&#39;+1;         p[i]&#x3D;p[i-1]*base;    &#125;    cin&gt;&gt;m;    while(m--)&#123;        int l1,r1,l2,r2;        scanf(&quot;%d%d%d%d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2);        if(get(l1,r1)&#x3D;&#x3D;get(l2,r2)) puts(&quot;Yes&quot;);        else puts(&quot;No&quot;);        &#x2F;&#x2F; printf(&quot;%llu\n&quot;,get(l,r));    &#125;    &#x2F;&#x2F; for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;    &#x2F;&#x2F;     printf(&quot;%llu\n&quot;,h[i]);         &#x2F;&#x2F;测试hash值            &#x2F;&#x2F; &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：这种方法可以过全部样例，如果时间有限，用string的<strong>substr(pos,n)</strong> 可以过一定的样例骗点分，但是还是多用哈希这种方法，还是很容易熟悉的。</p></blockquote><blockquote><p>substr从第pos个位置，开始拿出n个字符组成的字符串</p></blockquote><p>例题2:[字符串哈希](<a href="https://www.acwing.com/problem/content/843/">841. 字符串哈希 - AcWing题库</a>) </p><blockquote><p>该题与上题的不同在于 字符串中不止小写字母，还有大写字母和数字。</p><p>但是纠正后，str[i]只要不等于0都可以。所以方法相同。</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D;100010,base&#x3D;131;typedef unsigned long long ull;char str[N];int n,m;ull h[N];ull p[N];ull get(int l,int r)&#123;    return h[r]-h[l-1]*p[r-l+1];           &#x2F;&#x2F;得出l到r区间的hash值&#125;int main() &#123;    cin&gt;&gt;n&gt;&gt;m;    scanf(&quot;%s&quot;,str+1);    h[0]&#x3D;0;    p[0]&#x3D;1;     &#x2F;&#x2F;忘记初始化了    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;        h[i]&#x3D;h[i-1]*base + str[i];        p[i]&#x3D;p[i-1]*base;    &#125;    while(m--)&#123;        int l1,r1,l2,r2;        scanf(&quot;%d%d%d%d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2);        if(get(l1,r1)&#x3D;&#x3D;get(l2,r2)) puts(&quot;Yes&quot;);        else puts(&quot;No&quot;);        &#x2F;&#x2F; printf(&quot;%llu  %llu\n&quot;,get(l1,r1),get(l2,r2));    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Trie字典树-检索"><a href="#Trie字典树-检索" class="headerlink" title="Trie字典树      (检索)"></a>Trie字典树      (检索)</h3><blockquote><p>高效地存储和查找字符串集合的数据结构</p><p>    存储:  星号为标记一个字符串结束     </p><p>从根结点开始，只要遇到某个字符不存在就创建该结点</p><img src="file:///C:/Users/Lenovo/AppData/Roaming/marktext/images/2023-01-19-17-16-31-image.png" title="" alt="" width="361"><p>    查找：遍历待查找字符串，从根结点开始找对应的下一字符</p></blockquote><h4 id="字符串统计"><a href="#字符串统计" class="headerlink" title="字符串统计"></a>字符串统计</h4><blockquote><p><a href="https://www.acwing.com/problem/content/837/">835. Trie字符串统计 - AcWing题库</a> </p><p>插入字符串，查找字符串出现的个数</p><img src="file:///C:/Users/Lenovo/Desktop/pic/字符串统计.png" title="" alt="" width="476"></blockquote><blockquote><p>用map做结果：</p><p>通过了 18&#x2F;18个数据    运行时间： 111 ms    运行空间： 480 KB</p><p>用Trie字典树高效存储：</p><p>通过了 18&#x2F;18个数据    运行时间： 58 ms     运行空间： 10584 KB</p><p><strong>空间换时间</strong> (感觉map能过就不用trie了)</p></blockquote><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int N &#x3D;100010;int son[N][26];       &#x2F;&#x2F;假如是son[1][2]&#x3D;3;说明结点1有一个结点为3的儿子c (从0开始表示a……z); 并且每个结点最多有26个分支int cnt[N],idx;     &#x2F;&#x2F;cnt记录某个结点作为字符串结尾的次数char str[N];void insert(char str[])&#123;    int p&#x3D;0;    &#x2F;&#x2F;类似指针，指向每一个要插入的子结点的父母    &#x2F;&#x2F;这里str[i]用了字符串特性：结尾的 &#39;&#x2F;0&#39;    for(int i&#x3D;0;str[i];i++)&#123;        int u&#x3D;str[i]-&#39;a&#39;;     &#x2F;&#x2F;将每个字符转化为数字        if(!son[p][u]) son[p][u]&#x3D;++idx;         &#x2F;&#x2F;如果不存在该字符,新建一个并给孩子编号        p&#x3D;son[p][u];     &#x2F;&#x2F;p指针移向当前结点的子结点，进行下一步插入    &#125;    cnt[p]++;      &#x2F;&#x2F;循环结束后，p指向的是字符串str的最后一个结点&#125;&#x2F;&#x2F;查询，返回字符串出现的次数int query(char str[])&#123;    int p&#x3D;0;    for(int i&#x3D;0;str[i];i++)&#123;        int u&#x3D;str[i]-&#39;a&#39;;        if(!son[p][u]) return 0;          &#x2F;&#x2F;如果当前结点p不存在相应的孩子，则说明无这个字符串，直接返回        &#x2F;&#x2F;否则就将结点p指向子孩子对应的结点        p&#x3D;son[p][u];    &#125;    return cnt[p];       &#x2F;&#x2F;返回以当前字符为结尾的字符串个数&#125;int main()&#123;    int n;    cin&gt;&gt;n;    while(n--)&#123;       char c[2];       scanf(&quot;%s&quot;,c);      if(c[0]&#x3D;&#x3D;&#39;I&#39;)&#123;          scanf(&quot;%s&quot;,str);          insert(str);      &#125;else &#123;          scanf(&quot;%s&quot;,str);          printf(&quot;%d\n&quot;,query(str));      &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="最大异或对"><a href="#最大异或对" class="headerlink" title="最大异或对"></a>最大异或对</h4><blockquote><p> <a href="https://www.acwing.com/problem/content/145/">143. 最大异或对 - AcWing题库</a> </p><p><img src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-01-19-21-16-46-image.png"></p><p>暴力双层循环过5&#x2F;9样例</p></blockquote><blockquote><p>trie树做法：将每个数的二进制数插入字典树，查找时，在每一部选择上尽量选与当前位数不同的路，这样得到的结果是最大的异或数。</p><p>points：</p><p>1.二进制序列得到10进制数</p><p>2.二进制位运算  a&gt;&gt;k&amp;1;</p><p>3.选择路径</p></blockquote><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*&gt; 时间复杂度分析：用trie树在每一位二进制数中选择与当前目标数不同位的一条路，这样得到每一位尽可能的不同，最后得到的数就是最大异或数；这样最多10万个数，每个数最多走31条路(31次)，所以 31*1e5  大概是O(nlogn);*&#x2F;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)using namespace std;const int N &#x3D;100010;const int M &#x3D;N*31;    &#x2F;&#x2F;每个数的二进制数都有31位，所以要存这么多结点需要开M                      &#x2F;&#x2F;数据范围在2^31之内，则二进制数最多31位,则a二进制数的最左端是第30位int son[M][2],idx;void insert(int &amp;a)&#123;    int p&#x3D;0;    for(int i&#x3D;30;i&gt;&#x3D;0;i--)&#123;        int u&#x3D;a&gt;&gt;i&amp;1;   &#x2F;&#x2F;取a的二进制数的第30位，注意位数是从右往左0开始计数        if(!son[p][u]) son[p][u]&#x3D;++idx;        p&#x3D;son[p][u];    &#125;&#125;&#x2F;&#x2F;查询哪一个数与目标数的异或结果最大，返回该数int query(int a)&#123;    int res&#x3D;0;    int p&#x3D;0;    for(int i&#x3D;30;i&gt;&#x3D;0;i--)&#123;        int u &#x3D; a&gt;&gt;i&amp;1;        &#x2F;&#x2F;尽量走与当前位不同值的路   !u为非运算，x-&gt;0  0-&gt;x  （x为大于0的数）        &#x2F;&#x2F;如果相反的路存在，就走这条路,否则就直接走下一条        if(son[p][!u]) &#123;            p&#x3D;son[p][!u];            res&#x3D;res*2+!u;                    &#125;        else &#123;            p&#x3D;son[p][u];            res&#x3D;res*2+u;        &#125;    &#125;    return res;    &#x2F;*    这里的res&#x3D;res*2+!u&#x2F;u的运算，实际上就是2进制转10进制的运算,假如1001要接上下一位数1或0，变成10010或10011，    可以把1001左移一位得到10010,最后在最后一位加上u&#x2F;!u,而左移一位相当于*2。    这样的操作可以得到对应二进制序列代表的10进制数    *&#x2F;&#125;int main()&#123;    IOS;    int n;    cin&gt;&gt;n;    &#x2F;&#x2F;不需要实际读入，记录一下res即可    ,当然也可以存数组    int res&#x3D;0;    for(int i&#x3D;0;i&lt;n;i++) &#123;        int a;        cin&gt;&gt;a;        insert(a);        int s&#x3D;query(a);        res&#x3D;max(res,a^s);    &#125;    cout&lt;&lt;res&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><blockquote><p>主要完成两个操作：       时间复杂度可以接近O(1)</p><p>1.合并集合        2.询问两个数是否在同一个集合中</p><p>    如果需要用到这两个操作可以使用并查集</p></blockquote><blockquote><p>思路：将每个集合（树）的根结点作为代表结点，并将该集合的每一个结点的父结点存储下来，p[x]存储x的父结点的编号</p><p><em>(1).判断树根：</em>  </p><p>判断当前结点是否为树根就看当前( <mark> <strong>p[x]&#x3D;&#x3D;x</strong> </mark> )是否成立</p><p><strong><u>(2).求x对应的树根编号，即得到x所在集合的编号</u></strong> </p><p>从当前结点，依次往父结点靠拢，并判断是否为根结点 </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">while(p[x]!&#x3D;x)&#123;    x&#x3D;p[x];&#125;    &#x2F;&#x2F;最后x就为根结点的编号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><mark><strong>路径压缩优化</strong></mark> ：由于从x位置遍历到根结点，所以树层数高的时候复杂度较高</p><p>在往上遍历时，直到找到根结点，就把所有路经上的结点的父结点变为根结点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">核心递归操作int find(int x)&#123;   &#x2F;&#x2F;返回x的祖宗结点+路径压缩    if(p[x]!&#x3D;x) p[x]&#x3D;find(p[x]);return p[x];      &#x2F;&#x2F;直到某个结点的父结点是根结点后返回，这样就可以将路径                  &#x2F;&#x2F;上所有的结点的父结点变成根结点&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将两棵树中其中一颗的根结点变成另一颗树的孩子，这样就可以查找时有共同的根结点，即在一个集合中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">假设x集合的根结点编号为a，y集合的根结点编号为b则  p[a]&#x3D;b;  or  p[b]&#x3D;p[a];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p>y总视频课笔记：参考</p><blockquote><img src="file:///C:/Users/Lenovo/AppData/Roaming/marktext/images/2023-01-22-18-15-53-image.png" title="" alt="" width="427"></blockquote><h4 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h4><blockquote><p><a href="https://www.acwing.com/problem/content/838/">836. 合并集合 - AcWing题库</a> </p><p><img src="C:\Users\Lenovo\AppData\Roaming\marktext\images\2023-01-22-19-48-07-image.png"></p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;using namespace std;const int N &#x3D;100010;int p[N]; &#x2F;&#x2F;存放父结点int n,m;int find(int x)&#123;    &#x2F;&#x2F;寻找祖宗结点+路径压缩    if(p[x]!&#x3D;x) p[x]&#x3D;find(p[x]);    return p[x];&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;              p[i]&#x3D;i;          &#x2F;&#x2F;初始化每个数独自成集合 ,注意每个数是1--n范围内    &#125;    while(m--)&#123;        char op[2];        scanf(&quot;%s&quot;,op);        int a,b;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);           int c&#x3D;find(a),d&#x3D;find(b);        if(op[0]&#x3D;&#x3D;&#39;M&#39;)&#123;            if(c!&#x3D;d) p[c]&#x3D;d;    &#x2F;&#x2F;如果不在同一个集合，就进行合并，即将一个集合的根结点作为另一个集合的孩子        &#125;else &#123;            if(c&#x3D;&#x3D;d)            puts(&quot;Yes&quot;);            else puts(&quot;No&quot;);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="连通块中点的个数"><a href="#连通块中点的个数" class="headerlink" title="连通块中点的个数"></a>连通块中点的个数</h4><blockquote><p>连通指a可以到b，b可以到a</p><img src="file:///C:/Users/Lenovo/AppData/Roaming/marktext/images/2023-01-22-20-18-56-image.png" title="" alt="" width="574"></blockquote><p>    实际上和集合是差不多的，只要两个数在一个集合了，就一定可以互相到达，因此只需要关注第三个操作，前两个操作都是一样的；</p><p>    第三个操作：询问连通块中点的数量(集合的元素个数)</p><p>定义一个cap[N]数组存储每个集合根结点的元素个数，共有两个部分</p><p>1.初始化时每个集合大小都为1，且点独自为一个集合</p><p>2.合并集合时，其中一个集合的根结点被当作另一个集合的孩子时，另一个集合的大小要加上这个集合  即 <mark> <strong>p[find(a)]&#x3D;find(b);   cap[find(b)]+&#x3D;cap[find(a)];</strong></mark> </p><p>代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;using namespace std;const int N &#x3D;100010;&#x2F;&#x2F;连通块其实类似于集合，只要在同一个集合，就可以达到连通的效果&#x2F;&#x2F;并且本题的前两个操作很类似集合的操作，可模仿&#x2F;&#x2F;第三个操作需：合并集合时，维护集合大小int n,m;int p[N];int cap[N];    &#x2F;&#x2F;记录每个根结点代表的集合中点的个数int find(int x)&#123;    if(p[x]!&#x3D;x) p[x]&#x3D;find(p[x]);    return p[x];&#125;int main() &#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123;        p[i]&#x3D;i;        cap[i]&#x3D;1;    &#x2F;&#x2F;初始化小集合和大小    &#125;    while(m--)&#123;        char op[2];        scanf(&quot;%s&quot;,op);        int a,b,c&#x3D;0,d&#x3D;0;        if(op[0]&#x3D;&#x3D;&#39;C&#39;)&#123;            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            c&#x3D;find(a),d&#x3D;find(b);            if(c&#x3D;&#x3D;d) continue;    &#x2F;&#x2F;如果两者已经在一个集合里了，就不要再合并了，否则集合大小有问题            cap[d]+&#x3D;cap[c];        &#x2F;&#x2F;合并集合时，注意要维护一下新的根结点对应集合的大小            p[c]&#x3D;d;        &#125;else if(op[1]&#x3D;&#x3D;&#39;1&#39;)&#123;            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);            c&#x3D;find(a),d&#x3D;find(b);            if(c&#x3D;&#x3D;d) puts(&quot;Yes&quot;);            else puts(&quot;No&quot;);        &#125;else if(op[1]&#x3D;&#x3D;&#39;2&#39;)&#123;            scanf(&quot;%d&quot;,&amp;a);            cout&lt;&lt;cap[find(a)]&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h4><blockquote><p><a href="https://www.acwing.com/problem/content/242/">240. 食物链 - AcWing题库</a> </p></blockquote><p>话不多说了，代码含注释</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*  思路：实际上也是集合的合并以及判定，区别在于我们需要判断是否满足与题目要求的三点相符（假话条件）我们可以在不同维度上(x+n,x+n+n)上额外定义某动物x的捕食域和天敌域根据条件得到假话个数*&#x2F;#include&lt;iostream&gt;using namespace std;const int N &#x3D;2e5+10;    &#x2F;&#x2F;捕食域，天敌域分别存放在x+n和x+n+n的维度上  ,省去多开数组的麻烦int p[N];int n,k;int ans;       &#x2F;&#x2F;记录假话个数int find(int x)&#123;   if(p[x]!&#x3D;x) p[x]&#x3D;find(p[x]);   return p[x];&#125;&#x2F;&#x2F;需反复用到合并集合的操作，定义一个函数   此处定义的是x所在集合接到y所在集合void merge(int x,int y)&#123;    p[find(x)]&#x3D;find(y);&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    for(int i&#x3D;1;i&lt;&#x3D;3*n;i++) p[i]&#x3D;i;         &#x2F;&#x2F;初始化所有域    while(k--)&#123;        int d,x,y;        scanf(&quot;%d%d%d&quot;,&amp;d,&amp;x,&amp;y);        if(x&gt;n||y&gt;n)             ans++;            else if(d&#x3D;&#x3D;1)&#123;               &#x2F;&#x2F;如果x和y是同类  但是y的捕食域有x，或y的天敌域有x，则是假话            if(find(x)&#x3D;&#x3D;find(y+n)||find(x)&#x3D;&#x3D;find(y+n+n))                ans++;            else &#123;   &#x2F;&#x2F;既然是同类，那么他们的捕食和天敌应是一样的                merge(x,y);                merge(x+n,y+n);                 merge(x+n+n,y+n+n);            &#125;        &#125;else &#123;           &#x2F;&#x2F;如果x捕食y  但是x和y是同一个动物、同一类动物、x的天敌域中有y、y的捕食域有x 则是假话            if(x&#x3D;&#x3D;y||find(x)&#x3D;&#x3D;find(y)||find(y+n)&#x3D;&#x3D;find(x))                ans++;            else &#123;                merge(x+n,y);        &#x2F;&#x2F;x的捕食域加入y                merge(x,y+n+n);      &#x2F;&#x2F;y的天敌域加入x                merge(x+n+n,y+n);    &#x2F;&#x2F;根据题目说明，y如果是被x吃，那么y就能吃x的天敌，则y的捕食域加入x的天敌            &#125;        &#125;    &#125;        cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><p>与堆有关的STL：<a href="https://www.cnblogs.com/Bill-LHR/p/6934911.html#:~:text=%E4%BB%8B%E7%BB%8DSTL%E4%B8%AD%E4%B8%8E%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9A%844%E4%B8%AA%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E5%BB%BA%E7%AB%8B%E5%A0%86make_heap%20%28%29%EF%BC%8C%E5%9C%A8%E5%A0%86%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AEpush_heap,%28%29%EF%BC%8C%E5%9C%A8%E5%A0%86%E4%B8%AD%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AEpop_heap%20%28%29%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8Fsort_heap%20%28%29%EF%BC%9A">STL—heap概述及用法 - Bill_LHR - 博客园 (cnblogs.com)</a> </p><p>主要是建立大根堆小根堆</p><blockquote><p>堆是一颗完全二叉树</p><p>小根堆的概念：</p><p>    每个结点小于等于它的左右孩子，则根结点就是最小值</p><p>存储方式（与完全二叉树相同）：一维数组</p><p>    从1开始存，1位置是根结点,x的左孩子下标为2x,右孩子下标为2x+1</p><p>主要的两个操作 down(x),up(x);        调整堆为小根堆的操作</p><blockquote><p> down的操作是如果x变大，就要将其向下每一步与最小的孩子交换，最终重新成为小根堆；</p><p>up是x变小，将其向上如果小于父结点就进行交换，最终得到新的小根堆</p></blockquote></blockquote></blockquote><h4 id="手写堆排序"><a href="#手写堆排序" class="headerlink" title="手写堆排序"></a>手写堆排序</h4><p>主要的操作：</p><p>STL可支持前三个操作(但后两个可以间接实现)</p><p>1.插入一个数</p><p>2.求集合中的最小值</p><p>3.删除最小值</p><p>4.删除任意一个元素</p><p>5.修改任意一个元素</p><p><u>插入和删除的时间复杂度与树高度有关，则为logn</u> </p><blockquote><p>1.插入一个数到堆中，并调整为小根堆      插入到末尾后往上移</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">heap[++size]&#x3D;x; up(size);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.删除最小值</p><p>将最后一个元素heap[size]覆盖根结点heap[1],后size–，再进行down(1);调整即可</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">heap[1]&#x3D;heap[size];    size--;   down(1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.删除任意一个元素,删去第k个位置的数</p><p> 将最后一个元素heap[size]覆盖到第k个元素heap[k]，size–;最后调整第k个位置，</p><p>这里可以判断如果数变小了就上移up(k),否则变大了down(k); </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;直接上下调整一下更方便heap[k]&#x3D;heap[size];    size--;     down(k),up(k);&#x2F;&#x2F;或者判断一下，但是还要存temp：temp&#x3D;heap[k];  heap[k]&#x3D;heap[size];   size--;  if(temp&gt;heap[k]) up(k);    &#x2F;&#x2F;变小了else if(temp&lt;heap[k]) down(k);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 4.修改任意一个元素</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">heap[k]&#x3D;x;   down(k),up(k);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>[堆排序](<a href="https://www.acwing.com/problem/content/840/">838. 堆排序 - AcWing题库</a>) </p><blockquote><p>如题。</p><p><font color=#lightskyblue>本题只需要使用到down进行小根堆的生成和建立</font> </p></blockquote><p>代码实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N&#x3D;100010;int h[N];   int cap;     &#x2F;&#x2F;size好像有冲突，还是用cap吧 (capcity)int n,m;&#x2F;&#x2F;down，如果当前结点不满足小根堆条件，就和它的最小的孩子进行交换，直到不能交换为止void down(int u)&#123;    int t&#x3D;u;    &#x2F;&#x2F;如果它的左孩子存在并且大于左孩子就与左孩子交换    if(u * 2 &lt;&#x3D; cap &amp;&amp; h[t]&gt;h[u*2]) t&#x3D;u*2;    &#x2F;&#x2F;如果右孩子结点小于左孩子，就交换根结点与右孩子，否则就与左孩子交换    if(u * 2 + 1 &lt;&#x3D;cap &amp;&amp; h[t]&gt;h[u*2+1]) t&#x3D;u*2+1;    &#x2F;&#x2F;如果发生交换了，就下标对应的值交换,并且将这个数继续向下比较，直到不能交换为止    if(t!&#x3D;u)&#123;        swap(h[t],h[u]);        down(t);    &#125;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    cap&#x3D;n;    for(int i&#x3D;1;i&lt;&#x3D;n;i++) scanf(&quot;%d&quot;,&amp;h[i]);    for(int i&#x3D;n&#x2F;2; i ;i--)&#123;         &#x2F;&#x2F;树的最后一层不需要down，从倒数第二层开始进行每个元素的down即可生成小根堆        down(i);    &#125;    while(m--)&#123;        &#x2F;&#x2F;依次输出堆顶元素即最小值        printf(&quot;%d &quot;,h[1]);         &#x2F;&#x2F;输出后删去        h[1]&#x3D;h[cap]; cap--; down(1);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的基本操作代码实现</title>
      <link href="/2022/08/04/dan-lian-biao-de-ji-ben-cao-zuo-dai-ma-shi-xian/"/>
      <url>/2022/08/04/dan-lian-biao-de-ji-ben-cao-zuo-dai-ma-shi-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>        在实现顺序表的基本操作后，觉得自己对单链表基本操作的思路无大问题，因此当时没有对链表基本操作进行实现，在后来的稀疏多项式的运算中需要运用到单链表(顺序表实现会造成大量空间的浪费)，而自己并没有实现过这些基本操作，为防止在做稀疏多项式的运算时出现难以解决的问题，打算再把单链表的基本操作实现一遍。并写一篇博客，耗时：70分钟。</p><p>        希望能够对您有一定帮助和参考价值。新csdner，有所不足尽管提出。</p><p>        如果看完后有点点帮助，可以去CSDN给俺点一个赞嘛？（期待脸q(≧▽≦q)）</p><p>        <a href="https://blog.csdn.net/m0_67647682/article/details/126161385?spm=1001.2014.3001.5501">单链表的基本操作代码实现(C语言版)_KT pro的博客-CSDN博客</a></p><h2 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h2><p>        单链表的基本操作包括单链表的<strong>初始化</strong>、<strong>判断空链表</strong>、<strong>销毁</strong>、<strong>清空</strong>以及求<strong>表长</strong>这些较为简单的操作，还有更为重要的<strong>单链表的取值、按值查找返回元素所在地址、按值查找返回元素所对应序号、结点插入和删除以及头<strong><strong>插法</strong></strong>和尾<strong><strong>插法</strong></strong>建立单链表</strong>。目前只实现了这些操作，并进行的测试。</p><h2 id="准备工作（头文件、各种宏定义以及结构体定义）"><a href="#准备工作（头文件、各种宏定义以及结构体定义）" class="headerlink" title="准备工作（头文件、各种宏定义以及结构体定义）"></a>准备工作（头文件、各种宏定义以及结构体定义）</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#define OK 1#define ERROR 0        &#x2F;*用于返回函数执行的状态值*&#x2F;typedef int Status;typedef int ElemType;typedef struct Node &#123;    ElemType data;             &#x2F;&#x2F;存储数据    struct Node *next;&#x2F;&#x2F;存储下一个元素的地址&#125; Node;typedef struct Node *LinkList; &#x2F;* 定义LinkList *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动"></p><h3 id="一-较简单操作"><a href="#一-较简单操作" class="headerlink" title="一.较简单操作"></a>一.较简单操作</h3><h3 id="1-单链表的初始化"><a href="#1-单链表的初始化" class="headerlink" title="1.单链表的初始化"></a>1.单链表的初始化</h3><p>        单链表的初始化指生成一个只有头指针的单链表，并将其指向的头结点的指针域置空。需要注意的是，传入的参数为LinkList *L；为什么L本来就是指针类型了还要加   “ * “呢，因为你要知道你是要对链表的本质(内存，指针指向等)进行更改而不是使用链表进行元素的查找取值等，如果只是这些操作，只要告诉计算机你要查找的对象是哪个表，即把链表的头指针传过去就行（这样就不需要添加 “ * “ ）。以下是代码实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;* 初始化链式线性表 *&#x2F;Status IniList(LinkList *L) &#123;    *L&#x3D;(LinkList)malloc(sizeof(Node)); &#x2F;* 产生头结点,并使L指向此头结点 *&#x2F;    (*L)-&gt;next&#x3D;NULL; &#x2F;* 指针域为空 *&#x2F;    return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动"></p><h3 id="2-判断单链表是否为空表"><a href="#2-判断单链表是否为空表" class="headerlink" title="2.判断单链表是否为空表"></a>2.判断单链表是否为空表</h3><p>        只需要判断对应单链表头结点的指针域是否为空即可。该实现我使用的是bool类型返回值，实际上c语言中逻辑值就是0，1，因此多此一举了属于是；如果要用bool类型需要添加头文件#include&lt;stdbool.h&gt;。以下是代码实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool Empty(LinkList L) &#123;    if(L-&gt;next&#x3D;&#x3D;NULL)        return true;        return false;&#x2F;&#x2F;main函数中测试bool c&#x3D;Empty(L); printf(&quot;%d&quot;,c);  返回 1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动"></p><h3 id="3-单链表的销毁"><a href="#3-单链表的销毁" class="headerlink" title="3.单链表的销毁"></a>3.单链表的销毁</h3><p>        单链表的销毁指将链表中的所有结点包括头结点都释放掉（c语言中使用free（），c++中使用delete（））。由于仍然是对单链表的“本质”进行修改，所以参数需加  “ * “ ，思路是利用头指针以及新指针p(用于释放其指向的结点)，在释放之前，先将头指针后移，否则找不到下一结点。以下是代码实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;* 单链表的销毁*&#x2F;         Status DestoryList(LinkList *L) &#123;    LinkList p&#x3D;*L;              &#x2F;&#x2F;p此时指向头结点    &#x2F;&#x2F;注意此时不能直接释放p，因为头结点中还存放着下一结点的地址，释放就找不到下一个结点了    while(*L) &#123;        *L&#x3D;(*L)-&gt;next;        free(p);                    p&#x3D;*L;        &#125;    return OK;    &#x2F;&#x2F;测试int b&#x3D;DestoryList(&amp;L);  printf(&quot;%d&quot;,b);ListTraverse(L); 输出1，且并不打印其他的&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-单链表的清空"><a href="#4-单链表的清空" class="headerlink" title="4.单链表的清空"></a>4.单链表的清空</h3><p>        将除头结点以外的结点释放，并将头结点的指针域置空。与销毁不同，该操作的头指针不能动，所以还需要新定义一个指针对下一结点进行定位。以下是代码实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*清空链表*&#x2F;Status ClearList(LinkList L) &#123;    LinkList p,q;    &#x2F;&#x2F;p用于指向需要释放的结点，q用于在p释放之前指向下一结点，以使p移动    p&#x3D;L-&gt;next;       &#x2F;&#x2F;p指向首元结点    while(p) &#123;        q&#x3D;p-&gt;next;   &#x2F;&#x2F;q指向下一结点        free(p);        p&#x3D;q;    &#125;    &#x2F;&#x2F;最后不要忘了，结点释放后还需要将头结点的指针域更改为NULL，形成空表    L-&gt;next&#x3D;NULL;    return OK;    &#x2F;*测试CreateList(&amp;L,n); ClearList(L);ListTraverse(L);&#x2F;&#x2F;不输出创建时输入的元素*&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-求单链表的表长"><a href="#5-求单链表的表长" class="headerlink" title="5.求单链表的表长"></a>5.求单链表的表长</h3><p>        以下是代码实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*求链表的表长*&#x2F;int ListLength(LinkList L) &#123;    LinkList p;   &#x2F;&#x2F;用于指向除头结点以外的结点    int count&#x3D;0;    p&#x3D;L-&gt;next;    while(p) &#123;        count++;        p&#x3D;p-&gt;next;    &#125;    return count;     &#x2F;&#x2F;测试  printf(&quot;%d&quot;,ListLength(L)); 输出正确&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二-较重要操作"><a href="#二-较重要操作" class="headerlink" title="二.较重要操作"></a>二.较重要操作</h2><h3 id="1-单链表的取值"><a href="#1-单链表的取值" class="headerlink" title="1.单链表的取值"></a>1.单链表的取值</h3><p>        取出链表中位置 i 对应的元素，i表示的是序号，不按逻辑层面确定。思路：将指针p移动到对应序号逻辑层面存储位置，随后将其指向的元素返回即可。注意循环终止条件，以下是代码实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*获得某一元素*&#x2F;  &#x2F;&#x2F;返回链表中第i位置的元素Status GetElem(LinkList L,int i,ElemType *e) &#123;    Node *p;    p&#x3D;L-&gt;next;    int j &#x3D; 1;    for(; p&amp;&amp;j&lt;i ;) &#123;        p &#x3D; p-&gt;next; &#x2F;*p所指元素存在且j&lt;1时循环执行*&#x2F;        ++j;    &#125;    if(!p||j&gt;i) &#x2F;&#x2F;j大于i的情况：如i传入的为0或负数        return ERROR;    *e&#x3D;p-&gt;data;    return OK; &#x2F;&#x2F;测试：元素返回正确&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-单链表元素的查找"><a href="#2-单链表元素的查找" class="headerlink" title="2.单链表元素的查找"></a>2.单链表元素的查找</h3><p>        查找分为按值查找返回元素所在地址和返回所在序号，思路：定义一个指针p指向头结点，随后利用循环将指针p进行移动即对链表进行遍历，将每次循环时结点的数据与待查找数据比较，如果找到则返回对应地址(反映为当前指针的指向),以及对应的序号。以下是代码实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;查找&#x2F;*按值查找数据所在地址并返回*&#x2F;  &#x2F;&#x2F;参数为所需查询链表，需要查询的数据，返回p的地址LinkList searchAD(LinkList L,ElemType e) &#123;    LinkList p;    p&#x3D;L-&gt;next;    for(int i&#x3D;0; p&amp;&amp;i&lt;ListLength(L); i++) &#123;        if(p-&gt;data&#x3D;&#x3D;e)            break;        p&#x3D;p-&gt;next;    &#125;    return p; &#x2F;&#x2F;测试；printf(&quot;%p&quot;,searchAD(L,5));  5所在元素次序不同，打印的地址不同&#125;&#x2F;*按值查找数据所在链表的序号(第几个元素)*&#x2F;  &#x2F;&#x2F;参数：所需查询链表，所需查询数据，返回数据所在序号int searchNum(LinkList L,ElemType e) &#123;    LinkList p;    p&#x3D;L-&gt;next;    for(int i&#x3D;0; p&amp;&amp;i&lt;ListLength(L) ; i++) &#123;        if(p-&gt;data&#x3D;&#x3D;e) &#123;    &#x2F;&#x2F;遍历链表中p所指项结点的数据，与e比较，找到后返回对应序号即可            return i+1;        &#125;        p&#x3D;p-&gt;next; &#x2F;&#x2F;当前结点的数据不等于e则p指针后移    &#125;    return 0;  &#x2F;&#x2F;测试：printf(&quot;%d&quot;,searchNum(L,5));  返回5所在位置正确,如果不存在所查询数据，返回0&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-单链表的结点插入"><a href="#3-单链表的结点插入" class="headerlink" title="3.单链表的结点插入"></a>3.单链表的结点插入</h3><p>        思路：先将待插入位置找到，利用其前一个位置的指针p对其后继进行保留，随后定义一个新结点并用指向它的指针q，进行前驱后继的链接。以下是代码实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;链表元素的插入    &#x2F;&#x2F;参数:需要插入数据的链表，需要插入元素的位置，需要插入的数据，返回插入结束状态Status ListInsert(LinkList L,int i,ElemType e) &#123;    LinkList p,q;    p&#x3D;L;        &#x2F;&#x2F;指向头结点    &#x2F;&#x2F;先新建并初始化好需要插入的结点，用指针q指向它    q&#x3D;(Node *)malloc(sizeof(Node));    q-&gt;data&#x3D;e;    q-&gt;next&#x3D;NULL;    for(int j&#x3D;0; p&amp;&amp;j&lt;i-1 ; j++) &#123;         if(i&gt;ListLength(L)+1)            return ERROR;   &#x2F;&#x2F;如果插入的位置大于链表的尾结点后面的一个位置,则返回错误        p&#x3D;p-&gt;next;     &#125;    &#x2F;&#x2F;将待插入结点的前后结点与之形成链式关系    q-&gt;next&#x3D;p-&gt;next;    &#x2F;&#x2F;接后继结点    p-&gt;next&#x3D;q;            &#x2F;&#x2F;接前驱结点    return OK;    &#x2F;*        测试：ListInsert(L,4,99);    ListTraverse(L); 在表中元素为5个的情况下        插入位置为1--6均可正确插入，如果插入位置大于等于7，则不插入元素                  *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-单链表的结点删除"><a href="#4-单链表的结点删除" class="headerlink" title="4.单链表的结点删除"></a>4.单链表的结点删除</h3><p>        思路：同样是先找到待删除结点，将q指针指向它，并新定义一个指针p对其前驱进行指向，以便后续链接，接好待删除结点的前驱后继后即可释放该结点。以下是实现代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;链表元素的删除  &#x2F;&#x2F;参数需要删除元素的链表，需要删除的结点Status deleElem(LinkList L,int i) &#123;    LinkList p,q;   &#x2F;&#x2F;p指向删除位置的前一结点,q指向需要删除的结点    p&#x3D;L;  &#x2F;&#x2F;p指向头结点    &#x2F;&#x2F;首先需要将p移动到删除结点的前一结点    for(int j&#x3D;0; p&amp;&amp;j&lt;i-1; j++) &#123;        p&#x3D;p-&gt;next;    &#125;    q&#x3D;p-&gt;next;  &#x2F;&#x2F;如果所需删除结点存在,则将q指向它，如果不存在返回错误，不执行删除    if(!q)        return ERROR;  &#x2F;&#x2F;判断删除的结点是否存在    p-&gt;next&#x3D;p-&gt;next-&gt;next;  &#x2F;&#x2F;也可以p-&gt;next&#x3D;q-&gt;next;但一定要在释放之前将p指向下一结点，否则找不到    free(q);    return OK;    &#x2F;*    测试：    deleElem(L,1);    ListTraverse(L);假设表中有5个元素，则第1--5个位置的元素正常删除，如果为大于等于6的位置，不删除    *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-单链表的创建"><a href="#5-单链表的创建" class="headerlink" title="5.单链表的创建"></a>5.单链表的创建</h3><p>        包括尾插法和头插法，进行单链表的内存分配和结点的添加与赋值。以下是代码实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*头插法创建链表*&#x2F; &#x2F;&#x2F;输入n个元素 ，元素从头开始依次插入Status CreateList_H(LinkList *L,int n) &#123;    LinkList p,r;  &#x2F;&#x2F;p用于指向新结点,r指向头结点    &#x2F;&#x2F;建立一个带有头结点的单链表并将指针域置为空    *L&#x3D;(LinkList)malloc(sizeof(Node));    r&#x3D;*L;    r-&gt;next&#x3D;NULL;&#x2F;&#x2F;结点添加与赋值    for(int i&#x3D;n; i&gt;0; i--) &#123;        p&#x3D;(Node *)malloc(sizeof(Node));        printf(&quot;请输入该链表的第%d个元素：&quot;,i);        scanf(&quot;%d&quot;,&amp;p-&gt;data);        p-&gt;next&#x3D;NULL;        p-&gt;next&#x3D;r-&gt;next;        r-&gt;next&#x3D;p;    &#125;    return OK;    &#x2F;*测试:printf(&quot;请输入头插法创建链表的元素个数：&quot;);    scanf(&quot;%d&quot;,&amp;n);    CreateList_H(&amp;L_H,n);    ListTraverse(L_H);  新建正常    *&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;*尾插法创建链表*&#x2F; &#x2F;&#x2F;输入n个元素， 元素从尾部依次接入Status CreateList(LinkList *L,int n) &#123;    LinkList p,r;&#x2F;&#x2F;p用于指向新结点(待插入结点)，r指向尾部结点    *L &#x3D; (LinkList)malloc(sizeof(Node));    r&#x3D;*L;  &#x2F;&#x2F;刚开始时r指向头结点    r-&gt;next&#x3D;NULL;    for(int i&#x3D;0; i&lt;n; i++) &#123;        p&#x3D;(Node *)malloc(sizeof(Node));   &#x2F;&#x2F;注意这里不要忘记将这块内存定义为Node的指针类型        printf(&quot;请输入该链表的第%d个元素：&quot;,i+1);        scanf(&quot;%d&quot;,&amp;p-&gt;data);        p-&gt;next&#x3D;NULL;        r-&gt;next&#x3D;p;        r&#x3D;r-&gt;next;    &#125;    r-&gt;next&#x3D;NULL;    return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="以下是主函数以及函数声明"><a href="#以下是主函数以及函数声明" class="headerlink" title="以下是主函数以及函数声明"></a>以下是主函数以及函数声明</h1><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Status IniList(LinkList *L);Status GetElem(LinkList L,int i,ElemType *e);Status CreateList(LinkList *L,int n);  &#x2F;&#x2F;尾插法Status CreateList_H(LinkList *L,int n);&#x2F;&#x2F;头插法Status visit(ElemType c);Status ListTraverse(LinkList L);bool Empty(LinkList L);Status DestoryList(LinkList *L);Status ClearList(LinkList L);int ListLength(LinkList L);LinkList searchAD(LinkList L,ElemType e);int searchNum(LinkList L,ElemType e);Status ListInsert(LinkList L,int i,ElemType e);Status deleElem(LinkList L,int i);int main() &#123;    LinkList L,L_H;    int n;    int a&#x3D;IniList(&amp;L);     &#x2F;&#x2F;a用于判断是否成功初始化    printf(&quot;请输入尾插法创建链表的元素个数：&quot;);    scanf(&quot;%d&quot;,&amp;n);    CreateList(&amp;L,n);    ListTraverse(L);    printf(&quot;请输入头插法创建链表的元素个数：&quot;);    scanf(&quot;%d&quot;,&amp;n);    CreateList_H(&amp;L_H,n);    ListTraverse(L_H);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>        为了更方便的对链表进行输出，新定义了两个子函数实现，代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;打印元素Status visit(ElemType c) &#123;    printf(&quot;%d &quot;,c);    return OK;&#125;&#x2F;&#x2F;遍历链表Status ListTraverse(LinkList L) &#123;    LinkList p&#x3D;L-&gt;next;    printf(&quot;链表中所有元素为： &quot;);    if(!p)        return ERROR;&#x2F;&#x2F;如果首元结点不存在返回0    while(p) &#123;        visit(p-&gt;data);        p&#x3D;p-&gt;next;    &#125;    printf(&quot;\n&quot;);    return OK;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/23/hello-world/"/>
      <url>/2022/07/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
